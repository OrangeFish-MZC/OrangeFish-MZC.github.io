<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo+Next搭建个人博客</title>
    <url>/2020/02/04/Hexo+Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>博客有第三方平台，也可以自建，比较早的有博客园、CSDN，近几年新兴的也比较多诸如：WordPress、segmentFault、简书、掘金、知乎专栏、Github Page 等等。</p>
<p>这次我要说的就是 Github Page + Hexo 搭建个人博客的方式！Github Page 是 Github 提供的一种免费的静态网页托管服务（所以想想免费的空间不用也挺浪费的哈哈哈），可以用来托管博客、项目官网等静态网页。支持 Jekyll、Hugo、Hexo 编译静态资源，这次我们的主角就是 Hexo 了，具体的内容下面在文章内介绍。</p>
<h2 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ cd &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<p>新建完成后，指定文件夹的目录如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.├── _config.yml</span><br><span class="line"> ├── package.json</span><br><span class="line"> ├── scaffolds</span><br><span class="line"> ├── source</span><br><span class="line"> |   ├── _drafts</span><br><span class="line"> |   └── _posts</span><br><span class="line"> └── themes</span><br></pre></td></tr></table></figure>

<p><strong>_config.yml</strong></p>
<p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration" target="_blank" rel="noopener">配置</a> 信息，您可以在此配置大部分的参数。</p>
<p><strong>package.json</strong></p>
<p>应用程序的信息。<a href="https://ejs.co/" target="_blank" rel="noopener">EJS</a>, <a href="http://learnboost.github.io/stylus/" target="_blank" rel="noopener">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a> renderer 已默认安装，您可以自由移除。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">package.json</span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hexo-site"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"hexo"</span>: &#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">""</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"hexo"</span>: <span class="string">"^3.8.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-archive"</span>: <span class="string">"^0.1.5"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-category"</span>: <span class="string">"^0.1.3"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-index"</span>: <span class="string">"^0.2.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-generator-tag"</span>: <span class="string">"^0.2.0"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-ejs"</span>: <span class="string">"^0.3.1"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-stylus"</span>: <span class="string">"^0.3.3"</span>,</span><br><span class="line">    <span class="attr">"hexo-renderer-marked"</span>: <span class="string">"^0.3.2"</span>,</span><br><span class="line">    <span class="attr">"hexo-server"</span>: <span class="string">"^0.3.3"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>scaffolds</strong></p>
<p><a href="https://hexo.io/zh-cn/docs/writing" target="_blank" rel="noopener">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</p>
<p>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p>
<p><strong>source</strong></p>
<p>资源文件夹是存放用户资源的地方。除 <code>_posts</code> 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 <code>public</code> 文件夹，而其他文件会被拷贝过去。</p>
<p><strong>themes</strong></p>
<p><a href="https://hexo.io/zh-cn/docs/themes" target="_blank" rel="noopener">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</p>
<h2 id="3-Hexo的Next主题详细配置"><a href="#3-Hexo的Next主题详细配置" class="headerlink" title="3. Hexo的Next主题详细配置"></a>3. Hexo的Next主题详细配置</h2><p>经过一番不懈的努力，我们终于按照<a href="https://www.jianshu.com/p/51617690f8ca" target="_blank" rel="noopener">Hexo免费搭建一个属于自己的博客</a>搭建好了一个属于自己的博客，并且还安装了一个Next主题，但是我们的博客一开始还是很简陋的，我们需要把她装修一下。</p>
<blockquote>
<ul>
<li>在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。<br> 为了描述方便，在以下说明中，将前者称为<strong><em>站点配置文件</em></strong>， 后者称为<strong><em>主题配置文件</em></strong>。</li>
<li>以下所有终端执行的命令都在你的Hexo根目录下</li>
</ul>
</blockquote>
<h4 id="1、基本信息配置"><a href="#1、基本信息配置" class="headerlink" title="1、基本信息配置"></a>1、基本信息配置</h4><blockquote>
<p>基本信息包括：博客标题、作者、描述、语言等等。</p>
</blockquote>
<p>打开 <strong><em>站点配置文件</em></strong> ，找到Site模块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标题</span><br><span class="line">subtitle: 副标题</span><br><span class="line">description: 描述</span><br><span class="line">author: 作者</span><br><span class="line">language: 语言（简体中文是zh-Hans）</span><br><span class="line">timezone: 网站时区（Hexo 默认使用您电脑的时区，不用写）</span><br></pre></td></tr></table></figure>

<p>关于 <strong><em>站点配置文件</em></strong> 中的其他配置可参考[站点配置</p>
<h4 id="2、菜单设置"><a href="#2、菜单设置" class="headerlink" title="2、菜单设置"></a>2、菜单设置</h4><blockquote>
<p>菜单包括：首页、归档、分类、标签、关于等等</p>
</blockquote>
<p>我们刚开始默认的菜单只有首页和归档两个，不能够满足我们的要求，所以需要添加菜单，打开 <strong><em>主题配置文件</em></strong> 找到<code>Menu Settings</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home                          <span class="comment">//首页</span></span><br><span class="line">  archives: /archives/ || archive          <span class="comment">//归档</span></span><br><span class="line">  categories: /categories/ || th           <span class="comment">//分类</span></span><br><span class="line">  tags: /tags/ || tags                     <span class="comment">//标签</span></span><br><span class="line">  about: /about/ || user                   <span class="comment">//关于</span></span><br><span class="line">  <span class="meta">#schedule: /schedule/ || calendar        <span class="comment">//日程表</span></span></span><br><span class="line">  <span class="meta">#sitemap: /sitemap.xml || sitemap        <span class="comment">//站点地图</span></span></span><br><span class="line">  <span class="meta">#commonweal: /404/ || heartbeat          <span class="comment">//公益404</span></span></span><br></pre></td></tr></table></figure>

<p>看看你需要哪个菜单就把哪个取消注释打开就行了；<br> 关于后面的格式，以<code>archives: /archives/ || archive</code>为例：<br> <code>||</code> 之前的<code>/archives/</code>表示标题“归档”，关于标题的格式可以去<code>themes/next/languages/zh-Hans.yml</code>中参考或修改<br> <code>||</code>之后的<code>archive</code>表示图标，可以去<a href="https://links.jianshu.com/go?to=http%3A%2F%2Ffontawesome.io%2Ficons%2F" target="_blank" rel="noopener">Font Awesome</a>中查看或修改，Next主题所有的图标都来自Font Awesome。</p>
<p><strong>踩坑说明，修改主题配置后主题图标不生效，具体情况如图所示</strong></p>
<p><img src="/2020/02/04/Hexo+Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E8%8F%9C%E5%8D%95%E5%9B%BE%E6%A0%87%E4%B8%8D%E6%98%BE%E7%A4%BA.png" alt></p>
<p><strong>原因：</strong>小编当时也在网上搜了很多帖子，每一个修改步骤都是按照帖子里面来的，先修改<strong>主题</strong>配置文件中的<em>menu</em>配置，然后再修改<em>menu_icons</em>的配置，但是无论怎么改都是不生效；后来小编发现，在最新版的next主题中，菜单图标设置已经不是通过<em>menu_icons</em>属性设置了，这个属性只用于设置是否显示图标，新版主题设置直接就在<em>menu</em>属性中，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">home: &#x2F; || home</span><br></pre></td></tr></table></figure>

<p>其实，在clone主题之后初始化的文件中就是这样写的，只怪小编没有仔细看就安装旧版的教程改了~</p>
<p>但是，按照新版设置改过来之后，又出现了新的问题，图标的样式虽然显示出来了，但是点击图标跳转到的网址却是错误的，如下图所示，跳转的网址莫名其妙多加了%20，导致网址错误加载不出页面~</p>
<p><img src="/2020/02/04/Hexo+Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/%E8%8F%9C%E5%8D%95%E9%85%8D%E7%BD%AE%E5%9C%B0%E5%9D%80%E9%94%99%E8%AF%AF.png" alt></p>
<p>这个问题小编尝试了很久，才发现是配置图标的时候，<strong>||符号前面多了一个空格</strong>导致的，删掉多余的空格就OK啦~~</p>
<h4 id="3、Next主题样式设置"><a href="#3、Next主题样式设置" class="headerlink" title="3、Next主题样式设置"></a>3、Next主题样式设置</h4><p>我们百里挑一选择了Next主题，不过Next主题还有4种风格供我们选择，打开 <strong><em>主题配置文件</em></strong> 找到<code>Scheme Settings</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment"># scheme: Mist</span></span><br><span class="line">scheme: Pisces</span><br><span class="line"><span class="comment"># scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<p>4种风格大同小异，本人用的是Pisces风格，你们可以选择自己喜欢的风格。</p>
<h4 id="4、侧栏设置"><a href="#4、侧栏设置" class="headerlink" title="4、侧栏设置"></a>4、侧栏设置</h4><blockquote>
<p>侧栏设置包括：侧栏位置、侧栏显示与否、文章间距、返回顶部按钮等等</p>
</blockquote>
<p>打开 <strong><em>主题配置文件</em></strong> 找到<code>sidebar</code>字段</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sidebar:</span><br><span class="line"># Sidebar Position - 侧栏位置（只对Pisces | Gemini两种风格有效）</span><br><span class="line">  position: left        <span class="comment">//靠左放置</span></span><br><span class="line">  <span class="meta">#position: right      <span class="comment">//靠右放置</span></span></span><br><span class="line"></span><br><span class="line"># Sidebar Display - 侧栏显示时机（只对Muse | Mist两种风格有效）</span><br><span class="line">  <span class="meta">#display: post        <span class="comment">//默认行为，在文章页面（拥有目录列表）时显示</span></span></span><br><span class="line">  display: always       <span class="comment">//在所有页面中都显示</span></span><br><span class="line">  <span class="meta">#display: hide        <span class="comment">//在所有页面中都隐藏（可以手动展开）</span></span></span><br><span class="line">  <span class="meta">#display: remove      <span class="comment">//完全移除</span></span></span><br><span class="line"></span><br><span class="line">  offset: <span class="number">12</span>            <span class="comment">//文章间距（只对Pisces | Gemini两种风格有效）</span></span><br><span class="line"></span><br><span class="line">  b2t: <span class="literal">false</span>            <span class="comment">//返回顶部按钮（只对Pisces | Gemini两种风格有效）</span></span><br><span class="line"></span><br><span class="line">  scrollpercent: <span class="literal">true</span>   <span class="comment">//返回顶部按钮的百分比</span></span><br></pre></td></tr></table></figure>

<h4 id="5、头像设置"><a href="#5、头像设置" class="headerlink" title="5、头像设置"></a>5、头像设置</h4><p>打开 <strong><em>主题配置文件</em></strong> 找到<code>Sidebar Avatar</code>字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line">avatar: /images/header.jpg</span><br></pre></td></tr></table></figure>

<p>这是头像的路径，只需把你的头像命名为<code>header.jpg</code>（随便命名）放入<code>themes/next/source/images</code>中，将<code>avatar</code>的路径名改成你的头像名就OK啦！</p>
<h4 id="6、添加分类模块"><a href="#6、添加分类模块" class="headerlink" title="6、添加分类模块"></a>6、添加分类模块</h4><p>1、新建一个分类页面</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> page categories</span><br></pre></td></tr></table></figure>

<p>2、你会发现你的<code>source</code>文件夹下有了<code>categorcies/index.md</code>，打开<code>index.md</code>文件将title设置为<code>title: 分类</code><br>3、打开 <strong><em>主题配置文件</em></strong> 找到<code>menu</code>，将categorcies取消注释<br>4、把文章归入分类只需在文章的顶部标题下方添加<code>categories</code>字段，即可自动创建分类名并加入对应的分类中<br>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 分类测试文章标题</span><br><span class="line">categories: 分类名</span><br></pre></td></tr></table></figure>

<h4 id="7、添加标签模块"><a href="#7、添加标签模块" class="headerlink" title="7、添加标签模块"></a>7、添加标签模块</h4><p>1、新建一个标签页面</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> page tags</span><br></pre></td></tr></table></figure>

<p>2、你会发现你的<code>source</code>文件夹下有了<code>tags/index.md</code>，打开<code>index.md</code>文件将title设置为<code>title: 标签</code><br>3、打开 <strong><em>主题配置文件</em></strong> 找到<code>menu</code>，将tags取消注释<br>4、把文章添加标签只需在文章的顶部标题下方添加<code>tags</code>字段，即可自动创建标签名并归入对应的标签中<br>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签测试文章标题</span><br><span class="line">tags: </span><br><span class="line">  - 标签1</span><br><span class="line">  - 标签2</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h4 id="8、添加关于模块"><a href="#8、添加关于模块" class="headerlink" title="8、添加关于模块"></a>8、添加关于模块</h4><p>1、新建一个关于页面</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ hexo <span class="keyword">new</span> page about</span><br></pre></td></tr></table></figure>

<p>2、你会发现你的<code>source</code>文件夹下有了<code>about/index.md</code>，打开<code>index.md</code>文件即可编辑关于你的信息，可以随编辑。<br>3、打开 <strong><em>主题配置文件</em></strong> 找到<code>menu</code>，将about取消注释</p>
<h4 id="9、添加搜索功能"><a href="#9、添加搜索功能" class="headerlink" title="9、添加搜索功能"></a>9、添加搜索功能</h4><p>1、安装 hexo-generator-searchdb插件</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>2、打开 <strong><em>站点配置文件</em></strong> 找到<code>Extensions</code>在下面添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>

<p>3、打开 <strong><em>主题配置文件</em></strong> 找到<code>Local search</code>，将<code>enable</code>设置为<code>true</code></p>
<h4 id="10、添加阅读全文按钮"><a href="#10、添加阅读全文按钮" class="headerlink" title="10、添加阅读全文按钮"></a>10、添加阅读全文按钮</h4><p>NexT主题下的首页默认是显示每一篇文章的全文的，如果文章很长就要往下拉很远才能看到下一篇文章</p>
<p>我们要设置成每一篇文章只显示150个字的摘要，然后底部显示一个阅读原文的按钮，点击可以进入阅读全文</p>
<p>1、打开NexT主题的配置文件，站点根目录\themes\next_config.yml<br>2、搜索auto_excerpt，然后配置如下，开启摘要，设置摘要长度为150个字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Automatically Excerpt (Not recommend).</span><br><span class="line"># Use &lt;!-- more --&gt; in the post to control excerpt accurately.</span><br><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>

<h4 id="11、去掉文章目录标题的自动编号"><a href="#11、去掉文章目录标题的自动编号" class="headerlink" title="11、去掉文章目录标题的自动编号"></a>11、去掉文章目录标题的自动编号</h4><p>我们自己写文章的时候一般都会自己带上标题编号，但是默认的主题会给我们带上编号，很是别扭，如何去掉呢？<br>打开<strong><em>主题配置文件</em></strong>，找到</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># Table Of Contents in the Sidebar</span><br><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Automatically add list number to toc.</span><br><span class="line">  number: false</span><br><span class="line"></span><br><span class="line">  # If true, all words will placed on next lines if header width longer then sidebar width.</span><br><span class="line">  wrap: false</span><br></pre></td></tr></table></figure>

<p>将<code>number</code>改为<code>false</code>即可</p>
<h4 id="12、添加本地图片"><a href="#12、添加本地图片" class="headerlink" title="12、添加本地图片"></a>12、添加本地图片</h4><p>1、 把<strong><em>主页配置文件</em></strong><code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
<p>2、 在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件，来自大佬：大佬的git](<a href="https://github.com/CodeFalling/hexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a>)</p>
<p>3、 等待一小段时间后，再运行<code>hexo n &quot;xxxx&quot;</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹</p>
<p>4、 最后在<code>xxxx.md</code>中想引入图片时，先把图片复制到xxxx这个文件夹中，然后只需要在xxxx.md中按照markdown的格式引入图片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![你想输入的替代文字](xxxx&#x2F;图片名.jpg)</span><br></pre></td></tr></table></figure>

<p><strong>注意： xxxx是这个md文件的名字，也是同名文件夹的名字。只需要有文件夹名字即可，不需要有什么绝对路径。你想引入的图片就只需要放入xxxx这个文件夹内就好了，很像引用相对路径。</strong></p>
<p>5、 最后检查一下，<code>hexo g</code>生成页面后，进入<code>public\2017\02\26\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是``，而不是`。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</p>
<p><strong>踩坑说明，部署上去图片不显示，查看图片路径为/.com//…</strong></p>
<p><strong>原因是：</strong>使用 npm install <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2FCodeFalling%2Fhexo-asset-image" target="_blank" rel="noopener">https://github.com/CodeFalling/hexo-asset-image</a> –save 安装0.0.5版本的hexo-asset-image插件。 使用 npm install hexo-asset-image –save 安装的是1.0.0版本的hexo-asset-image插件。 两者最直接的区别是映射关系不同。也就是因为插件版本更新了，之前的使用方法有所变化，于是我安装了0.0.5版本的插件，就成功加载图片了</p>
<h4 id="13、修改文章内链接文本样式"><a href="#13、修改文章内链接文本样式" class="headerlink" title="13、修改文章内链接文本样式"></a>13、修改文章内链接文本样式</h4><p>打开文件 <code>themes/next/source/css/_common/components/post/post.styl</code>，在末尾添加</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">p</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#0593d3</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: none;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#0593d3</span>;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#fc6423</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: <span class="selector-tag">none</span>;</span><br><span class="line">    <span class="selector-tag">border-bottom</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#fc6423</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中选择 .post-body 是为了不影响标题，选择 p 是为了不影响首页“阅读全文”的显示样式,颜色可以自己定义。</p>
<h4 id="14、添加字数统计和阅读时长"><a href="#14、添加字数统计和阅读时长" class="headerlink" title="14、添加字数统计和阅读时长"></a>14、添加字数统计和阅读时长</h4><p>首先安装一个插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-symbols-count-time --save</span><br></pre></td></tr></table></figure>

<p>接着博客根目录下的配置文件里添加以下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 文章字数统计</span><br><span class="line">symbols_count_time:</span><br><span class="line">  symbols: true</span><br><span class="line">  time: true</span><br><span class="line">  total_symbols: true</span><br><span class="line">  total_time: true</span><br></pre></td></tr></table></figure>

<p>最后到 next 主题的配置文件下开启 symbols_count_time 字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Post wordcount display settings</span><br><span class="line"># Dependencies: https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-symbols-count-time</span><br><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br></pre></td></tr></table></figure>

<h4 id="15、添加站点访问计数"><a href="#15、添加站点访问计数" class="headerlink" title="15、添加站点访问计数"></a>15、添加站点访问计数</h4><p>站点访问计数有名的就是<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fbusuanzi.ibruce.info" target="_blank" rel="noopener">不蒜子</a>，使用起来非常方便<br>1、安装脚本<br>打开 <strong>themes/next/layout/_partial/footer.swig</strong>，将下面这段代码添加到里面</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">src</span>=<span class="string">"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_pv"</span> <span class="attr">style</span>=<span class="string">'display:none'</span>&gt;</span></span><br><span class="line">    本站总访问量 <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_pv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> 次</span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"post-meta-divider"</span>&gt;</span>|<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_container_site_uv"</span> <span class="attr">style</span>=<span class="string">'display:none'</span>&gt;</span></span><br><span class="line">    有<span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">"busuanzi_value_site_uv"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span>人看过我的博客啦</span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>添加的位置如下图，可自行根据个人喜好更换位置</p>
<img src="/2020/02/04/Hexo+Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/添加站点访问统计.png" style="zoom: 150%;">

<p>2、以上只是显示站点的访问次数，如果想显示每篇文章的访问次数，打开 <strong>themes/next/layout/_macro/post.swig</strong>，在第一行增加<code>is_pv</code>字段</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">macro</span> render(post, is_index, is_pv, post_extra_class) %&#125;</span><br></pre></td></tr></table></figure>

<p>然后将这段代码插入到里面</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> is_pv %&#125;</span><br><span class="line">  &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-meta-divider"</span>&gt;|&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;span id="busuanzi_value_page_pv"&gt;&lt;/</span>span&gt;次阅读</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>插入的位置</p>
<img src="/2020/02/04/Hexo+Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/添加每篇文章的访问次数统计.png" style="zoom:150%;">

<p>然后再打开 <strong>themes/next/layout/post.swig</strong>，这个文件是文章的模板，给render方法传入参数（对应刚才添加的<code>is_pv</code>字段）</p>
<img src="/2020/02/04/Hexo+Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/添加每篇文章的访问次数统计1.png" alt="img" style="zoom:150%;">


<p> 最后再打开 <strong>themes/next/layout/index.swig</strong>，这个文件是首页的模板，给render方法传入参数（对应刚才添加的is_pv字段）</p>
<img src="/2020/02/04/Hexo+Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/添加每篇文章的访问次数统计2.png" alt="img" style="zoom:150%;">

<p> OK！设置完毕。</p>
<h2 id="4-写作"><a href="#4-写作" class="headerlink" title="4. 写作"></a>4. 写作</h2><p>以上所有的工作都完成了，并设置了一套你自己喜欢的主题样式，接下来就可以写博客了。</p>
<h4 id="1、新建一篇文章"><a href="#1、新建一篇文章" class="headerlink" title="1、新建一篇文章"></a>1、新建一篇文章</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new layout title</span><br></pre></td></tr></table></figure>

<p>layout：模板，如果不写将使用默认模板，一般不写，直接<code>$ hexo new title</code><br>title：文章标题，如果标题包含空格的话，请使用引号括起来。<br>新建的文章将会存在<code>username/source/_posts</code>中，<code>_posts</code>就是默认模板，文章文件名称将会是<code>title.md</code>，接下来就可以打开该文件进行编辑写你的文章了。</p>
<h4 id="2、生成静态文件"><a href="#2、生成静态文件" class="headerlink" title="2、生成静态文件"></a>2、生成静态文件</h4><p>写完文章之后执行，来生成静态网页文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g 			&#x2F;&#x2F;hexo generate的缩写</span><br></pre></td></tr></table></figure>

<h4 id="3、启动本地服务器"><a href="#3、启动本地服务器" class="headerlink" title="3、启动本地服务器"></a>3、启动本地服务器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo s			&#x2F;&#x2F;hexo server的缩写</span><br></pre></td></tr></table></figure>

<h4 id="4、部署网站"><a href="#4、部署网站" class="headerlink" title="4、部署网站"></a>4、部署网站</h4><p>安装部署工具</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>安装完毕后打开username下的<code>_config.yml</code>文件，翻到最底部找到deploy节点编辑如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;YoungerLi&#x2F;youngerli.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<p>其中<code>https://github.com/YoungerLi/youngerli.github.io.git</code>就是你GitHub中创建的仓库地址，在这复制即可</p>
<img src="/2020/02/04/Hexo+Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/仓库路径.png" alt="img" style="zoom:150%;">

<p>最后，部署网站</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d        &#x2F;&#x2F;hexo deploy的缩写</span><br></pre></td></tr></table></figure>

<p>第一次执行这一步的时候会让你输入你的GitHub的用户名及密码，输入正确无误后执行完毕，任何人就可以访问 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fyoungerli.github.io" target="_blank" rel="noopener">https://youngerli.github.io</a> 进入你的博客了。</p>
<blockquote>
<p><strong><em>以后每次写完文章之后依次执行以下命令就可以发布更新了</em></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;$ hexo clean      &#x2F;&#x2F; 清除缓存</span><br><span class="line">&gt;$ hexo g          &#x2F;&#x2F; 生成静态网页文件</span><br><span class="line">&gt;$ hexo d          &#x2F;&#x2F; 将本地博客发布到github</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="5、FAQ"><a href="#5、FAQ" class="headerlink" title="5、FAQ"></a>5、FAQ</h2><h4 id="1、hexo-d报错"><a href="#1、hexo-d报错" class="headerlink" title="1、hexo d报错"></a>1、hexo d报错</h4><p><img src="/2020/02/04/Hexo+Next%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/hexo%E9%83%A8%E7%BD%B2%E9%94%99%E8%AF%AF.png" alt></p>
<p>错误原因：hexo版本过低或者nodejs版本过高，降低nodejs版本到12.14.0，安装node多版本控制器n，切换到低版本即可。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo n 12.14.0 # 安装其他版本node</span><br><span class="line">sudo n # 切换到该版本</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式缓存-1-Redis</title>
    <url>/2022/07/05/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-1-Redis/</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Redis6-2-1单实例安装"><a href="#Redis6-2-1单实例安装" class="headerlink" title="Redis6.2.1单实例安装"></a>Redis6.2.1单实例安装</h2><p><strong>1、下载</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/</span><br><span class="line">wget https://download.redis.io/releases/redis-6.2.1.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>2、解压</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-6.2.1.tar.gz</span><br></pre></td></tr></table></figure>

<p><strong>3、安装gcc依赖</strong></p>
<p>Redis是C语言编写的，编译需要GCC。Redis6.x.x版本支持了多线程，需要gcc的版本大于4.9，但是CentOS7的默认版本是4.8.5。</p>
<p>查看gcc的版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

<p>升级gcc版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install centos-release-scl</span><br><span class="line"></span><br><span class="line">yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span><br><span class="line"></span><br><span class="line">scl enable devtoolset-9 bash</span><br><span class="line"></span><br><span class="line">echo "source /opt/rh/devtoolset-9/enable" &gt;&gt;/etc/profile</span><br></pre></td></tr></table></figure>

<p>确认gcc的版本（在同一个窗口中！）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>

<p><strong>4、编译安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd redis-6.2.1/bin</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>安装成功的结果是bin目录下面出现服务端和客户端的脚本<br>redis-server<br>redis-cli<br>redis-sentinel</p>
<p><strong>5、修改配置文件</strong></p>
<p>默认的配置文件是/usr/redis-6.2.1/redis.conf</p>
<p>修改后台启动，不然窗口一关服务就挂了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>

<p>下面一行必须改成 bind 0.0.0.0 或注释，否则只能在本机访问</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure>

<p>如果需要密码访问，取消requirepass的注释，在外网（比如阿里云）这个必须要配置！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">requirepass yourpassword</span><br></pre></td></tr></table></figure>

<p><strong>6、使用指定配置文件启动Redis</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/redis-6.2.1/bin/redis-server /usr/redis-6.2.1/redis.conf</span><br></pre></td></tr></table></figure>

<p>查看端口是否启动成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">netstat -an|grep 6379</span><br></pre></td></tr></table></figure>

<p><strong>7、进入客户端</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/redis-6.2.1/bin/redis-cli -h 192.168.100.201 -p 6379</span><br></pre></td></tr></table></figure>

<p><strong>8、停止redis（在客户端中）</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> shutdown</span></span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -aux | grep redis</span><br><span class="line">kill -9 xxxx</span><br></pre></td></tr></table></figure>

<p><strong>9、配置别名的步骤</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加两行</span></span><br><span class="line">alias redis='/usr/redis-6.2.1/bin/redis-server /usr/redis-6.2.1/redis.conf'</span><br><span class="line">alias rcli='/usr/redis-6.2.1/bin/redis-cli'</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译生效</span></span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>这样就可以用<code>redis</code>启动服务，<code>rcli</code>进入客户端了</p>
<h2 id="Redis6-2-1一主两从Sentinel监控配置"><a href="#Redis6-2-1一主两从Sentinel监控配置" class="headerlink" title="Redis6.2.1一主两从Sentinel监控配置"></a>Redis6.2.1一主两从Sentinel监控配置</h2><p>安装一个Redis服务之后，可以克隆出来3台机器，避免重复安装。开启哨兵模式，至少需要3个Sentinel实例（奇数个，否则无法选举Leader）。本例通过3个Sentinel实例监控3个Redis服务（1主2从）。如果在同一台机器上安装，复制可配置不同的端口号。<strong>防火墙记得关闭！！!</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">IP地址	          节点角色&amp;端口</span><br><span class="line">192.168.100.201	Master：6379 / Sentinel : 26379</span><br><span class="line">192.168.100.201	Slave ：6380 / Sentinel : 26380</span><br><span class="line">192.168.100.201	Slave ：6381 / Sentinel : 26381</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/05/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-1-Redis/Redis%E4%B8%80%E4%B8%BB%E4%B8%A4%E4%BB%8ESentinel%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="网络结构图"></p>
<p>在6380和6381的redis.conf配置中找到被注释的这一行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> replicaof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line">replicaof 192.168.100.201 6379</span><br></pre></td></tr></table></figure>

<p>在6379、6380、6381目录下创建sentinel配置文件（单例安装后根目录下默认有sentinel.conf，可以先备份默认的配置）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/redis-6.2.1</span><br><span class="line">mkdir logs</span><br><span class="line">mkdir rdbs</span><br><span class="line">mkdir sentinel-tmp</span><br><span class="line">cp sentinel.conf sentinel.conf.bak</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">sentinel.conf</span></span><br><span class="line">vim sentinel.conf</span><br></pre></td></tr></table></figure>

<p>sentinel.conf配置文件内容，三台机器相同。如果在一台机器安装，则需修改端口号。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">daemonize yes</span><br><span class="line">port 26379</span><br><span class="line">protected-mode no</span><br><span class="line">dir &quot;&#x2F;usr&#x2F;redis-6.2.1&#x2F;sentinel-tmp&quot;</span><br><span class="line">sentinel monitor redis-master 192.168.100.201 6379 2</span><br><span class="line">sentinel down-after-milliseconds redis-master 30000</span><br><span class="line">sentinel failover-timeout redis-master 180000</span><br><span class="line">sentinel parallel-syncs redis-master 1</span><br><span class="line"></span><br><span class="line">daemonize yes</span><br><span class="line">port 26380</span><br><span class="line">protected-mode no</span><br><span class="line">dir &quot;&#x2F;usr&#x2F;redis-6.2.1-6380&#x2F;sentinel-tmp&quot;</span><br><span class="line">sentinel monitor redis-master 192.168.100.201 6379 2</span><br><span class="line">sentinel down-after-milliseconds redis-master 30000</span><br><span class="line">sentinel failover-timeout redis-master 180000</span><br><span class="line">sentinel parallel-syncs redis-master 1</span><br><span class="line"></span><br><span class="line">daemonize yes</span><br><span class="line">port 26381</span><br><span class="line">protected-mode no</span><br><span class="line">dir &quot;&#x2F;usr&#x2F;redis-6.2.1-6381&#x2F;sentinel-tmp&quot;</span><br><span class="line">sentinel monitor redis-master 192.168.100.201 6379 2</span><br><span class="line">sentinel down-after-milliseconds redis-master 30000</span><br><span class="line">sentinel failover-timeout redis-master 180000</span><br><span class="line">sentinel parallel-syncs redis-master 1</span><br></pre></td></tr></table></figure>

<p>配置解读：</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>protected-mode</td>
<td>是否允许外部网络访问，yes不允许</td>
</tr>
<tr>
<td>dir</td>
<td>sentinel的工作目录</td>
</tr>
<tr>
<td>sentinel monitor</td>
<td>sentinel监控的redis主节点</td>
</tr>
<tr>
<td>down-after-milliseconds（毫秒）</td>
<td>master宕机多久，才会被Sentinel主观认为下线</td>
</tr>
<tr>
<td>sentinel failover-timeout（毫秒）</td>
<td>1.同一个sentinel对同一个master两次failover之间的间隔时间。2. 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。3.当想要取消一个正在进行的failover所需要的时间。 4.当进行failover时，配置所有slaves指向新的master所需的最大时间。</td>
</tr>
<tr>
<td>parallel-syncs</td>
<td>这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。可以通过将这个值设为 1 来保证每次只有一个slave 处于不能处理命令请求的状态。</td>
</tr>
</tbody></table>
<p>在3台机器上分别启动Redis和Sentinel</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/redis-6.2.1/bin</span><br><span class="line">./redis-server ./redis.conf</span><br><span class="line">./redis-sentinel ./sentinel.conf</span><br><span class="line"></span><br><span class="line">cd /usr/redis-6.2.1-6380/bin</span><br><span class="line">./redis-server ./redis.conf</span><br><span class="line">./redis-sentinel ./sentinel.conf</span><br><span class="line"></span><br><span class="line">cd /usr/redis-6.2.1-6381/bin</span><br><span class="line">./redis-server ./redis.conf</span><br><span class="line">./redis-sentinel ./sentinel.conf</span><br></pre></td></tr></table></figure>

<p>哨兵节点的另一种启动方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./redis-server ./sentinel.conf --sentinel</span><br></pre></td></tr></table></figure>

<p>在3台机器上查看集群状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /usr/redis-6.2.1/bin/redis-cli</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> info replication</span></span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/05/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-1-Redis/%E4%B8%80%E4%B8%BB%E4%B8%A4%E4%BB%8E%E9%9B%86%E7%BE%A4%E7%8A%B6%E6%80%81.png" alt="集群状态"></p>
<p>模拟master宕机，在6379上执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> shutdown</span></span><br></pre></td></tr></table></figure>

<p>注意看sentinel.conf里面的redis-master被修改了，变成了当前master的IP端口。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> /usr/redis-6.2.1-6380/bin/redis-cli -h 192.168.100.201 -p 6380</span></span><br><span class="line"><span class="meta">redis&gt;</span><span class="bash"> info replication</span></span><br></pre></td></tr></table></figure>

<p>这个时候会有一个slave节点被Sentinel设置为master。再次启动master，它不一定会被选举为master。</p>
<h2 id="单机安装Redis-Cluster-3主3从伪集群"><a href="#单机安装Redis-Cluster-3主3从伪集群" class="headerlink" title="单机安装Redis Cluster(3主3从伪集群)"></a>单机安装Redis Cluster(3主3从伪集群)</h2><p>为了节省机器，我们直接把6个Redis实例安装在同一台机器上（3主3从），只是使用不同的端口号。可以跟单机的redis安装在同一台机器上，因为数据目录不同，没有影响。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/</span><br><span class="line">mkdir redis-cluster</span><br><span class="line">cd redis-cluster</span><br><span class="line">mkdir 7291 7292 7293 7294 7295 7296</span><br></pre></td></tr></table></figure>

<p>复制redis配置文件到7291目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp /usr/redis-6.2.1/redis.conf /usr/redis-cluster/7291</span><br></pre></td></tr></table></figure>

<p>修改7291的redis.conf配置文件，内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/redis-cluster/7291</span><br><span class="line">vim redis.conf</span><br></pre></td></tr></table></figure>

<p>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">port 7291</span><br><span class="line">daemonize yes</span><br><span class="line">protected-mode no</span><br><span class="line">dir &#x2F;usr&#x2F;redis-cluster&#x2F;7291&#x2F;</span><br><span class="line">cluster-enabled yes</span><br><span class="line">cluster-config-file nodes-7291.conf</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line">appendonly yes</span><br><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis_7291.pid</span><br></pre></td></tr></table></figure>

<p><strong>注意，外网集群要添加这个配置：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 实际给各节点网卡分配的IP（公网IP）</span></span><br><span class="line">cluster-announce-ip 47.xx.xx.xx</span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点映射端口</span></span><br><span class="line">cluster-announce-port $&#123;PORT&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 节点总线端口</span></span><br><span class="line">cluster-announce-bus-port 1$&#123;PORT&#125;</span><br></pre></td></tr></table></figure>

<p>把7291下的redis.conf复制到其他5个目录。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/redis-cluster/7291</span><br><span class="line">cp redis.conf ../7292</span><br><span class="line">cp redis.conf ../7293</span><br><span class="line">cp redis.conf ../7294</span><br><span class="line">cp redis.conf ../7295</span><br><span class="line">cp redis.conf ../7296</span><br></pre></td></tr></table></figure>

<p>批量替换内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/redis-cluster</span><br><span class="line">sed -i 's/7291/7292/g' 7292/redis.conf</span><br><span class="line">sed -i 's/7291/7293/g' 7293/redis.conf</span><br><span class="line">sed -i 's/7291/7294/g' 7294/redis.conf</span><br><span class="line">sed -i 's/7291/7295/g' 7295/redis.conf</span><br><span class="line">sed -i 's/7291/7296/g' 7296/redis.conf</span><br></pre></td></tr></table></figure>

<p>启动6个Redis节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/redis-6.2.1/</span><br><span class="line">./bin/redis-server /usr/redis-cluster/7291/redis.conf</span><br><span class="line">./bin/redis-server /usr/redis-cluster/7292/redis.conf</span><br><span class="line">./bin/redis-server /usr/redis-cluster/7293/redis.conf</span><br><span class="line">./bin/redis-server /usr/redis-cluster/7294/redis.conf</span><br><span class="line">./bin/redis-server /usr/redis-cluster/7295/redis.conf</span><br><span class="line">./bin/redis-server /usr/redis-cluster/7296/redis.conf</span><br></pre></td></tr></table></figure>

<p>是否启动了6个进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ps -ef|grep redis</span><br></pre></td></tr></table></figure>

<p><img src="/2022/07/05/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-1-Redis/image-20220713162726130.png" alt></p>
<p>创建集群，注意用绝对IP，不要用127.0.0.1</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/redis-6.2.1/bin/</span><br><span class="line">redis-cli --cluster create 192.168.100.201:7291 192.168.100.201:7292 192.168.100.201:7293 192.168.100.201:7294 192.168.100.201:7295 192.168.100.201:7296 --cluster-replicas 1</span><br></pre></td></tr></table></figure>

<p>Redis会给出一个预计的方案，对6个节点分配3主3从，如果认为没有问题，输入yes确认</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Performing hash slots allocation on 6 nodes...</span><br><span class="line">Master[0] -&gt; Slots 0 - 5460</span><br><span class="line">Master[1] -&gt; Slots 5461 - 10922</span><br><span class="line">Master[2] -&gt; Slots 10923 - 16383</span><br><span class="line">Adding replica 192.168.100.201:7295 to 192.168.100.201:7291</span><br><span class="line">Adding replica 192.168.100.201:7296 to 192.168.100.201:7292</span><br><span class="line">Adding replica 192.168.100.201:7294 to 192.168.100.201:7293</span><br><span class="line">&gt;&gt;&gt; Trying to optimize slaves allocation for anti-affinity</span><br><span class="line">[WARNING] Some slaves are in the same host as their master</span><br><span class="line">M: c1d268f0d1ba8b7d9f7f7d955a0b910ca81e7673 192.168.100.201:7291</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">M: 9d5997517cf19df7c5ec79f5628cfb3d8a178556 192.168.100.201:7292</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">M: 697957756b27cca6a6c20b7de4c4a06393678a1e 192.168.100.201:7293</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">S: e324aa8e8b37d324271e8813f858fde30dc83b3f 192.168.100.201:7294</span><br><span class="line">   replicates 697957756b27cca6a6c20b7de4c4a06393678a1e</span><br><span class="line">S: a170ec411acaeea17fec789a33a6716ea5885ed2 192.168.100.201:7295</span><br><span class="line">   replicates c1d268f0d1ba8b7d9f7f7d955a0b910ca81e7673</span><br><span class="line">S: 2bffcd1bbda049188a5bad9ba44d28b95c6be1b2 192.168.100.201:7296</span><br><span class="line">   replicates 9d5997517cf19df7c5ec79f5628cfb3d8a178556</span><br><span class="line">Can I set the above configuration? (type &#39;yes&#39; to accept): yes</span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span><br><span class="line">Waiting for the cluster to join</span><br><span class="line">.</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.100.201:7291)</span><br><span class="line">M: c1d268f0d1ba8b7d9f7f7d955a0b910ca81e7673 192.168.100.201:7291</span><br><span class="line">   slots:[0-5460] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: e324aa8e8b37d324271e8813f858fde30dc83b3f 192.168.100.201:7294</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 697957756b27cca6a6c20b7de4c4a06393678a1e</span><br><span class="line">S: a170ec411acaeea17fec789a33a6716ea5885ed2 192.168.100.201:7295</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates c1d268f0d1ba8b7d9f7f7d955a0b910ca81e7673</span><br><span class="line">M: 697957756b27cca6a6c20b7de4c4a06393678a1e 192.168.100.201:7293</span><br><span class="line">   slots:[10923-16383] (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 9d5997517cf19df7c5ec79f5628cfb3d8a178556 192.168.100.201:7292</span><br><span class="line">   slots:[5461-10922] (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 2bffcd1bbda049188a5bad9ba44d28b95c6be1b2 192.168.100.201:7296</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 9d5997517cf19df7c5ec79f5628cfb3d8a178556</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check for open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<p>注意看slot的分布：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7291  [0-5460] (5461个槽) </span><br><span class="line">7292  [5461-10922] (5462个槽) </span><br><span class="line">7293  [10923-16383] (5461个槽)</span><br></pre></td></tr></table></figure>

<p>重置集群的方式是在每个节点上个执行<code>cluster reset</code>，然后重新创建集群。</p>
<p>批量写入值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/redis-cluster/</span><br><span class="line">vim setkey.sh</span><br></pre></td></tr></table></figure>

<p>脚本内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for ((i=0;i&lt;20000;i++))</span><br><span class="line">do</span><br><span class="line">echo -en "helloworld" | redis-cli -h 192.168.100.201 -p 7291 -c -x set name$i &gt;&gt;redis.log</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod +x setkey.sh</span><br><span class="line">./setkey.sh</span><br></pre></td></tr></table></figure>

<p>连接到客户端</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 7291</span><br><span class="line">redis-cli -p 7292</span><br><span class="line">redis-cli -p 7293</span><br></pre></td></tr></table></figure>

<p>每个节点分布的数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:7291&gt; dbsize</span><br><span class="line">(integer) 6652</span><br><span class="line">127.0.0.1:7292&gt; dbsize</span><br><span class="line">(integer) 6683</span><br><span class="line">127.0.0.1:7293&gt; dbsize</span><br><span class="line">(integer) 6665</span><br></pre></td></tr></table></figure>

<p>新增节点如何重新分片：一个新节点add-node加入集群后，是没有slots的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster reshard 目标节点（IP端口）</span><br></pre></td></tr></table></figure>

<p>这时会要求你输入分配的槽位，生成reshard计划，确定就会迁移数据</p>
<h3 id="cluster管理命令"><a href="#cluster管理命令" class="headerlink" title="cluster管理命令"></a>cluster管理命令</h3><p>其他命令，比如添加节点、删除节点，重新分布数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis-cli --cluster help</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Cluster Manager Commands:</span><br><span class="line">  create         host1:port1 ... hostN:portN</span><br><span class="line">                 --cluster-replicas &lt;arg&gt;</span><br><span class="line">  check          host:port</span><br><span class="line">                 --cluster-search-multiple-owners</span><br><span class="line">  info           host:port</span><br><span class="line">  fix            host:port</span><br><span class="line">                 --cluster-search-multiple-owners</span><br><span class="line">                 --cluster-fix-with-unreachable-masters</span><br><span class="line">  reshard        host:port</span><br><span class="line">                 --cluster-from &lt;arg&gt;</span><br><span class="line">                 --cluster-to &lt;arg&gt;</span><br><span class="line">                 --cluster-slots &lt;arg&gt;</span><br><span class="line">                 --cluster-yes</span><br><span class="line">                 --cluster-timeout &lt;arg&gt;</span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  rebalance      host:port</span><br><span class="line">                 --cluster-weight &lt;node1&#x3D;w1...nodeN&#x3D;wN&gt;</span><br><span class="line">                 --cluster-use-empty-masters</span><br><span class="line">                 --cluster-timeout &lt;arg&gt;</span><br><span class="line">                 --cluster-simulate</span><br><span class="line">                 --cluster-pipeline &lt;arg&gt;</span><br><span class="line">                 --cluster-threshold &lt;arg&gt;</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  add-node       new_host:new_port existing_host:existing_port</span><br><span class="line">                 --cluster-slave</span><br><span class="line">                 --cluster-master-id &lt;arg&gt;</span><br><span class="line">  del-node       host:port node_id</span><br><span class="line">  call           host:port command arg arg .. arg</span><br><span class="line">                 --cluster-only-masters</span><br><span class="line">                 --cluster-only-replicas</span><br><span class="line">  set-timeout    host:port milliseconds</span><br><span class="line">  import         host:port</span><br><span class="line">                 --cluster-from &lt;arg&gt;</span><br><span class="line">                 --cluster-from-user &lt;arg&gt;</span><br><span class="line">                 --cluster-from-pass &lt;arg&gt;</span><br><span class="line">                 --cluster-from-askpass</span><br><span class="line">                 --cluster-copy</span><br><span class="line">                 --cluster-replace</span><br><span class="line">  backup         host:port backup_directory</span><br><span class="line">  help</span><br><span class="line"></span><br><span class="line">For check, fix, reshard, del-node, set-timeout you can specify the host and port of any working node in the cluster.</span><br><span class="line"></span><br><span class="line">Cluster Manager Options:</span><br><span class="line">  --cluster-yes  Automatic yes to cluster commands prompts</span><br></pre></td></tr></table></figure>

<h3 id="附录：（在redis客户端执行）"><a href="#附录：（在redis客户端执行）" class="headerlink" title="附录：（在redis客户端执行）"></a>附录：（在redis客户端执行）</h3><p><strong>集群命令</strong></p>
<p>cluster info ：打印集群的信息<br>cluster nodes ：列出集群当前已知的所有节点（node），以及这些节点的相关信息。<br>cluster meet ：将 ip 和 port 所指定的节点添加到集群当中，让它成为集群的一份子。<br>cluster forget <node_id> ：从集群中移除 node_id 指定的节点(保证空槽道)。<br>cluster replicate <node_id> ：将当前节点设置为 node_id 指定的节点的从节点。<br>cluster saveconfig ：将节点的配置文件保存到硬盘里面。</node_id></node_id></p>
<p><strong>槽slot命令</strong></p>
<p>cluster addslots [slot …] ：将一个或多个槽（slot）指派（assign）给当前节点。<br>cluster delslots [slot …] ：移除一个或多个槽对当前节点的指派。<br>cluster flushslots ：移除指派给当前节点的所有槽，让当前节点变成一个没有指派任何槽的节点。<br>cluster setslot node <node_id> ：将槽 slot 指派给 node_id 指定的节点，如果槽已经指派给另一个节点，那么先让另一个节点删除该槽&gt;，然后再进行指派。<br>cluster setslot migrating <node_id> ：将本节点的槽 slot 迁移到 node_id 指定的节点中。<br>cluster setslot importing <node_id> ：从 node_id 指定的节点中导入槽 slot 到本节点。<br>cluster setslot stable ：取消对槽 slot 的导入（import）或者迁移（migrate）。</node_id></node_id></node_id></p>
<p><strong>键命令</strong></p>
<p>cluster keyslot ：计算键 key 应该被放置在哪个槽上。<br>cluster countkeysinslot ：返回槽 slot 目前包含的键值对数量。<br>cluster getkeysinslot ：返回 count 个 slot 槽中的键</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Redis的作者笔名叫antirez，2008年的时候他做了一个记录网站访问情况的系统，比如每天有多少个用户，多少个页面浏览，访客的IP、操作系统、浏览器、使用的搜索关键词等等（跟百度统计功能一样）。最开始存储方案用MySQL，但是实在慢的不行，09年的时候antirez就自己谢了一个内存的List，这个就是Redis。</p>
<p><img src="/2022/07/05/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98-1-Redis/image-20220713165823311.png" alt></p>
<p>Redis，全程REmote DIctionary Service，远程字典服务。</p>
<h1 id="关系型数据库与非关系型数据库"><a href="#关系型数据库与非关系型数据库" class="headerlink" title="关系型数据库与非关系型数据库"></a>关系型数据库与非关系型数据库</h1><p><strong>关系型数据库的特点：</strong></p>
<ol>
<li>它以表格的形式，基于行存储数据，是一个二维的模式。</li>
<li>它存储的是结构化的数据，数据存储有固定的模式（schema），数据需要适应表结构。</li>
<li>表与表之间存在关联（Relationship）。</li>
<li>大部分关系型数据库都支持SQL（结构化查询语言）的操作，支持复杂的关联查询。</li>
<li>通过支持事务（ACID酸）来提供严格或者实时的数据一致性。</li>
</ol>
<p><strong>关系型数据库的限制：</strong></p>
<ol>
<li>要实现扩容的话，只能向上（垂直）扩展，比如磁盘限制了数据的存储，就要扩大磁盘容量，通过堆硬件的方式，不支持动态的扩缩容。水平扩容需要复杂的技术来实现，比如分库分表。</li>
<li>表结构修改困难，因此存储的数据格式也受到限制。</li>
<li>关系型数据库通常会把数据持久化到磁盘，在高并发和高数据量的情况下，居于磁盘的读写压力比较大。</li>
</ol>
<p><strong>非关系型数据库（non-relational或Not Only SQL）的特点：</strong></p>
<ol>
<li>存储非结构化的数据，比如文本、图片、音频、视频。</li>
<li>表与表之间没有关联，可扩展性强。</li>
<li>保证数据的最终一致性，遵循BASE（碱）理论。Basically Available（基本可用）；Soft-state（软状态）；Eventually Consistent（最终一致性）。</li>
<li>支持海量数据的存储和高并发的高效读写。</li>
<li>支持分布式，能够对数据进行分片存储，扩缩容简单。</li>
</ol>
<p><strong>非关系型数据库常见类型：</strong></p>
<p>参见：<a href="http://nosql-database.org/" target="_blank" rel="noopener">http://nosql-database.org/</a></p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>1、为什么要把数据放在内存中？</p>
<ul>
<li><p>内存的速度更快，10WQPS</p>
</li>
<li><p>减少计算的时间，减轻数据库压力</p>
</li>
</ul>
<p>2、如果是用内存的数据结构作为缓存，为什么不用HashMap或者Memcached？</p>
<ul>
<li>更丰富的数据类型</li>
<li>支持多种编程语言</li>
<li>功能丰富：持久化机制、内存淘汰策略、事务、发布订阅、pipeline、lua</li>
<li>支持集群、分布式</li>
</ul>
<p>3、Memcached与Redis的主要区别？</p>
<p>Memcached只能存储KV、没有持久化机制、不支持主从复制、是多线程的。</p>
<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>Redis一共又8种数据类型：String、Hash、Set、List、Zset、Hyperloglog、Geo、Streams。最基本也是最常用的数据类型就是String。Redis的字符串被叫做二进制安全的字符串。</p>
<h2 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h2><p><strong>存储类型</strong></p>
<p>可以用来存储INT(整数)、float(单精度浮点数)、String(字符串)</p>
<p><strong>操作命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取指定范围的字符</span></span><br><span class="line">getrange key 0 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取值长度</span></span><br><span class="line">strlen key</span><br><span class="line"><span class="meta">#</span><span class="bash"> 字符串追加内容</span></span><br><span class="line">append key good</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置多个值（批量操作，原子性）</span></span><br><span class="line">mset key1 0 key2 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取多个值</span></span><br><span class="line">mget key1 key2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置值，如果key存在，则不成功</span></span><br><span class="line">setnx key1 0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 基于此可实现分布式锁。用del key释放锁。释放锁操作失败，会导致其他节点永远无法获取到锁，可加上过期时间。另可使用多参数方式</span></span><br><span class="line">set key value [expiration EX seconds|PX milliseconds][NX|XX]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用参数的方式</span></span><br><span class="line">set k1 v1 EX 10 NX</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> （整数）值递增（值不存在会得到1）</span></span><br><span class="line">incr key</span><br><span class="line">incrby key 100</span><br><span class="line"><span class="meta">#</span><span class="bash"> （整数）值递减</span></span><br><span class="line">decr key</span><br><span class="line">decrby key 100</span><br><span class="line"><span class="meta">#</span><span class="bash"> 浮点数增量</span></span><br><span class="line">set mf 2.6</span><br><span class="line">incrbyfloat mf 7.3</span><br></pre></td></tr></table></figure>

<p><strong>存储原理</strong></p>
]]></content>
      <categories>
        <category>分布式缓存</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>分布式缓存</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构-10-Spring-Cloud-Gateway</title>
    <url>/2021/07/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-10-Spring-Cloud-Gateway/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>微服务架构</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构-1-基础概念</title>
    <url>/2021/01/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h2 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h2><p>项目初期，所有的功能模块都放在一个工程中编码、编译、打包并且部署在一个Tomcat容器中的架构模式就是单体架构。</p>
<p>优点：</p>
<ol>
<li>项⽬前期开发节奏快，团队成员少的时候能够快速迭代　　</li>
<li>架构简单：MVC架构，只需要借助IDE开发、调试即可</li>
<li>易于测试：只需要通过单元测试或者浏览器完成</li>
<li>易于部署：打包成单⼀可执⾏的jar或者打成war包放到容器内启动</li>
</ol>
<p>缺点：</p>
<ol>
<li>随着时间推移业务增加，功能不断迭代，项目会不断变得臃肿，业务耦合严重，随着项目团队增大，沟通成本高，项目启动慢</li>
<li>新增业务困难：在已经乱如麻的系统中增加新业务，维护旧功能，⼀脚踩进去全是不可预测 的问题。新⼈来了以后很难接⼿任务，学习成本⾼</li>
<li>核⼼业务与边缘业务混合在⼀块，出现问题互相影响</li>
</ol>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>集群就是单机的多实例，在多个服务器上部署多个服务，每个服务就是一个节点，部署N个节点，处理业务的能力就提升 N倍（大约），这些节点的集合就叫做集群。</p>
<p>优点：操作简单，容易部署；</p>
<p>缺点：每个节点负载相同（耦合度高），每个具体业务的访问量可能差异很大，比如美团外卖美食外卖的访问量一定大于鲜花外卖的访问量，这就造成了资源浪费</p>
<h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>分布式结构就是将一个完整的系统，按照业务功能，拆分成一个个独立的子系统，在分布式结构中，每个子系统就被称为“服务”。这些子系统能够独立运行在web容器中，它们之间通过RPC方式通信。</p>
<p>优点：资源利用率高</p>
<p>缺点：安全性低，如果一台服务器出现问题整个系统就会崩塌</p>
<h2 id="垂直化"><a href="#垂直化" class="headerlink" title="垂直化"></a>垂直化</h2><p>为了避免单体架构上出现的那些问题，大家开始对应用按照业务做垂直划分，把原来的的一个单体架构拆成一堆单体应用，这时候就由原来的单应用变成了多应用部署，这就是垂直架构。</p>
<p>优点：</p>
<ol>
<li><p>系统拆分实现了流量分担，解决了并发问题</p>
</li>
<li><p>可以针对不同模块进⾏优化</p>
</li>
<li><p>⽅便⽔平扩展，负载均衡，容错率提⾼</p>
</li>
<li><p>系统间相互独⽴，互不影响，新的业务迭代时更加⾼效</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>服务之间相互调⽤，如果某个服务的端⼝或者ip地址发⽣改变，调⽤的系统得⼿动改变（也就是硬编码）</p>
</li>
<li><p>搭建集群之后，实现负载均衡⽐较复杂，如：内⽹负载，在迁移机器时会影响调⽤⽅的路 由，导致线上故障</p>
</li>
<li><p>服务之间调⽤⽅式不统⼀，基于 httpclient 、 webservice ，接⼝协议不统⼀</p>
</li>
<li><p>服务监控不到位：除了依靠端⼝、进程的监控，调⽤的成功率、失败率、总耗时等等这些监 控指标是没有的</p>
</li>
</ol>
<h2 id="服务化（SOA）"><a href="#服务化（SOA）" class="headerlink" title="服务化（SOA）"></a>服务化（SOA）</h2><p>SOA (Service-Oriented Architecture)，即⾯向服务的架构。其思想就是根据实际业务，把系统拆分成合适的、独⽴部署的模块，模块之间相互独⽴（通过Webservice/Dubbo等技术进⾏通信）。可以理解为拆分出来的每个系统都是一个个的组件，组件与组件之间都是通过服务进行调用。</p>
<p>优点：</p>
<ol>
<li><p>分布式</p>
</li>
<li><p>松耦合</p>
</li>
<li><p>扩展灵活</p>
</li>
<li><p>可重⽤</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>服务抽取粒度较⼤</p>
</li>
<li><p>服务调⽤⽅和提供⽅耦合度较⾼（接⼝耦合度）</p>
</li>
</ol>
<h2 id="微服务化"><a href="#微服务化" class="headerlink" title="微服务化"></a>微服务化</h2><p>在SOA架构下虽然能解决大部分的问题，但是由于他自身的缺点，依然不那么尽如人意，其实主要还是在SOA架构下拆分粒度不是很细，因此大家又在SOA架构下进行了拓展，将服务粒度拆分得更细这就引出了微服务架构。这种架构模式下它拆分粒度更⼩、服务更独⽴。把应⽤拆分成为⼀个个微⼩的服务，不同的服务可以使⽤不同的开发语⾔和存储，服务之间往往通过Restful等轻量级通信。微服务架构关键在于微⼩、独⽴、轻量级通信。微服务架构强调的⼀个重点是“业务需要彻底的组件化和服务化”。其实这时候就要求服务的拆分达到一个设计原则：单一职责原则。</p>
<p>优点：</p>
<ol>
<li><p>业务聚焦</p>
</li>
<li><p>解耦</p>
</li>
<li><p>降低团队合作成本</p>
</li>
<li><p>复用性高、可维护性搞</p>
</li>
</ol>
<p>缺点：由于服务拆分粒度很细，技术成本高（容错、分布式事务等），对团队挑战大、服务治理成本高</p>
<h2 id="服务端负载均衡和客户端负载均衡的区别"><a href="#服务端负载均衡和客户端负载均衡的区别" class="headerlink" title="服务端负载均衡和客户端负载均衡的区别"></a>服务端负载均衡和客户端负载均衡的区别</h2><ul>
<li><p>服务器端负载均衡：例如Nginx，通过Nginx进行负载均衡，先发送请求，然后通过负载均衡算法，在多个服务器之间选择一个进行访问；即在服务器端再进行负载均衡算法分配。</p>
</li>
<li><p>客户端负载均衡：例如spring cloud中的ribbon，客户端会有一个服务器地址列表，在发送请求前通过负载均衡算法选择一个服务器，然后进行访问，这是客户端负载均衡；即在客户端就进行负载均衡算法分配。</p>
</li>
</ul>
<p>Ribbon是一个基于HTTP和TCP的客户端负载均衡器，当我们将Ribbon和Eureka一起使用时，Ribbon会从Eureka注册中心去获取服务端列表，然后进行轮询访问以到达负载均衡的作用，客户端负载均衡中也需要心跳机制去维护服务端清单的有效性，当然这个过程需要配合服务注册中心一起完成。</p>
<p>从上面的描述我们可以看出，<strong>客户端负载均衡和服务端负载均衡最大的区别在于服务清单所存储的位置。在客户端负载均衡中，所有的客户端节点都有一份自己要访问的服务端清单，这些清单统统都是从Eureka服务注册中心获取的。</strong></p>
<h2 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h2><p>SpringBoot是一个快速开发的框架，能够快速整合第三方框架，他是如何快速整合的呢？其实他是基于原来的Maven依赖关系，Maven的集成，完全采用注解化，简化XML配置，内嵌HTTP服务器（Tomcate，jetty），默认嵌入Tomcate，最终以Java应用程序进行执行。</p>
<ol>
<li><p>SpringBoot是微服务框架</p>
</li>
<li><p>SpringBoot核心：快速整合第三方框架</p>
</li>
<li><p>SpringBoot原理：Maven依赖关系，Maven的继承，完全采用注解化，Spring3.0以后采用注解方式启动SpringMVC</p>
</li>
</ol>
<h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>SpringCloud一套目前完整的微服务解决框架，功能非常强大，注册中心，客户端调用工具，服务治理（负载均衡，断路器，分布式配置中心，网管，消息总线等）。</p>
<h2 id="Spring-Cloud生态"><a href="#Spring-Cloud生态" class="headerlink" title="Spring Cloud生态"></a>Spring Cloud生态</h2><p><img src="/2021/01/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%9A%84%E7%8E%B0%E7%8A%B6%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5.jpg" alt></p>
<h2 id="Spring-Cloud版本命名"><a href="#Spring-Cloud版本命名" class="headerlink" title="Spring Cloud版本命名"></a>Spring Cloud版本命名</h2><p>Spring Cloud 采用了英国伦敦地铁站的名称来命名，并由地铁站名称字母A-Z依次类推的形式来发布迭代版本。Spring Cloud 的第一个版本 “Angel” ，接着 “Brixton” 就是第二个版本。当一个项目到达发布临界点或者解决了一个严重的BUG后就会发布一个 “service Release” 版本， 简称 SR（X）版本，x 代表一个递增数字。</p>
<p><strong>SR：service Release，服务版本</strong></p>
<p><strong>RC:Release Candidate，候选发布版本</strong> </p>
<p><strong>M：MileStone，里程碑版本</strong></p>
<p><strong>GA : General Availability，正式发布的版本，官方推荐使用此版本。在国外都是用GA来说明release版本的</strong>。</p>
<h2 id="Spring-Boot和Spring-Cloud版本关系"><a href="#Spring-Boot和Spring-Cloud版本关系" class="headerlink" title="Spring Boot和Spring Cloud版本关系"></a>Spring Boot和Spring Cloud版本关系</h2><ol>
<li>官网：<a href="https://spring.io/projects/spring-cloud" target="_blank" rel="noopener">https://spring.io/projects/spring-cloud</a></li>
</ol>
<p><img src="/2021/01/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/SpringCloud%E4%B8%8ESpringBoot%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB.png" alt></p>
<ol start="2">
<li>接口返回：<a href="https://start.spring.io/actuator/info" target="_blank" rel="noopener">https://start.spring.io/actuator/info</a></li>
</ol>
]]></content>
      <categories>
        <category>微服务架构</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构-2-SpringBoot</title>
    <url>/2021/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-2-SpringBoot/</url>
    <content><![CDATA[<h1 id="Spring-Boot的前世今生"><a href="#Spring-Boot的前世今生" class="headerlink" title="Spring Boot的前世今生"></a>Spring Boot的前世今生</h1><h2 id="Spring-Framework"><a href="#Spring-Framework" class="headerlink" title="Spring Framework"></a>Spring Framework</h2><ol>
<li><p><strong>IOC（Inversion of Control）：</strong>控制反转，简单点说，就是创建对象的控制权，被反转到了Spring框架上。通常，我们实例化一个对象时，都是使用类的构造方法来new一个对象，这个过程是由我们自己来控制的，而控制反转就把new对象的工交给了Spring容器。</p>
<p><strong>IoC的主要实现方式有两种：</strong>依赖查找、依赖注入。依赖注入是一种更可取的方式。</p>
<p><strong>依赖查找和依赖注入的区别：</strong></p>
<p>依赖查找，主要是容器为组件提供一个回调接口和上下文环境。这样一来，组件就必须自己使用容器提供的API来查找资源和协作对象，控制反转仅体现在那些回调方法上，容器调用这些回调方法，从而应用代码获取到资源。</p>
<p>依赖注入，组件不做定位查询，只提供标准的Java方法让容器去决定依赖关系。容器全权负责组件的装配，把符合依赖关系的对象通过Java Bean属性或构造方法传递给需要的对象。</p>
<p><strong>IoC容器：</strong>具有依赖注入功能的容器，可以创建对象的容器。IoC容器负责实例化、定位、配置应用程序中的对象并建立这些对象之间的依赖。</p>
<p><strong>依赖注入：</strong>DI，英文全称，Dependency Injection，意为依赖注入。由IoC容器动态地将某个对象所需要的外部资源（包括对象、资源、常量数据）注入到组件(Controller, Service等）之中。简单点说，就是IoC容器会把当前对象所需要的外部资源动态的注入给我们。Spring依赖注入的方式主要有四个，基于注解注入方式、set注入方式、构造器注入方式、静态工厂注入方式。推荐使用基于注解注入方式，配置较少，比较方便。</p>
<p>除此之外，对于一些复杂的装载Bean的时机，比如我们需要根据配置装载不同的Bean，以完成不同的操作，可以使用getBean(“beanID”)的方式来加载Bean。</p>
<p>通过BeanID加载Bean方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtils</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationContext applicationContext;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (BeanUtils.applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            BeanUtils.applicationContext = applicationContext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getBean</span><span class="params">(String id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> applicationContext.containsBean(id) ? applicationContext.getBean(id) : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BeansException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"not found bean id: "</span> + id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> IService <span class="title">loadService</span><span class="params">(String id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IService iService = (IService) BeanUtils.getBean(id);</span><br><span class="line">        <span class="keyword">if</span> (iService != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> iService;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"加载Bean错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>AOP(Aspect-Oriented Programming)：</strong>面向切面编程（AOP）就是纵向的编程。比如业务A和业务B现在需要一个相同的操作，传统方法我们可能需要在A、B中都加入相关操作代码，而应用AOP就可以只写一遍代码，A、B共用这段代码。并且，当A、B需要增加新的操作时，可以在不改动原代码的情况下，灵活添加新的业务逻辑实现。</p>
<p>在实际开发中，比如商品查询、促销查询等业务，都需要记录日志、异常处理等操作，AOP把所有共用代码都剥离出来，单独放置到某个类中进行集中管理，在具体运行时，由容器进行动态织入这些公共代码。</p>
<p>AOP主要一般应用于签名验签、参数校验、日志记录、事务控制、权限控制、性能统计、异常处理等。</p>
<p><strong>切面（Aspect）：</strong>共有功能的实现。如日志切面、权限切面、验签切面等。在实际开发中通常是一个存放共有功能实现的标准Java类。当Java类使用了@Aspect注解修饰时，就能被AOP容器识别为切面。</p>
<p><strong>通知（Advice）：</strong>切面的具体实现。就是要给目标对象织入的事情。以目标方法为参照点，根据放置的地方不同，可分为前置通知（Before）、后置通知（AfterReturning）、异常通知（AfterThrowing）、最终通知（After）与环绕通知（Around）5种。在实际开发中通常是切面类中的一个方法，具体属于哪类通知，通过方法上的注解区分。</p>
<p><strong>连接点（JoinPoint）：</strong>程序在运行过程中能够插入切面的地点。例如，方法调用、异常抛出等。Spring只支持方法级的连接点。一个类的所有方法前、后、抛出异常时等都是连接点。</p>
<p><strong>切入点（Pointcut）：</strong>用于定义通知应该切入到哪些连接点上。不同的通知通常需要切入到不同的连接点上，这种精准的匹配是由切入点的正则表达式来定义的。</p>
<p>比如，在上面所说的连接点的基础上，来定义切入点。我们有一个类，类里有10个方法，那就产生了几十个连接点。但是我们并不想在所有方法上都织入通知，我们只想让其中的几个方法，在调用之前检验下入参是否合法，那么就用切点来定义这几个方法，让切点来筛选连接点，选中我们想要的方法。切入点就是来定义哪些类里面的哪些方法会得到通知。</p>
<p><strong>目标对象（Target）：</strong>那些即将切入切面的对象，也就是那些被通知的对象。这些对象专注业务本身的逻辑，所有的共有功能等待AOP容器的切入。</p>
<p><strong>代理对象（Proxy）：</strong>将通知应用到目标对象之后被动态创建的对象。可以简单地理解为，代理对象的功能等于目标对象本身业务逻辑加上共有功能。代理对象对于使用者而言是透明的，是程序运行过程中的产物。目标对象被织入共有功能后产生的对象。</p>
<p><strong>织入（Weaving）：</strong>将切面应用到目标对象从而创建一个新的代理对象的过程。这个过程可以发生在编译时、类加载时、运行时。Spring是在运行时完成织入，运行时织入通过Java语言的反射机制与动态代理机制来动态实现。</p>
</li>
</ol>
<h2 id="用Spring-MVC创建一个web项目"><a href="#用Spring-MVC创建一个web项目" class="headerlink" title="用Spring MVC创建一个web项目"></a>用Spring MVC创建一个web项目</h2><ul>
<li><p>创建一个项目结构（maven/gradle）</p>
<p><img src="/2021/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-2-SpringBoot/idea%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8Emaven%E7%9A%84web%E9%A1%B9%E7%9B%AE.png" alt="image-20210325180818597"></p>
</li>
<li><p>spring的依赖，spring mvc，servlet api依赖</p>
<p><img src="/2021/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-2-SpringBoot/Springmvc%E4%BE%9D%E8%B5%96.png" alt></p>
</li>
<li><p>web.xml，配置DispatcherServlet</p>
<p><img src="/2021/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-2-SpringBoot/%E9%85%8D%E7%BD%AEDispatcherServlet.png" alt></p>
</li>
<li><p>启动一个spring mvc的配置，Dispatcher-servlet.xml</p>
<p><img src="/2021/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-2-SpringBoot/Dispatcher-servlet.xml.png" alt></p>
</li>
<li><p>创建一个Controller发布一个http请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发布到jsp/servlet容器</p>
<p><img src="/2021/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-2-SpringBoot/Tomcat.png" alt></p>
</li>
</ul>
<h2 id="什么是Spring-Boot"><a href="#什么是Spring-Boot" class="headerlink" title="什么是Spring Boot"></a>什么是Spring Boot</h2><blockquote>
<p>约定优于配置理念下的一个产物</p>
</blockquote>
<h2 id="创建一个Spring-Boot的web项目"><a href="#创建一个Spring-Boot的web项目" class="headerlink" title="创建一个Spring Boot的web项目"></a>创建一个Spring Boot的web项目</h2><ul>
<li><p>idea创建一个Spring Boot的web项目</p>
<p><img src="/2021/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-2-SpringBoot/idea%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAspringboot-web%E9%A1%B9%E7%9B%AE.png" alt></p>
</li>
<li><p>创建一个Controller发布一个http请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDemo02BootApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootDemo02BootApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//@RequestMapping</span></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello Spring Boot"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>pom.xml添加mybatis依赖</p>
<p><img src="/2021/01/28/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-2-SpringBoot/%E9%9B%86%E6%88%90mybatis%E4%BE%9D%E8%B5%96.png" alt></p>
</li>
<li><p>application.properties配置数据库连接信息和mapper路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/test_springboot?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=CTT</span><br><span class="line"># 配置mapper.xml的路径</span><br><span class="line">mybatis.mapper-locations=classpath:*Mapper.xml</span><br></pre></td></tr></table></figure>
</li>
<li><p>Usermapper.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>UserMapper.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span> <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.study.example.dao.mappers.UserMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.study.example.dao.entity.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">property</span>=<span class="string">"name"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Base_Column_List"</span>&gt;</span></span><br><span class="line">        id,name</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"com.study.example.dao.entity.User"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        insert into t_user(name) values(#&#123;name,jdbcType=VARCHAR&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：mapper写在了java目录里面，而不是在resource目录里，这样会出现一个问题，即使你在properties里面配置了 mybatis.mapper-locations= classpath:*Mapper.xml，也没有用，因为编译的时候这个xml文件并没有被自动拉到target里面，毕竟编译的是.java文件而不是xml，所以这时候应该在pom文件里面加上：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span><span class="comment">&lt;!--所在的目录--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span><span class="comment">&lt;!--包括目录下的.properties,.xml文件都会扫描到--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>UserServiceImpl.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserMapper userMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insert</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.insert(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>pom添加redis依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.properties添加redis配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">xxx</span></span><br><span class="line"><span class="comment"># 端口号默认6379</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="meta">spring.redis.password</span>=<span class="string">xxx</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>RedisController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello/redis"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloRedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisTemplate.opsForValue().get(<span class="string">"desccache_asset:1198213797811195904"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.study.example"</span>)</span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"com.study.example.dao.mappers"</span>)</span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDemo02BootApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootDemo02BootApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Spring-Boot的特性"><a href="#Spring-Boot的特性" class="headerlink" title="Spring Boot的特性"></a>Spring Boot的特性</h1><ul>
<li>EnableAutoConfiguration 自动装配</li>
<li>Starter启动依赖</li>
<li>Actuator监控</li>
<li>Spring Boot CLI（命令行操作的功能，groovy脚本）</li>
</ul>
<h1 id="Spring注解驱动的发展过程"><a href="#Spring注解驱动的发展过程" class="headerlink" title="Spring注解驱动的发展过程"></a>Spring注解驱动的发展过程</h1><h2 id="Spring常用注解"><a href="#Spring常用注解" class="headerlink" title="Spring常用注解"></a>Spring常用注解</h2><ol>
<li><strong>@Controller:</strong>用于标注控制器层组件</li>
<li><strong>@Service:</strong>用于标注业务层组件</li>
<li><strong>@Component:</strong>用于标注这是一个受Spring管理的组件，组件引用名称是类名，第一个字母小写。可以使用@Component(“beanID”)指定组件名称</li>
<li><strong>@Repository:</strong>用于标注数据访问组件，即DAO组件</li>
<li><strong>@Bean:</strong>方法级别的注解，主要用在@Configuration和@Component注解的类里，@Bean注解的方法会产生一个Bean对象，该对象由Spring管理并放在IoC容器中。引用名称是方法名，也可以用@Bean(name=”beanID”)指定组件名</li>
<li><strong>@Scope(“prototype”):</strong>将组件的范围设置为原型的（即多例）。保证每一个请求有一个单独的action来处理，避免action的线程问题。</li>
<li><strong>@Autowired:</strong>默认按类型进行自动装配。在容器查找匹配的Bean，当有且仅有一个匹配的Bean时，Spring将其注入@Autowired标注的变量中。</li>
<li><strong>@Resource:</strong>默认按名称进行自动装配，当找不到与名称匹配的Bean时会按类型装配。</li>
</ol>
<blockquote>
<p>简单点说，就是，能够明确该类是一个控制器类组件的，就用@Controller；能够明确是一个服务类组件的，就用@Service；能够明确该类是一个数据访问组件的，就用@Repository；不知道他是啥或者不好区分他是啥，但是就是想让他动态装配的就用@Component。</p>
<p>@Controller、@Service、@Component、@Repository都是类级别的注解，如果一个方法也想动态装配，就用@Bean。</p>
<p>当我们想按类型进行自动装配时，就用@Autowired；当我们想按名称（beanID）进行自动装配时，就用@Resource；当我们需要根据比如配置信息等来动态装配不同的组件时，可以用getBean(“beanID”)。</p>
<p>@Autowired与@Resource都可以用来装配Bean，都可以写在字段、setter方法上。他们的区别是：</p>
<p>@Autowired默认按类型进行自动装配（该注解属于Spring），默认情况下要求依赖对象必须存在，如果要允许为null，需设置required属性为false，例：@Autowired(required=false)。如果要使用名称进行装配，可以与@Qualifier注解一起使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(<span class="string">"adminService"</span>)</span><br><span class="line"><span class="keyword">private</span> AdminService adminService;</span><br></pre></td></tr></table></figure>

<p>@Resource默认按照名称进行装配（该注解属于J2EE），名称可以通过name属性来指定。如果没有指定name属性，当注解写在字段上时，默认取字段名进行装配；如果注解写在setter方法上，默认取属性名进行装配。当找不到与名称相匹配的Bean时，会按照类型进行装配。但是，name属性一旦指定，就只会按照名称进行装配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Resource</span>(name = <span class="string">"adminService"</span>)</span><br><span class="line"><span class="keyword">private</span> AdminService adminService;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>@Bean与@Component(@Controller、@Service、@Repository)等的区别？</p>
<p>@Component用于自动检测和使用类路径扫描自动配置bean。注释类和bean之间存在隐式的一对一映射（即每个类一个bean）</p>
<p>@Bean用于显示声明单个bean，而不是让Spring像上面那样自动执行它。它将bean的声明与类定义分离，并允许您精确的创建和配置bean。常和@Configuration注解搭配使用</p>
<p>以上两种注解均可使用@Autowired或者@Resource注解注入</p>
<p>为什么有了@Component，还需要@Bean呢？</p>
<p>如果想将第三方的类变成组件，但又没有源代码，也就没办法使用@Component进行自动配置，这种时候使用@Bean就比较合适了。不过同样的也可以通过xml方式来定义。另外@Bean注解的方法返回值是对象，可以在方法中为对象设置属性。例如Spring的Starter自动装配机制，就是通过@Bean注解来定义bean。可以搭配@ConditionalOnMissingBean注解和@ConditionalOnMissingClass注解等条件注解来使用，如果本项目中没有定义该类型的bean则会失效，避免在某个项目中定义或者通过config注解来声明大量重复的bean。</p>
</blockquote>
<h2 id="Spring-1-x"><a href="#Spring-1-x" class="headerlink" title="Spring 1.x"></a>Spring 1.x</h2><p>实现IoC功能</p>
<ul>
<li><p>applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"demoService01"</span> <span class="attr">class</span>=<span class="string">"com.study.annotation.demo1.DemoService01"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Main01.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优点：将对象的创建交由Spring来控制，而不是通过new来实现</span></span><br><span class="line"><span class="comment"> * 缺点：需要在xml中配置大量的bean，造成配置臃肿</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main01</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">        <span class="comment">// 根据name获取bean</span></span><br><span class="line">        System.out.println(context.getBean(<span class="string">"demoService01"</span>));</span><br><span class="line">        <span class="comment">// 根据type获取bean</span></span><br><span class="line">        System.out.println(context.getBean(DemoService01<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Spring-2-x"><a href="#Spring-2-x" class="headerlink" title="Spring 2.x"></a>Spring 2.x</h2><p>通过注解装配bean，@Required/@Repository/@Aspect。Spring 2.5增加@Component/@Service/@Controller/@RequestMappping</p>
<ul>
<li><p>applicationContext.xml增加注解扫描</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过注解扫描，扫描路径下的注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.study.annotation.demo2"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Main02.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 优点：减少大量bean的配置，只需要关注整合第三方组件的配置，如数据源配置，mybatis配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main02</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">        System.out.println(context.getBean(DemoService02<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Spring-3-x"><a href="#Spring-3-x" class="headerlink" title="Spring 3.x"></a>Spring 3.x</h2><h3 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h3><p>去xml化，无需applicationContext.xml文件。核心目的是：把bean对象如何更加便捷的方式去加载到Spring IOC容器中</p>
<ul>
<li><p>SpringConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.study.annotation.demo3"</span>) <span class="comment">// 相当于&lt;context:component-scan base-package="com.study.annotation.demo3" /&gt;，扫描@Service/@Repository/@Controller等注解，没有@ComponentScan，则无法扫描到这些注解导致注解失效</span></span><br><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 相当于applicationContext.xml</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此处通过<span class="doctag">@Bean</span>来创建对象，则无需在DemoService03上注解<span class="doctag">@Service</span>。</span></span><br><span class="line"><span class="comment">     * 若组件类上使用<span class="doctag">@Service</span>，则不需要<span class="doctag">@Bean</span>注解方法，只需在配置类上增加<span class="doctag">@ComponentScan</span>("com.study.annotation.demo3")</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 相当于&lt;bean name="" class="" /&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoService03 <span class="title">demoService03</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoService03();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Main03.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(context.getBean(DemoService03<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>依赖注入</p>
<p>DemoService03.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService03</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>DemoService04.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService04</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DemoService03 demoService03;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoService03 <span class="title">getDemoService03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService03;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDemoService03</span><span class="params">(DemoService03 demoService03)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.demoService03 = demoService03;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 相当于applicationContext.xml</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 此处通过<span class="doctag">@Bean</span>来创建对象，则无需在DemoService03上注解<span class="doctag">@Service</span>。</span></span><br><span class="line"><span class="comment">     * 若组件类上使用<span class="doctag">@Service</span>，则不需要<span class="doctag">@Bean</span>注解方法，只需在配置类上增加<span class="doctag">@ComponentScan</span>("com.study.annotation.demo3")</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span> <span class="comment">// 相当于&lt;bean name="" class="" /&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoService03 <span class="title">demoService03</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoService03();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DemoService04依赖注入DemoService03</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoService04 <span class="title">demoService04</span><span class="params">(DemoService03 demoService03)</span></span>&#123;</span><br><span class="line">        DemoService04 demoService04 = <span class="keyword">new</span> DemoService04();</span><br><span class="line">        demoService04.setDemoService03(demoService03);</span><br><span class="line">        <span class="keyword">return</span> demoService04;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h3><ul>
<li><p>动态导入其他配置类</p>
<p>ImportConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ImportConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ImportService <span class="title">importService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImportService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Main04.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 动态的导入另外一个配置类，有两种方式</span></span><br><span class="line"><span class="comment">         * 方式一：</span></span><br><span class="line"><span class="comment">         * ApplicationContext context =</span></span><br><span class="line"><span class="comment">         *                 new AnnotationConfigApplicationContext(ImportConfiguration.class, SpringConfiguration.class);</span></span><br><span class="line"><span class="comment">         * 方式二：</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@Import</span>(SpringConfiguration.class)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> AnnotationConfigApplicationContext(ImportConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(context.getBean(DemoService03<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="Enable"><a href="#Enable" class="headerlink" title="@Enable"></a>@Enable</h3><ul>
<li><p>模块驱动，把相关组件的bean自动装配到IOC容器中</p>
<p>Spring3.x版本中，集成Redis或者mybatis：1、创建配置类 2、@Bean注解来声明一个bean</p>
<p>例如：增加定时任务</p>
<ol>
<li><p>applicationContext.xml中增加注解驱动扫描</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过注解扫描，扫描路径下的注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.study.annotation.demo5"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--通过注解驱动扫描Scheduled的定时任务--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">scheduler</span>=<span class="string">"scheduler"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"scheduler"</span> <span class="attr">pool-size</span>=<span class="string">"5"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>TaskService.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">3000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportCurrentTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"current Time: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TaskMain.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context =</span><br><span class="line">                <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>使用@Enable，则无需在xml中增加注解驱动扫描</p>
<ol>
<li><p>TaskConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.study.annotation.demo6"</span>)</span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TaskService02.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskService02</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">3000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportCurrentTime</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"current Time: "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>TaskMain02.java同上</p>
</li>
</ol>
</li>
</ul>
<h2 id="Spring-4-x"><a href="#Spring-4-x" class="headerlink" title="Spring 4.x"></a>Spring 4.x</h2><h3 id="Conditional"><a href="#Conditional" class="headerlink" title="@Conditional"></a>@Conditional</h3><p>@Conditional是Spring4新提供的注解，它的作用是按照一定的条件进行判断，满足条件给容器注册bean。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">// 此注解可以标注在类和方法上</span><br><span class="line">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface Conditional &#123;</span><br><span class="line">    Class<span class="php"><span class="meta">&lt;?</span> extends Condition&gt;[] value();</span></span><br><span class="line"><span class="php">&#125;</span></span><br></pre></td></tr></table></figure>

<p>从代码中可以看到，需要传入一个Class数组，并且需要集成Condition接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext var1, AnnotatedTypeMetadata var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Condition是个接口，需要实现matches方法，返回true则注入bean， false则不注入</p>
<p>示例：</p>
<p>DemoService07.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService07</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String osName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOsName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> osName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOsName</span><span class="params">(String osName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.osName = osName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DemoService07</span><span class="params">(String osName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.osName = osName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"DemoService07&#123;"</span> +</span><br><span class="line">                <span class="string">"osName='"</span> + osName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SpringConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有一个类时，大括号可以省略</span></span><br><span class="line">    <span class="comment">// 如果WindowsCondition返回true时，则注入这个bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(&#123;WindowsCondition<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span>(<span class="title">name</span> </span>= <span class="string">"windows"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoService07 <span class="title">demoService07</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoService07(<span class="string">"windows"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果LinuxCondition返回true时，则注入这个bean</span></span><br><span class="line">    <span class="meta">@Conditional</span>(LinuxCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">Bean</span>(<span class="title">name</span> </span>= <span class="string">"linux"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoService07 <span class="title">demoService07_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoService07(<span class="string">"linux"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>WindowCondition.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conditionContext // 判断条件能使用的上下文环境</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotatedTypeMetadata // 注解所在位置的注释信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取ioc使用的beanFactory</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = conditionContext.getBeanFactory();</span><br><span class="line">        <span class="comment">//获取类加载器</span></span><br><span class="line">        ClassLoader classLoader = conditionContext.getClassLoader();</span><br><span class="line">        <span class="comment">//获取当前环境信息</span></span><br><span class="line">        Environment environment = conditionContext.getEnvironment();</span><br><span class="line">        <span class="comment">//获取bean定义的注册类</span></span><br><span class="line">        BeanDefinitionRegistry registry = conditionContext.getRegistry();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得当前系统名</span></span><br><span class="line">        String property = environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">        <span class="comment">//包含Windows则说明是windows系统，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (property.contains(<span class="string">"Windows"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LinuxCondition.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conditionContext // 判断条件能使用的上下文环境</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> annotatedTypeMetadata // 注解所在位置的注释信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前环境信息</span></span><br><span class="line">        Environment environment = conditionContext.getEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得当前系统名</span></span><br><span class="line">        String property = environment.getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">        <span class="comment">//包含Windows则说明是windows系统，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (property.contains(<span class="string">"Linux"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Main07.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        String osName = context.getEnvironment().getProperty(<span class="string">"os.name"</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前系统为："</span> + osName);</span><br><span class="line">        Map&lt;String, DemoService07&gt; map = context.getBeansOfType(DemoService07<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@Conditional也可以标注在类上，如标注在类上，那么该类下所有@Bean方法 或者@Import 或者 @ComponentScan都会受到其配置条件的影响，如下会注入多个bean实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 环境变量为windows时，两个实例都将被注入</span></span><br><span class="line"><span class="meta">@Conditional</span>(&#123;WindowsCondition<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"windows"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoService07 <span class="title">demoService07</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoService07(<span class="string">"windows"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"linux"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DemoService07 <span class="title">demoService07_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoService07(<span class="string">"linux"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@Conditional注解传入的是Class数组，存在多种条件类的情况下：都返回true时才注入，存在false则不注入</p>
</blockquote>
<h2 id="Spring-5-x"><a href="#Spring-5-x" class="headerlink" title="Spring 5.x"></a>Spring 5.x</h2><h3 id="Indexed"><a href="#Indexed" class="headerlink" title="@Indexed"></a>@Indexed</h3><p>它可以为Spring的模式注解添加索引，以提升应用启动性能。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h3 id="Qualifiler"><a href="#Qualifiler" class="headerlink" title="@Qualifiler"></a>@Qualifiler</h3><h4 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h4><p>Qualifier的意思是合格者，通过这个标示，表明了哪个实现类才是我们所需要的；</p>
<p>@Autowired默认按照类型匹配注入bean，如果有多个相同类型的bean，将抛出 <code>NoUniqueBeanDefinitionException</code>， 以提示有多个满足条件的 <strong>bean</strong> 进行自动装配。程序无法正确做出判断使用哪一个。则框架搭配@Qualifier(“实现类名称”)表明注入的是哪一个实现类的bean;</p>
<p>示例：</p>
<p>DemoService08.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService08</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>QualifierConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifierConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"demoService08_1"</span>)</span><br><span class="line">    <span class="function">DemoService08 <span class="title">demoService08_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoService08();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"demoService08_2"</span>)</span><br><span class="line">    <span class="function">DemoService08 <span class="title">demoService08_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoService08();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>QualifierTestController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifierTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若不使用@Qualifier进行区分，则程序会报错。Could not autowire. There is more than one bean of 'DemoService08' type.</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"demoService08_1"</span>)</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DemoService08 demoService08;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test/qualifier"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">testQualifier</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService08;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高级应用"><a href="#高级应用" class="headerlink" title="高级应用"></a>高级应用</h4><p>区别于上面的基础应用，@Qualifier注解除了用于在属性上、类型进行鉴别，还能把容器内所有标记有@Qualifier依赖注入List。此方式在Ribbon的LoadBalancerAutoConfiguration中就有应用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>DemoService09.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoService09</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>QualifierListConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifierListConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Qualifier</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"demoService09_1"</span>)</span><br><span class="line">    <span class="function">DemoService09 <span class="title">demoService09_1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoService09();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Qualifier</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"demoService09_2"</span>)</span><br><span class="line">    <span class="function">DemoService09 <span class="title">demoService09_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DemoService09();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>QualifierListTestController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifierListTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 将注入被@Qualifier标记的所有bean实例到List集合中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Qualifier</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    List&lt;DemoService09&gt; demoService09List = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/test/qualifier/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">testQualifier</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> demoService09List;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Spring的注解驱动的整个发展过程，目的就是是bean的装载变得更加简单</p>
]]></content>
      <categories>
        <category>微服务架构</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构-4-手动实现一个Spring Boot Starter组件</title>
    <url>/2021/04/20/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-4-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AASpring-Boot-Starter%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="手写一个Spring-Boot-Starter组件"><a href="#手写一个Spring-Boot-Starter组件" class="headerlink" title="手写一个Spring Boot Starter组件"></a>手写一个Spring Boot Starter组件</h1><p>官方的starter组件一般都命名为spring-boot-starter-xxx，如spring-boot-starter-redis。第三方starter组件一般命名为xxx-spring-boot-starter。对于自动装配的配置类命名方式一般xxxAutoConfiguration.java。</p>
<h2 id="创建starter项目"><a href="#创建starter项目" class="headerlink" title="创建starter项目"></a>创建starter项目</h2><p><strong><em>基于maven-quickstart创建项目redisson-spring-boot-starter</em></strong></p>
<ol>
<li><p>pom.xml:引入相关依赖。spring-boot-starter（使用spring boot自动装配注解）、redisson、spring-boot-configuration-processor（更优雅的读取配置文件，提供属性文件提示等）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>RedissonProperties.java:属性文件类，与全局配置文件中的属性进行映射。包括redis连接的相关配置，并指定默认值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"cust.redisson"</span>)<span class="comment">//匹配全局配置文件的前缀</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host = <span class="string">"localhost"</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer port = <span class="number">6379</span>;</span><br><span class="line">    <span class="keyword">private</span> Integer timeout = <span class="number">30000</span>;<span class="comment">// 超时时间</span></span><br><span class="line">    <span class="keyword">private</span> Boolean ssl = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHost</span><span class="params">(String host)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPort</span><span class="params">(Integer port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> timeout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(Integer timeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">getSsl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ssl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSsl</span><span class="params">(Boolean ssl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ssl = ssl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>RedissonAutoConfiguration.java:自动装配配置类，配置RedissonClient bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass</span>(Redisson<span class="class">.<span class="keyword">class</span>)//条件注解，存在<span class="title">Redisson</span>.<span class="title">class</span>时注入以下的<span class="title">bean</span></span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">RedissonProperties</span>.<span class="title">class</span>)//开启配置属性注解，注入属性类</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RedissonAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">(RedissonProperties redissonProperties)</span></span>&#123;</span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        String prefix = <span class="string">"redis://"</span>;</span><br><span class="line">        <span class="keyword">if</span>(redissonProperties.getSsl())&#123;</span><br><span class="line">            prefix = <span class="string">"rediss://"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        config.useSingleServer().</span><br><span class="line">                setAddress(prefix + redissonProperties.getHost() + <span class="string">":"</span> + redissonProperties.getPort()).</span><br><span class="line">                setConnectTimeout(redissonProperties.getTimeout());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>resources/META-INF/spring.factories:配置需要自动装配的配置类的全路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">  com.study.redisson.starter.RedissonAutoConfiguration</span><br></pre></td></tr></table></figure>
</li>
<li><p>maven打包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.redisson.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="创建测试项目"><a href="#创建测试项目" class="headerlink" title="创建测试项目"></a>创建测试项目</h2><p><strong><em>基于Spring Initializr创建项目redisson-spring-boot-use</em></strong></p>
<ol>
<li><p>pom.xml:引入上面打包的starter</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.redisson.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.properties:添加redis连接配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"># 只需指定连接地址，端口号默认，无密码</span><br><span class="line">cust.redisson.host=<span class="number">192.168</span><span class="number">.100</span><span class="number">.201</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>RedissonTestController.java:测试使用Redisson客户端连接redis并获取值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonTestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/starter/test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">starterTest</span><span class="params">(@RequestParam(required = <span class="keyword">true</span>, value=<span class="string">"key"</span>)</span>String key)</span>&#123;</span><br><span class="line">        RBucket&lt;String&gt; rBucket = redissonClient.getBucket(key);</span><br><span class="line">        <span class="keyword">if</span>(rBucket.get() == <span class="keyword">null</span>)&#123;</span><br><span class="line">            rBucket.set(<span class="string">"hello my firster starter"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rBucket.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="另一个自定义Spring-Boot-Starter组件"><a href="#另一个自定义Spring-Boot-Starter组件" class="headerlink" title="另一个自定义Spring Boot Starter组件"></a>另一个自定义Spring Boot Starter组件</h1><p>查看Spring Boot的源码，starter包并没有真正的代码，代码都写在xxx-autoconfigure中。照葫芦画瓢，以下项目将创建一个starter项目和一个autoconfigurer项目，在autoconfigurer项目中写自动配置类，在starter项目中依赖autoconfigure项目，使用时，只需引入starter的maven左边即可。</p>
<h2 id="创建starter项目-1"><a href="#创建starter项目-1" class="headerlink" title="创建starter项目"></a>创建starter项目</h2><p><strong><em>基于maven-quickstart创建项目hello-spring-boot-starter，无需做自动配置，只需引入autoconfigurer项目依赖</em></strong></p>
<ol>
<li><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hello.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>hello-spring-boot-starter<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- FIXME change it to the project's website --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hello.starter.autoconfigurer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-spring-boot-starter-autoconfigurer<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="创建autoconfigurer项目"><a href="#创建autoconfigurer项目" class="headerlink" title="创建autoconfigurer项目"></a>创建autoconfigurer项目</h2><p><strong><em>基于maven-quickstart创建项目hello-spring-boot-starter-autoconfigurer，在本项目中做自动配置</em></strong></p>
<ol>
<li><p>pom.xml:引入相关依赖，spring-boot-starter（使用spring boot自动装配注解）、spring-boot-configuration-processor（更优雅的读取配置文件，提供属性文件提示等）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hello.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>hello-spring-boot-starter<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- FIXME change it to the project's website --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>http://www.example.com<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HelloProperties.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"cust.hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HelloService.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloProperties <span class="title">getHelloProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHelloProperties</span><span class="params">(HelloProperties helloProperties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.helloProperties = helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloProperties.getName() + <span class="string">" say : Hello!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HelloAutoCOnfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HelloProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HelloAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 与上一个例子不同的时，此处依赖注入HelloProperties时，上面例子使用构造器方式依赖注入，而此处使用set方式</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloService();</span><br><span class="line">        helloService.setHelloProperties(helloProperties);</span><br><span class="line">        <span class="keyword">return</span> helloService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>resources/META-INF/spring.factories</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">  com.hello.starter.autoconfigurer.HelloAutoConfiguration</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="创建测试项目-1"><a href="#创建测试项目-1" class="headerlink" title="创建测试项目"></a>创建测试项目</h2><p><strong><em>基于Spring Initializr创建项目hello-spring-boot-starter-test</em></strong></p>
<ol>
<li><p>pom.xml:引入starter项目依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.hello.starter<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hello-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application.properties:配置属性cust.hello.name=张三</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">hello-spring-boot-starter-test</span></span><br><span class="line"><span class="comment"># 应用服务 WEB 访问端口</span></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br><span class="line"></span><br><span class="line"><span class="meta">cust.hello.name</span>=<span class="string">张三</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HelloController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloService helloService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="关于-ConfigurationProperties和-EnableConfigurationProperties"><a href="#关于-ConfigurationProperties和-EnableConfigurationProperties" class="headerlink" title="关于@ConfigurationProperties和@EnableConfigurationProperties"></a>关于@ConfigurationProperties和@EnableConfigurationProperties</h1><h2 id="1-ConfigurationProperties"><a href="#1-ConfigurationProperties" class="headerlink" title="1. @ConfigurationProperties"></a>1. @ConfigurationProperties</h2><p>Spring源码中大量使用了ConfigurationProperties注解，通过与其他注解配合使用，能够实现Bean的按需配置。该注解有一个prefix属性，通过指定的前缀，绑定配置文件中的配置，该注解可以放在类上，也可以放在方法上。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation for externalized configuration. Add this to a class definition or a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@Bean</span>&#125; method in a &#123;<span class="doctag">@code</span> <span class="doctag">@Configuration</span>&#125; class if you want to bind and validate</span></span><br><span class="line"><span class="comment"> * some external Properties (e.g. from a .properties file).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Binding is either performed by calling setters on the annotated class or, if</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> ConstructorBinding <span class="doctag">@ConstructorBinding</span>&#125; is in use, by binding to the constructor</span></span><br><span class="line"><span class="comment"> * parameters.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * Note that contrary to &#123;<span class="doctag">@code</span> <span class="doctag">@Value</span>&#125;, SpEL expressions are not evaluated since property</span></span><br><span class="line"><span class="comment"> * values are externalized.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.0.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationPropertiesScan</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConstructorBinding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurationPropertiesBindingPostProcessor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> EnableConfigurationProperties</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConfigurationProperties &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The prefix of the properties that are valid to bind to this object. Synonym for</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> #prefix()&#125;. A valid prefix is defined by one or more words separated with</span></span><br><span class="line"><span class="comment">	 * dots (e.g. &#123;<span class="doctag">@code</span> "acme.system.feature"&#125;).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the prefix of the properties to bind</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor</span>(<span class="string">"prefix"</span>)</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The prefix of the properties that are valid to bind to this object. Synonym for</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> #value()&#125;. A valid prefix is defined by one or more words separated with</span></span><br><span class="line"><span class="comment">	 * dots (e.g. &#123;<span class="doctag">@code</span> "acme.system.feature"&#125;).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the prefix of the properties to bind</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">	<span class="function">String <span class="title">prefix</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Flag to indicate that when binding to this object invalid fields should be ignored.</span></span><br><span class="line"><span class="comment">	 * Invalid means invalid according to the binder that is used, and usually this means</span></span><br><span class="line"><span class="comment">	 * fields of the wrong type (or that cannot be coerced into the correct type).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the flag value (default false)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">ignoreInvalidFields</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Flag to indicate that when binding to this object unknown fields should be ignored.</span></span><br><span class="line"><span class="comment">	 * An unknown field could be a sign of a mistake in the Properties.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the flag value (default true)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">ignoreUnknownFields</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以从注解说明中看到，当将该注解作用于方法上时，如果想要有效的绑定配置，那么该方法需要有@Bean注解且所属Class需要有@Configuration注解。</p>
<p><strong>简单一句话概括就是：Sring的有效运行是通过上下文（Bean容器）中Bean的配合完成的，Bean可以简单理解成对象，有些对象需要指定字段内容，那么这些内容我们可以通过配置文件进行绑定，然后将此Bean归还给容器</strong></p>
<h3 id="作用于方法"><a href="#作用于方法" class="headerlink" title="作用于方法"></a>作用于方法</h3><p>比较常见的就是配置读写分离的场景。</p>
<p><strong>配置文件内容</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#数据源</span></span><br><span class="line"><span class="meta">spring.datasource.druid.write.url</span>=<span class="string">jdbc:mysql://localhost:3306/jpa</span></span><br><span class="line"><span class="meta">spring.datasource.druid.write.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.druid.write.password</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">spring.datasource.druid.write.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.datasource.druid.read.url</span>=<span class="string">jdbc:mysql://localhost:3306/jpa</span></span><br><span class="line"><span class="meta">spring.datasource.druid.read.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.druid.read.password</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">spring.datasource.druid.read.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></table></figure>

<p><strong>java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidDataSourceConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DataSource 配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.druid.read"</span>)</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"readDruidDataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">readDruidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DataSource 配置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource.druid.write"</span>)</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"writeDruidDataSource"</span>)</span><br><span class="line">    <span class="meta">@Primary</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">writeDruidDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>prefix并没有指定配置的全限定名，那它是怎么进行配置绑定的？</p>
<p>@Value注解可以通过全限定名进行配置的绑定，这里的ConfigurationProperties其实就类似于使用多个@Value同时绑定，绑定的对象就是DataSource类型的对象，而且是隐式绑定的，意味着在配置文件编写的时候需要与对应类的字段名称相同，比如上述<code>spring.datasource.druid.write.url=jdbc:mysql://localhost:3306/jpa</code> ，当然了，你也可以随便写个配置，比如 <code>spring.datasource.druid.write.uuu=www.baidu.com</code>，此时你只需要在注解中加上以下参数即可</p>
<p>以上就完成了多个数据源的配置，为读写分离做了铺垫</p>
<h3 id="作用于Class类及其用法"><a href="#作用于Class类及其用法" class="headerlink" title="作用于Class类及其用法"></a>作用于Class类及其用法</h3><p><strong>配置文件内容</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:8888/test?useUnicode=false&amp;autoReconnect=true&amp;characterEncoding=utf-8</span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.datasource.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.datasource.type</span>=<span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure>

<p><strong>java代码</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.datasource"</span>)</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatasourcePro</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置文件中是driver-class-name, 转驼峰命名便可以绑定成</span></span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDriverClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> driverClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriverClassName</span><span class="params">(String driverClassName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driverClassName = driverClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>用法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/config"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigurationPropertiesController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DatasourcePro datasourcePro;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"url"</span>, datasourcePro.getUrl());</span><br><span class="line">        map.put(<span class="string">"userName"</span>, datasourcePro.getUsername());</span><br><span class="line">        map.put(<span class="string">"password"</span>, datasourcePro.getPassword());</span><br><span class="line">        map.put(<span class="string">"className"</span>, datasourcePro.getDriverClassName());</span><br><span class="line">        map.put(<span class="string">"type"</span>, datasourcePro.getType());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>@ConfigurationProperties和@value有着相同的功能,但是@ConfigurationProperties的写法更为方便</li>
<li>@ConfigurationProperties的POJO类的命名比较严格,因为它必须和prefix的后缀名要一致, 不然值会绑定不上, 特殊的后缀名是“driver-class-name”这种带横杠的情况,在POJO里面的命名规则是下划线转驼峰就可以绑定成功，所以就是 “driverClassName”</li>
</ol>
<h2 id="2-EnableConfigurationProperties"><a href="#2-EnableConfigurationProperties" class="headerlink" title="2.@EnableConfigurationProperties"></a>2.@EnableConfigurationProperties</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>使@ConfigurationProperties注解的类生效。如果一个配置类只配置@ConfigurationProperties注解，而没有使用@Component，那么在IOC容器中是获取不到properties配置文件转化的bean。说白了 @EnableConfigurationProperties 相当于把使用 @ConfigurationProperties 的类进行了一次注入。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>对于Spring Boot来说，激活@ConfigurationProperties，可以通过以下集中方式应用上下文中。</p>
<ol>
<li><p>通过添加@Component注解让Component Scan扫描到。只有当类所在的包被 Spring@ComponentScan注解扫描到才会生效，默认情况下，该注解会扫描在主应用类下的所有包结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"cust.hello"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloProperties</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过添加@Configuration实现。只要该类被Spring Boot扫描到，就可以在应用上下文中访问到该属性类bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloProperties <span class="title">helloProperties</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HelloProperties();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过添加@EnableConfigurationProperties注解让SpringBoot知道，在该注解中其实是用了<code>@Import(EnableConfigurationPropertiesImportSelector.class)</code> 实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigurationProperties</span>(HelloProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Configuration</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">HelloAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HelloService <span class="title">helloService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloService();</span><br><span class="line">        helloService.setHelloProperties(helloProperties);</span><br><span class="line">        <span class="keyword">return</span> helloService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>微服务架构</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构-3-Spring Boot的核心特性及设计思想</title>
    <url>/2021/04/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-3-Spring-Boot%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<h1 id="Spring动态Bean的装载"><a href="#Spring动态Bean的装载" class="headerlink" title="Spring动态Bean的装载"></a>Spring动态Bean的装载</h1><h2 id="ImportSelector实现bean的动态装载"><a href="#ImportSelector实现bean的动态装载" class="headerlink" title="ImportSelector实现bean的动态装载"></a>ImportSelector实现bean的动态装载</h2><ol>
<li><p>自定义RedisConfiguration</p>
<p>CustRedisTemplate.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustRedisTemplate</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RedisConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustRedisTemplate <span class="title">custRedisTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustRedisTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义MybatisConfiguration</p>
<p>CustSqlSessionFactory.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustSqlSessionFactory</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MybatisConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustSqlSessionFactory <span class="title">custSqlSessionFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustSqlSessionFactory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义ImportSelector实现动态批量扫描配置类</p>
<p>CustImportSelector.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ImportSelector实现动态批量的配置类扫描</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        <span class="comment">// 动态导入bean，告诉了Spring两个配置类在哪里</span></span><br><span class="line">        <span class="comment">// 传入需要导入的配置类或这bean，即数组元素可以是CustRedisTemplate.class.getName(), CustSqlSessionFactory.class.getName()</span></span><br><span class="line">        <span class="comment">// System.out.println(RedisConfiguration.class.getName());//com.study.demo02_RedisConfiguration.RedisConfiguration</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;RedisConfiguration<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">MybatisConfiguration</span>.<span class="title">class</span>.<span class="title">getName</span>()&#125;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义Enable注解，用于导入ImportSelector配置类。在开源原件中大部分@Import是伴随着一个@EnableXXX使用的</p>
<p>EnableSelectorConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义注解用于启用ImportSelector配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Import</span>(CustImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableSelectorConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动类使用自定义Enable注解，开启相关配置的装载</p>
<p>SpringbootDemo03RedisApplication.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableSelectorConfiguration</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDemo03RedisApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(SpringbootDemo03RedisApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">        System.out.println(context.getBean(CustRedisTemplate<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        System.out.println(context.getBean(CustSqlSessionFactory<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="ImportBeanDefinitionRegistrar"><a href="#ImportBeanDefinitionRegistrar" class="headerlink" title="ImportBeanDefinitionRegistrar"></a>ImportBeanDefinitionRegistrar</h2><ol>
<li><p>自定义类实现ImportBeanDefinitionRegistrar解口,重写registerBeanDefinitions方法,完成特定对象的装载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustImportBeanDefinitionRegistar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        BeanDefinition redisBeanDefinition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">        redisBeanDefinition.setBeanClassName(RedisConfiguration<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        BeanDefinition mybatisBeanDefinition = <span class="keyword">new</span> GenericBeanDefinition();</span><br><span class="line">        mybatisBeanDefinition.setBeanClassName(MybatisConfiguration<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">"Redis"</span>, redisBeanDefinition);</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">"Mybatis"</span>, mybatisBeanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>自定义Enable注解，用于导入Registar配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Import</span>(CustImportBeanDefinitionRegistar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableRegistarConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动类使用自定义Enable注解，开启相关配置的装载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableRegistarConfiguration</span></span><br><span class="line"><span class="comment">//@EnableSelectorConfiguration</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDemo03RedisApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(SpringbootDemo03RedisApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">        System.out.println(context.getBean(CustRedisTemplate<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        System.out.println(context.getBean(CustSqlSessionFactory<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="Spring自动装配-EnableAutoConfiguration源码解析"><a href="#Spring自动装配-EnableAutoConfiguration源码解析" class="headerlink" title="Spring自动装配@EnableAutoConfiguration源码解析"></a>Spring自动装配@EnableAutoConfiguration源码解析</h1><p>Springboot项目中最核心也是入门级的注解就是@SpringBootApplication，这是由@EnableAutoConfiguration、@ComponentScan和@Configuration组成的一个组合注解。</p>
<p>@EnableAutoConfiguration启用Spring的自动配置，尝试猜测和配置可能需要的bean。通常根据类路径和定义的bean来应用自动配置类。通常建议将@EnableAutoConfiguration（如果不使用@SpringBootApplication）放在根包中，以便可以搜索所有子包和类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Environment property that can be used to override when auto-configuration is</span></span><br><span class="line"><span class="comment">	 * enabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String ENABLED_OVERRIDE_PROPERTY = <span class="string">"spring.boot.enableautoconfiguration"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the classes to exclude</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Exclude specific auto-configuration class names such that they will never be</span></span><br><span class="line"><span class="comment">	 * applied.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the class names to exclude</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 1.3.0</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	String[] excludeName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@EnableAutoConfiguration中通过@Import引入AutoConfigurationImportSelector来动态的装载所需要的bean。</p>
<ol>
<li><p><strong>分析AutoConfigurationImportSelector</strong></p>
<blockquote>
<p>EnableAutoConfiguration有两大属性，exclude和excludeName都是用来指定不需要自动配置的配置类。</p>
<p>AutoConfigurationImportSelector是一个ImportSelector类，selectImports的返回值就是其最后注入IOC容器的配置类。另外，AutoConfigurationImportSelector还用到了beanClassLoader、environment、resourceLoader，因此其还实现了BeanClassLoaderAware，EnviromentAware，ResourceLoaderAware接口。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the &#123;<span class="doctag">@link</span> AutoConfigurationEntry&#125; based on the &#123;<span class="doctag">@link</span> AnnotationMetadata&#125;</span></span><br><span class="line"><span class="comment"> * of the importing &#123;<span class="doctag">@link</span> Configuration <span class="doctag">@Configuration</span>&#125; class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> annotationMetadata the annotation metadata of the configuration class</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the auto-configurations that should be imported</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1、获取注解属性exclude和excludeName</span></span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">// 2、获取所有配置类路径，自动配置路径统一放到META-INF/spring.factories文件下</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">// 3、去除重复项</span></span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    <span class="comment">// 4、exclusions项处理。</span></span><br><span class="line">    <span class="comment">// 如果对于项目中的某些自动配置类，不希望其自动配置，可以通过exclude或excludeName属性进行配置，</span></span><br><span class="line">    <span class="comment">// 或者也可以在配置文件中通过配置项"spring.autoconfigure.exclude"进行配置</span></span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    <span class="comment">// 对exclusions进行验证。exclusions必须是自动配置类，否则抛出异常</span></span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    <span class="comment">// 移除exclusions</span></span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    <span class="comment">// 5、根据项目中的AutoConfigurationImportFilter类进行过滤。</span></span><br><span class="line">    <span class="comment">// 对于自动配置类，只要不满足任意一个filter的match()方法，就将其进行过滤，不再自动配置。</span></span><br><span class="line">    <span class="comment">// 最常见的filter类就是OnClassCondition类，与ConditionalOnClass注解息息相关，判断当前类加载路径下是否有对应文件</span></span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    <span class="comment">// 6、配置监听事件</span></span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring-boot-autoconfigure-2.3.7.RELEASE下的spring.factories文件</p>
<p><img src="/2021/04/12/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-3-Spring-Boot%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7%E5%8F%8A%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/spring.factories.png" alt></p>
</li>
</ol>
<h1 id="SpringBoot条件装配"><a href="#SpringBoot条件装配" class="headerlink" title="SpringBoot条件装配"></a>SpringBoot条件装配</h1><p>我们知道自动装配是SpringBoot微服务化的核心，它会把META-INF/spring.factoires里配置的EnableAutoConfiguration注册到IOC容器里。但是，请大家考虑一个问题，根据需求我们要配置一个tomcat的内嵌容器，可是当前的运行环境里都没有servlet的相关API或者说当前的ApplicationContext不是一个WebApplicationContext，如果这样的话，那么创建tomcat的内嵌容器还有什么意义上呢？如果根据需求我们想自动装配一个Mybatis的SqlSessionFactory，可是运行环境里连DataSource都没有，恐怕要自动装配Mybatis的愿望也会落空吧！针对这种问题，SpringBoot早都考虑到了，下面我们来看看SpringBoot是怎么解决的。</p>
<h2 id="关于-Conditional"><a href="#关于-Conditional" class="headerlink" title="关于@Conditional"></a>关于@Conditional</h2><p>详见上一节</p>
<h2 id="SpringBoot中对-Conditional的扩展"><a href="#SpringBoot中对-Conditional的扩展" class="headerlink" title="SpringBoot中对@Conditional的扩展"></a>SpringBoot中对@Conditional的扩展</h2><p>Spring Boot中，提供了以下条件化注解：</p>
<table>
<thead>
<tr>
<th align="center">条件化注解</th>
<th align="center">配置生效条件</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@ConditionalOnClass</td>
<td align="center">Classpath里有指定的类</td>
</tr>
<tr>
<td align="center">@ConditionalOnMissingClass</td>
<td align="center">Classpath里缺少指定的类</td>
</tr>
<tr>
<td align="center">@ConditionalOnBean</td>
<td align="center">配置了某个特定Bean</td>
</tr>
<tr>
<td align="center">@ConditionalOnMissingBean</td>
<td align="center">没有配置特定的Bean</td>
</tr>
<tr>
<td align="center">@ConditionalOnProperty</td>
<td align="center">指定的配置属性要有一个明确的值</td>
</tr>
<tr>
<td align="center">@ConditionalOnResource</td>
<td align="center">Classpath里有指定的资源</td>
</tr>
<tr>
<td align="center">@ConditionalOnWebApplication</td>
<td align="center">这是一个Web应用程序</td>
</tr>
<tr>
<td align="center">@ConditionalOnNotWebApplication</td>
<td align="center">这不是一个Web应用程序</td>
</tr>
<tr>
<td align="center">@ConditionalOnExpression</td>
<td align="center">给定的SpEL表达式计算结果为true</td>
</tr>
</tbody></table>
<p>另外可以在resources/META-INF目录下的spring-autoconfigure-metadata.properties中配置条件装配，作用同注解方式一样，例如：com.study.autoconfiguration.CustCoreBean.ConditionOnClass=com.study.autoconfiguration.DemoClass</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>见项目springboot-demo01-conditionannotation-demo01</p>
<h1 id="SPI机制"><a href="#SPI机制" class="headerlink" title="SPI机制"></a>SPI机制</h1><p>Service provider interface，是Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件。SPI的作用就是为这些被扩展的API寻找服务实现。而Spring的自动装配就是基于SPI思想实现的一种扩展机制</p>
<p>满足以下条件：</p>
<ol>
<li>需要在classpath目录下创建一个META-INF/services</li>
<li>在该目录下创建一个扩展点的全路径名<ul>
<li>文件中填写这个扩展点的实现</li>
<li>文件编码格式UTF-8</li>
</ul>
</li>
<li>ServiceLoader去进行加载</li>
</ol>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><ol>
<li><p>基于maven-quickstart创建项目jdk-spi-demo01-driver。定义驱动接口</p>
<p>DataBaseDriver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataBaseDriver</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">buildConn</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于maven-quickstart创建项目jdk-spi-demo02-impl。引入jar包并实现驱动接口。在resources目录下创建META-INF/services目录，并在目录下创建文件，文件名为扩展点接口的全路径名（com.study.spi.driver.DataBaseDriver）</p>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.spi.driver<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdk-spi-demo01-driver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MySqlDriver.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySqlDriver</span> <span class="keyword">implements</span> <span class="title">DataBaseDriver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">buildConn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MySql的驱动实现:"</span> + s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>resources/META-INF/services/com.study.spi.driver.DataBaseDriver</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.study.spi.impl.MySqlDriver</span><br><span class="line">com.study.spi.impl.SqlServerDriver</span><br><span class="line">com.study.spi.impl.OracleDriver</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于maven-quickstart创建项目jdk-spi-demo03-use。引入jar包并进行测试</p>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.spi.driver<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdk-spi-demo01-driver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.spi.impl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jdk-spi-demo02-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>App.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ServiceLoader&lt;DataBaseDriver&gt; serviceLoader = ServiceLoader.load(DataBaseDriver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span>(DataBaseDriver dbd : serviceLoader)&#123;</span><br><span class="line">            System.out.println(dbd.buildConn(<span class="string">"Test"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="SPI原理解析"><a href="#SPI原理解析" class="headerlink" title="SPI原理解析"></a>SPI原理解析</h2><p>通过上面简单的demo，可以看到最关键的实现是ServiceLoader这个类，可以看下这个类的源码，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">	<span class="comment">// 扫码目录的前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被加载的类或接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于定位、加载和实例化实现方法的类的类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照实例化的顺序缓存已经实例化的类</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒查找迭代器</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 私有内部类，提供对所有的service的类的加载与实例化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        Class&lt;S&gt; service;</span><br><span class="line">        ClassLoader loader;</span><br><span class="line">        Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;</span><br><span class="line">        Iterator&lt;String&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">        String nextName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fullName = PREFIX + service.getName();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            String cn = nextName;</span><br><span class="line">            nextName = <span class="keyword">null</span>;</span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                S p = service.cast(c.newInstance());</span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">                     x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> hasNextService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nextService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;S&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现Spring自动装配的一个小Demo"><a href="#实现Spring自动装配的一个小Demo" class="headerlink" title="实现Spring自动装配的一个小Demo"></a>实现Spring自动装配的一个小Demo</h1><h2 id="创建maven项目配置需要自动装配的核心bean"><a href="#创建maven项目配置需要自动装配的核心bean" class="headerlink" title="创建maven项目配置需要自动装配的核心bean"></a>创建maven项目配置需要自动装配的核心bean</h2><p><strong><em>基于maven-quickstart创建项目springboot-autoconfiguration-demo01-core</em></strong></p>
<ol>
<li><p>pom.xml:引入spring-context依赖，以使用其@Configuration注解</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CustCoreBean.java:创建需要自动装配的核心bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustCoreBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">autoConfigureBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm auto configuration core bean"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"I'm auto configuration core bean..."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>CustAutoConfiguration.java:创建配置类，注入核心bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustAutoConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustCoreBean <span class="title">custCoreBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustCoreBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring.factories:在resources/META-INF目录下创建spring.factories文件，并添加自动装配的配置类信息，键为固定值org.springframework.boot.autoconfigure.EnableAutoConfiguration=\，值为配置类的全路径名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line">  com.study.autoconfiguration.CustAutoConfiguration</span><br></pre></td></tr></table></figure>
</li>
<li><p>打包成jar</p>
</li>
</ol>
<h2 id="创建SpringBoot项目测试自动装配核心bean"><a href="#创建SpringBoot项目测试自动装配核心bean" class="headerlink" title="创建SpringBoot项目测试自动装配核心bean"></a>创建SpringBoot项目测试自动装配核心bean</h2><p><strong><em>基于Spring Initializr创建项目springboot-autoconfiguration-demo02-use</em></strong></p>
<ol>
<li><p>pom.xml:引入需要自动装配的外部jar包，此时Spring的自动扫描装配即可自动完成装配所需的bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.study.autoconfiguration<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-autoconfiguration-demo01-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>SpringbootAutoconfigurationDemo02UseApplication.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootAutoconfigurationDemo02UseApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConfigurableApplicationContext context = SpringApplication.run(SpringbootAutoconfigurationDemo02UseApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">        CustCoreBean custCoreBean = context.getBean(CustCoreBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(context.getBean(CustCoreBean<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        custCoreBean.autoConfigureBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>输出结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.study.autoconfiguration.CustCoreBean@10643593</span><br><span class="line">I&#39;m auto configuration core bean</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>微服务架构</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构-5-Spring Boot特性之Actuator</title>
    <url>/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><blockquote>
<p>官网介绍：<a href="https://docs.spring.io/spring-boot/docs/2.5.0-SNAPSHOT/reference/html/production-ready-features.html#production-ready" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.5.0-SNAPSHOT/reference/html/production-ready-features.html#production-ready</a></p>
</blockquote>
<ul>
<li>Spring Boot包含许多其他功能，可帮助您在将应用程序推送到生产环境时监视和管理应用程序。</li>
<li>Spring Boot包含许多其他功能，可帮助您在将应用程序推送到生产环境时监视和管理应用程序。</li>
<li>审核，运行状况和指标收集也可以自动应用于您的应用程序。</li>
</ul>
<p><strong>总之Spring Boot Actuator就是一款可以帮助你监控系统数据的框架,其可以监控很多很多的系统数据,它有对应用系统的自省和监控的集成功能，可以查看应用配置的详细信息,如:</strong></p>
<ul>
<li><p>显示应用程序员的Health健康信息</p>
</li>
<li><p>显示Info应用信息</p>
</li>
<li><p>显示HTTP Request跟踪信息</p>
</li>
<li><p>显示当前应用程序的“Metrics”信息</p>
</li>
<li><p>显示所有的@RequestMapping的路径信息</p>
</li>
<li><p>显示应用程序的各种配置信息</p>
</li>
<li><p>显示你的程序请求的次数时间等各种信息</p>
</li>
</ul>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ol>
<li><p><strong>pom.xml中添加依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>所有监控断电endpoints</strong></p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">auditevents</td>
<td align="center">公开当前应用程序的审核事件信息。</td>
</tr>
<tr>
<td align="center">beans</td>
<td align="center">显示应用程序中所有Spring bean的完整列表。</td>
</tr>
<tr>
<td align="center">caches</td>
<td align="center">暴露可用的缓存。</td>
</tr>
<tr>
<td align="center">conditions</td>
<td align="center">显示在配置和自动配置类上评估的条件以及它们匹配或不匹配的原因。</td>
</tr>
<tr>
<td align="center">configprops</td>
<td align="center">显示所有的整理列表@ConfigurationProperties,查看配置属性，包括默认配置</td>
</tr>
<tr>
<td align="center">env</td>
<td align="center">露出Spring的属性的各种环境变量,后面可跟/{name}查看具体的值</td>
</tr>
<tr>
<td align="center">flyway</td>
<td align="center">显示已应用的任何Flyway数据库迁移。</td>
</tr>
<tr>
<td align="center">health</td>
<td align="center">显示应用健康信息,在spring boot2.0以后需要在配置里show-details打开所有健康信息</td>
</tr>
<tr>
<td align="center">httptrace</td>
<td align="center">显示HTTP跟踪信息（默认情况下，最后100个HTTP请求 - 响应交换）,2.0以后需要手动打开</td>
</tr>
<tr>
<td align="center">info</td>
<td align="center">显示任意应用信息,是在配置文件里自己定义的</td>
</tr>
<tr>
<td align="center">integrationgraph</td>
<td align="center">显示Spring Integration图。</td>
</tr>
<tr>
<td align="center">loggers</td>
<td align="center">显示和修改应用程序中记录器的配置。</td>
</tr>
<tr>
<td align="center">liquibase</td>
<td align="center">显示已应用的任何Liquibase数据库迁移。</td>
</tr>
<tr>
<td align="center">metrics</td>
<td align="center">显示当前应用程序的“指标”信息,比如内存用量和HTTP请求计数,后可跟/{name}查看具体值</td>
</tr>
<tr>
<td align="center">mappings</td>
<td align="center">显示所有@RequestMapping路径的整理列表。</td>
</tr>
<tr>
<td align="center">scheduledtasks</td>
<td align="center">显示应用程序中的计划任务。</td>
</tr>
<tr>
<td align="center">sessions</td>
<td align="center">允许从Spring Session支持的会话存储中检索和删除用户会话。使用Spring Session对响应式Web应用程序的支持时不可用</td>
</tr>
<tr>
<td align="center">shutdown</td>
<td align="center">允许应用程序正常关闭。</td>
</tr>
<tr>
<td align="center">threaddump</td>
<td align="center">执行线程转储。</td>
</tr>
</tbody></table>
<p>如果您的应用程序是Web应用程序（Spring MVC，Spring WebFlux或Jersey），则可以使用以下附加端点：</p>
<table>
<thead>
<tr>
<th align="center">ID</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">heapdump</td>
<td align="center">返回hprof堆转储文件。</td>
</tr>
<tr>
<td align="center">jolokia</td>
<td align="center">通过HTTP公开JMX bean（当Jolokia在类路径上时，不适用于WebFlux）。</td>
</tr>
<tr>
<td align="center">logfile</td>
<td align="center">返回日志文件的内容（如果已设置logging.file或logging.path属性）。支持使用HTTP Range标头检索部分日志文件的内容。</td>
</tr>
<tr>
<td align="center">prometheus</td>
<td align="center">可以由Prometheus服务器抓取的格式公开指标。</td>
</tr>
</tbody></table>
</li>
</ol>
<h1 id="Actuator两种形态监控"><a href="#Actuator两种形态监控" class="headerlink" title="Actuator两种形态监控"></a>Actuator两种形态监控</h1><h2 id="HTTP监控"><a href="#HTTP监控" class="headerlink" title="HTTP监控"></a>HTTP监控</h2><ol>
<li><p>在spring boot 2.0以后,actuator默认只开启了info和health两个端点,要想使用其他的端点,需要在application.properties中打开</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#激活所有的端点的web方式请求</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br><span class="line"><span class="comment">#关闭端点web方式</span></span><br><span class="line"><span class="meta">management.endpoints.web.exposure.exclude</span>=<span class="string">env,beans</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>而且所有的端点都以默认的路径<a href="http://localhost:8080/actuator" target="_blank" rel="noopener">http://localhost:8080/actuator</a> 开始，如我们查看info端点的信息就是访问:<a href="http://localhost:8080/actuator/info" target="_blank" rel="noopener">http://localhost:8080/actuator/info</a></p>
</li>
<li><p>Timestamps时间戳: 端点消耗的所有时间戳（作为查询参数或在请求正文中）必须格式化为ISO 8601中指定的偏移日期和时间 。 默认的时间戳是跟我们中国的时区不符合的.</p>
</li>
<li><p>actuator的大部分监控请求都是以get请求的.只有少数是post请求.</p>
</li>
<li><p>如果想更改默认的actuator启动路径的前缀,可以在application.properties中更改,如我们改成 <a href="http://localhost:8080/manage" target="_blank" rel="noopener">http://localhost:8080/manage</a></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.base-path</span>=<span class="string">/manage</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在application.yml中开启所有的Health监控数据。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoint.health.show-details</span>=<span class="string">always</span></span><br></pre></td></tr></table></figure>

<p>health端点不仅仅只包含springboot应用本身的健康状态，还包含其他引用包的使用状态，如redis等。</p>
</li>
<li><p>metrics包含很多系统信息，如JVM（内存/堆）、系统（运行时间/平均负载/处理器的信息）、线程池信息、tomcat会话信息</p>
</li>
</ol>
<h2 id="JMX-Java-Management-Extensions-监控"><a href="#JMX-Java-Management-Extensions-监控" class="headerlink" title="JMX(Java Management Extensions)监控"></a>JMX(Java Management Extensions)监控</h2><p>对于Spring Boot项目，还可以通过Java管理扩展（JMX）来让开发人员监控JVM的状况。</p>
<h3 id="1-激活jmx监控"><a href="#1-激活jmx监控" class="headerlink" title="1. 激活jmx监控"></a>1. 激活jmx监控</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#激活所有的JMX方式请求</span></span><br><span class="line"><span class="meta">management.endpoints.jmx.exposure.include</span>=<span class="string">*</span></span><br><span class="line"><span class="comment">#开启spring的jmx监控</span></span><br><span class="line"><span class="meta">spring.jmx.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-控制台调用Java内置的jconsole来实现JMX监控"><a href="#2-控制台调用Java内置的jconsole来实现JMX监控" class="headerlink" title="2.控制台调用Java内置的jconsole来实现JMX监控"></a>2.控制台调用Java内置的jconsole来实现JMX监控</h3><p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/cmd%E6%89%93%E5%BC%80jconsole.jpg" alt></p>
<p>这时会打开jconsole页面，选择当前的程序进程，如下：</p>
<p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/jmx%E7%9B%91%E6%8E%A7%E6%8E%A7%E5%88%B6%E5%8F%B0.jpg" alt></p>
<p>进入界面后，在MBean标签的org.springframework.boot域下可对我们的程序进行监控和管理，如下：</p>
<p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/jmx%E7%9B%91%E6%8E%A7%E7%AB%AF%E7%82%B9.jpg" alt></p>
<h1 id="自定义端点"><a href="#自定义端点" class="headerlink" title="自定义端点"></a>自定义端点</h1><h2 id="自定义端点使用到的注解"><a href="#自定义端点使用到的注解" class="headerlink" title="自定义端点使用到的注解"></a>自定义端点使用到的注解</h2><p>可以使用<code>@Endpoint</code>,<code>@WebEndpoint</code>,<code>@JmxEndpoint</code>,或者<code>EndpointWebExtension</code>来实现HTTP方式的端点,可以是传统SpringMVC也可以是最新的<code>Spring WebFlux</code></p>
<ul>
<li><code>@Endpoint</code>相当于<code>@WebEndpoint</code>和<code>@JmxEndpoint</code>的整合。web和jmx方式都支持</li>
<li><code>@WebEndpoint</code> 只会生成web的方式的端点监控</li>
<li><code>@JmxEndpoint</code> 只会生成Jmx的方式监控</li>
</ul>
<h2 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h2><p>默认的基础路径是<code>/actuator</code>,如果一个端点配置的路径是<code>sessions</code>,那么它的全路径就是<code>/actuator/sessions</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@WebEndpoint</span>(id = <span class="string">"sessions"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthEndpoint</span> </span>&#123;</span><br><span class="line">  <span class="meta">@ReadOperation</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Info <span class="title">get</span><span class="params">(@Selector String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Info(name, <span class="string">"23"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Selector</code> 的含义是让这个路径变成<code>/actuator/sessions/{name}</code> 我们能从路径上获取一个入参。</p>
<h2 id="自定义管理端点路径"><a href="#自定义管理端点路径" class="headerlink" title="自定义管理端点路径"></a>自定义管理端点路径</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">management.endpoints.web.base-path &#x3D; &#x2F;manage</span><br></pre></td></tr></table></figure>

<p>此配置会将<code>/actuator/sessions/{name}</code>转换成<code>/manage/sessions/{name}</code></p>
<h2 id="自定义管理服务器地址"><a href="#自定义管理服务器地址" class="headerlink" title="自定义管理服务器地址"></a>自定义管理服务器地址</h2><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.server.port</span> = <span class="string">8081</span></span><br><span class="line"><span class="meta">management.server.address</span> = <span class="string">127.0.0.1</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>@Endpoint就相当于声明称一个@RestController的控制类，而请求方法分别被下面注解代替</p>
<table>
<thead>
<tr>
<th align="center"><strong>Operation</strong></th>
<th align="center"><strong>HTTP method</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">@ReadOperation</td>
<td align="center">GET</td>
</tr>
<tr>
<td align="center">@WriteOperation</td>
<td align="center">POST</td>
</tr>
<tr>
<td align="center">@DeleteOperation</td>
<td align="center">DELETE</td>
</tr>
</tbody></table>
<h1 id="自定义JMX监控对象"><a href="#自定义JMX监控对象" class="headerlink" title="自定义JMX监控对象"></a>自定义JMX监控对象</h1><h2 id="1-创建SystemInfoMBean接口"><a href="#1-创建SystemInfoMBean接口" class="headerlink" title="1.创建SystemInfoMBean接口"></a>1.创建SystemInfoMBean接口</h2><p>定义cpu核心数、总内存、shutDown等方法。命名规范以MBean结尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口命名规范一定是以MBean结尾，默认以get开头为属性，其余为操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SystemInfoMBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCpuCore</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getTotalMemory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-创建SystemInfo实现类"><a href="#2-创建SystemInfo实现类" class="headerlink" title="2.创建SystemInfo实现类"></a>2.创建SystemInfo实现类</h2><p>实现上述接口，命名规范与接口名一致去掉MBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemInfo</span> <span class="keyword">implements</span> <span class="title">SystemInfoMBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCpuCore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Runtime.getRuntime().availableProcessors();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTotalMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Runtime.getRuntime().totalMemory();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-创建测试类TestMain"><a href="#3-创建测试类TestMain" class="headerlink" title="3.创建测试类TestMain"></a>3.创建测试类TestMain</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> MalformedObjectNameException, NotCompliantMBeanException, InstanceAlreadyExistsException, MBeanRegistrationException, IOException </span>&#123;</span><br><span class="line">        MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();</span><br><span class="line">        ObjectName objectName = <span class="keyword">new</span> ObjectName(<span class="string">"com.example.jmxendpoint:type=SystemInfo"</span>);</span><br><span class="line">        SystemInfo systemInfo = <span class="keyword">new</span> SystemInfo();</span><br><span class="line">        mBeanServer.registerMBean(systemInfo, objectName);</span><br><span class="line">        <span class="comment">// 阻塞</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-查看jconsole的MBean信息"><a href="#4-查看jconsole的MBean信息" class="headerlink" title="4.查看jconsole的MBean信息"></a>4.查看jconsole的MBean信息</h2><p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/%E8%87%AA%E5%AE%9A%E4%B9%89jmx%E7%9B%91%E6%8E%A7%E5%AF%B9%E8%B1%A1.jpg" alt></p>
<h1 id="Spring-Boot定义JMX监控对象源码解析"><a href="#Spring-Boot定义JMX监控对象源码解析" class="headerlink" title="Spring Boot定义JMX监控对象源码解析"></a>Spring Boot定义JMX监控对象源码解析</h1><p>![](微服务架构-5-Spring-Boot特性之Actuator/Spring Boot JMX监控对象.png)</p>
<p>通过查看SpringBoot项目的JMX监控控制台，发现其存在一个type为Admin，name为SpringApplication的MBean对象。查看SpringBoot源码，其通过创建SpringApplicationAdminMXBean接口，并通过SpringApplicationAdminMXBeanRegistrar实现其方法，最后由SpringApplicationAdminJmxAutoConfiguration.java进行自动装配。</p>
<h2 id="1-SpringApplicationAdminMXBean-java"><a href="#1-SpringApplicationAdminMXBean-java" class="headerlink" title="1. SpringApplicationAdminMXBean.java"></a>1. SpringApplicationAdminMXBean.java</h2><p>定义MXBean接口，并定义两个属性和两个操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SpringApplicationAdminMXBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmbeddedWebApplication</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-SpringApplicationAdminMXBeanRegistrar-java"><a href="#2-SpringApplicationAdminMXBeanRegistrar-java" class="headerlink" title="2.SpringApplicationAdminMXBeanRegistrar.java"></a>2.SpringApplicationAdminMXBeanRegistrar.java</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplicationAdminMXBeanRegistrar</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">GenericApplicationListener</span>, <span class="title">EnvironmentAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(SpringApplicationAdminMXBeanRegistrar.SpringApplicationAdmin<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext applicationContext;</span><br><span class="line">    <span class="keyword">private</span> Environment environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectName objectName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> ready = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> embeddedWebApplication = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpringApplicationAdminMXBeanRegistrar</span><span class="params">(String name)</span> <span class="keyword">throws</span> MalformedObjectNameException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objectName = <span class="keyword">new</span> ObjectName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现ApplicationContextAware接口的方法，设置应用上下文</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        Assert.state(applicationContext <span class="keyword">instanceof</span> ConfigurableApplicationContext, <span class="string">"ApplicationContext does not implement ConfigurableApplicationContext"</span>);</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = (ConfigurableApplicationContext)applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现EnvironmentAware接口的方法，设置当前环境变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; type = eventType.getRawClass();</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ApplicationReadyEvent<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>) || <span class="title">WebServerInitializedEvent</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">type</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsSourceType</span><span class="params">(Class&lt;?&gt; sourceType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationReadyEvent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.onApplicationReadyEvent((ApplicationReadyEvent)event);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (event <span class="keyword">instanceof</span> WebServerInitializedEvent) &#123;</span><br><span class="line">            <span class="keyword">this</span>.onWebServerInitializedEvent((WebServerInitializedEvent)event);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">2147483648</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onApplicationReadyEvent</span><span class="params">(ApplicationReadyEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext.equals(event.getApplicationContext())) &#123;</span><br><span class="line">            <span class="keyword">this</span>.ready = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onWebServerInitializedEvent</span><span class="params">(WebServerInitializedEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext.equals(event.getApplicationContext())) &#123;</span><br><span class="line">            <span class="keyword">this</span>.embeddedWebApplication = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现InitializingBean接口的方法，初始化bean时候的调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MBeanServer server = ManagementFactory.getPlatformMBeanServer();</span><br><span class="line">        server.registerMBean(<span class="keyword">new</span> SpringApplicationAdminMXBeanRegistrar.SpringApplicationAdmin(), <span class="keyword">this</span>.objectName);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Application Admin MBean registered with name '"</span> + <span class="keyword">this</span>.objectName + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现DisposableBean接口的方法，销毁bean时的调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ManagementFactory.getPlatformMBeanServer().unregisterMBean(<span class="keyword">this</span>.objectName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现上述MXBean接口，命名同接口去掉MXBean</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplicationAdmin</span> <span class="keyword">implements</span> <span class="title">SpringApplicationAdminMXBean</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">SpringApplicationAdmin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SpringApplicationAdminMXBeanRegistrar.<span class="keyword">this</span>.ready;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmbeddedWebApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SpringApplicationAdminMXBeanRegistrar.<span class="keyword">this</span>.embeddedWebApplication;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SpringApplicationAdminMXBeanRegistrar.<span class="keyword">this</span>.environment.getProperty(key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            SpringApplicationAdminMXBeanRegistrar.logger.info(<span class="string">"Application shutdown requested."</span>);</span><br><span class="line">            SpringApplicationAdminMXBeanRegistrar.<span class="keyword">this</span>.applicationContext.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-SpringApplicationAdminJmxAutoConfiguration-java"><a href="#3-SpringApplicationAdminJmxAutoConfiguration-java" class="headerlink" title="3.SpringApplicationAdminJmxAutoConfiguration.java"></a>3.SpringApplicationAdminJmxAutoConfiguration.java</h2><p>自动配置类，对定义的MXBean进行自动装配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@AutoConfigureAfter</span>(JmxAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">prefix</span> </span>= <span class="string">"spring.application.admin"</span>, value = <span class="string">"enabled"</span>, havingValue = <span class="string">"true"</span>,</span><br><span class="line">		matchIfMissing = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringApplicationAdminJmxAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The property to use to customize the &#123;<span class="doctag">@code</span> ObjectName&#125; of the application admin</span></span><br><span class="line"><span class="comment">	 * mbean.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JMX_NAME_PROPERTY = <span class="string">"spring.application.admin.jmx-name"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The default &#123;<span class="doctag">@code</span> ObjectName&#125; of the application admin mbean.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_JMX_NAME = <span class="string">"org.springframework.boot:type=Admin,name=SpringApplication"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SpringApplicationAdminMXBeanRegistrar <span class="title">springApplicationAdminRegistrar</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ObjectProvider&lt;MBeanExporter&gt; mbeanExporters, Environment environment)</span> <span class="keyword">throws</span> MalformedObjectNameException </span>&#123;</span><br><span class="line">		String jmxName = environment.getProperty(JMX_NAME_PROPERTY, DEFAULT_JMX_NAME);</span><br><span class="line">		<span class="keyword">if</span> (mbeanExporters != <span class="keyword">null</span>) &#123; <span class="comment">// Make sure to not register that MBean twice</span></span><br><span class="line">			<span class="keyword">for</span> (MBeanExporter mbeanExporter : mbeanExporters) &#123;</span><br><span class="line">				mbeanExporter.addExcludedBean(jmxName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SpringApplicationAdminMXBeanRegistrar(jmxName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="手动实现将SystemInfoMBean通过SpringBoot进行jmx监控"><a href="#手动实现将SystemInfoMBean通过SpringBoot进行jmx监控" class="headerlink" title="手动实现将SystemInfoMBean通过SpringBoot进行jmx监控"></a>手动实现将SystemInfoMBean通过SpringBoot进行jmx监控</h1><h2 id="1-CustomerApplicationMXBeanRegistrar-java"><a href="#1-CustomerApplicationMXBeanRegistrar-java" class="headerlink" title="1. CustomerApplicationMXBeanRegistrar.java"></a>1. CustomerApplicationMXBeanRegistrar.java</h2><p>定义一个registrar，模拟上报MXBean到jmx</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerApplicationMXBeanRegistrar</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">EnvironmentAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConfigurableApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Environment environment = <span class="keyword">new</span> StandardEnvironment();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ObjectName objectName = <span class="keyword">new</span> ObjectName(<span class="string">"com.example.jmxendpoint:type=SystemInfo"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomerApplicationMXBeanRegistrar</span><span class="params">()</span> <span class="keyword">throws</span> MalformedObjectNameException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MBeanServer server = ManagementFactory.getPlatformMBeanServer();</span><br><span class="line">        server.registerMBean(<span class="keyword">new</span> SystemInfo(), <span class="keyword">this</span>.objectName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = (ConfigurableApplicationContext)applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnvironment</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.environment = environment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-查看jconsole的MBean信息"><a href="#2-查看jconsole的MBean信息" class="headerlink" title="2.查看jconsole的MBean信息"></a>2.查看jconsole的MBean信息</h2><p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/%E6%89%8B%E5%8A%A8%E9%80%9A%E8%BF%87springboot%E5%AE%9E%E7%8E%B0jmx%E7%9B%91%E6%8E%A7.jpg" alt></p>
<h1 id="开源监控系统Prometheus-Grafana"><a href="#开源监控系统Prometheus-Grafana" class="headerlink" title="开源监控系统Prometheus+Grafana"></a>开源监控系统Prometheus+Grafana</h1><h2 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h2><blockquote>
<p>官网地址：<a href="https://prometheus.io/" target="_blank" rel="noopener">https://prometheus.io/</a></p>
</blockquote>
<ol>
<li><p><strong>下载</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;github.com&#x2F;prometheus&#x2F;prometheus&#x2F;releases&#x2F;download&#x2F;v2.26.0&#x2F;prometheus-2.26.0.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解压</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf prometheus-2.26.0.linux-amd64</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>SpringBoot引入prometheus依赖</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.micrometer<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>micrometer-registry-prometheus<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>查看prometheus监控信息</strong></p>
<p><a href="http://localhost:8081/methrics/prometheus" target="_blank" rel="noopener">http://localhost:8081/methrics/prometheus</a></p>
</li>
<li><p><strong>配置prometheus监控节点</strong></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># my global config</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span>     <span class="string">15s</span> <span class="comment"># Set the scrape interval to every 15 seconds. Default is every 1 minute.</span></span><br><span class="line">  <span class="attr">evaluation_interval:</span> <span class="string">15s</span> <span class="comment"># Evaluate rules every 15 seconds. The default is every 1 minute.</span></span><br><span class="line">  <span class="comment"># scrape_timeout is set to the global default (10s).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Alertmanager configuration</span></span><br><span class="line"><span class="attr">alerting:</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span></span><br><span class="line">      <span class="comment"># - alertmanager:9093</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Load rules once and periodically evaluate them according to the global 'evaluation_interval'.</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="comment"># - "first_rules.yml"</span></span><br><span class="line">  <span class="comment"># - "second_rules.yml"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line"><span class="attr">scrape_configs:</span></span><br><span class="line">  <span class="comment"># The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'prometheus'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># metrics_path defaults to '/metrics'</span></span><br><span class="line">    <span class="comment"># scheme defaults to 'http'.</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['localhost:9090']</span></span><br><span class="line">  <span class="comment"># 新增springboot监控节点</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">'spring-boot'</span></span><br><span class="line">    <span class="comment"># 配置metrics地址，根据该地址采集数据</span></span><br><span class="line">    <span class="attr">metrics_path:</span> <span class="string">'/actuator/prometheus'</span></span><br><span class="line">    <span class="comment"># 扫描间隔，默认15s</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span></span><br><span class="line">    <span class="comment"># 配置目标节点</span></span><br><span class="line">    <span class="attr">static_configs:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.100.17:8081']</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动prometheus</strong></p>
<p><strong>用指定配置文件启动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;prometheus --config.file prometheus.yml</span><br></pre></td></tr></table></figure>

<p><strong>后台启动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup .&#x2F;prometheus --config.file prometheus.yml</span><br></pre></td></tr></table></figure>

<p><strong>相关启动参数：</strong></p>
<p>–web.enable-admin-api  该参数为开启API服务</p>
<p>–web.enable-lifecycle  该参数为开启动态加载配置文件</p>
<p>–config.file=/安装目录/prometheus.yml 该参数为指定配置文件路径</p>
<p><strong>其他命令：</strong></p>
<p>开启–web.enable-admin-api状态下：</p>
<p><strong>删除指定 Metric 名称全部数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST -g &#39;http:&#x2F;&#x2F;ip:9090&#x2F;api&#x2F;v1&#x2F;admin&#x2F;tsdb&#x2F;delete_series?match[]&#x3D;test&#39;</span><br></pre></td></tr></table></figure>

<p><strong>删除指定 Metric 名称和 label 名称的全部数据</strong></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST -g &#39;http:&#x2F;&#x2F;ip:9090&#x2F;api&#x2F;v1&#x2F;admin&#x2F;tsdb&#x2F;delete_series?match[]&#x3D;test&#123;mode&#x3D;&quot;123&quot;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><strong>删除指定时间范围内的 Metric 数据</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST -g &#39;http:&#x2F;&#x2F;127.0.0.1:9090&#x2F;api&#x2F;v1&#x2F;admin&#x2F;tsdb&#x2F;delete_series?start&#x3D;1578301194&amp;end&#x3D;1578301694&amp;match[]&#x3D;test&#123;mode&#x3D;&quot;123&quot;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p><strong>清理数据，从磁盘删除已经被 delete_series 接口删除的数据，并清理现有的 tombstones</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST http:&#x2F;&#x2F;127.0.0.1:9090&#x2F;api&#x2F;v1&#x2F;admin&#x2F;tsdb&#x2F;clean_tombstones</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><blockquote>
<p>官方地址：<a href="https://grafana.com/" target="_blank" rel="noopener">https://grafana.com/</a></p>
</blockquote>
<ol>
<li><p><strong>下载</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用华为开源镜像站地址（https:&#x2F;&#x2F;mirrors.huaweicloud.com&#x2F;）</span><br><span class="line">wget https:&#x2F;&#x2F;repo.huaweicloud.com&#x2F;grafana&#x2F;7.5.5&#x2F;grafana-7.5.5.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解压</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf grafana-7.5.5.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>启动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd grafana-7.5.5&#x2F;bin</span><br><span class="line">.&#x2F;grafana-server</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问</strong></p>
<p>地址：<a href="http://192.168.100.201:3000/" target="_blank" rel="noopener">http://192.168.100.201:3000/</a></p>
<p>初始账号密码：admin/admin</p>
</li>
<li><p><strong>添加数据源</strong></p>
<p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/grafana%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%BA%90prometheus_1.jpg" alt></p>
<p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/grafana%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE%E6%BA%90prometheus_2.jpg" alt></p>
</li>
<li><p><strong>添加DashBoard</strong></p>
<p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/grafana%E6%B7%BB%E5%8A%A0dashboard_1.jpg" alt></p>
<p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/grafana%E6%B7%BB%E5%8A%A0dashboard_2.jpg" alt></p>
<p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/grafana%E6%B7%BB%E5%8A%A0dashboard_3.jpg" alt></p>
</li>
<li><p><strong>使用grafana官方DashBoard模板</strong></p>
<p>地址：<a href="https://grafana.com/grafana/dashboards" target="_blank" rel="noopener">https://grafana.com/grafana/dashboards</a></p>
<p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/grafana%E5%AE%98%E6%96%B9dashboard%E6%A8%A1%E6%9D%BF_1.jpg" alt></p>
<p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/grafana%E5%AE%98%E6%96%B9dashboard%E6%A8%A1%E6%9D%BF_2.jpg" alt></p>
<p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/grafana%E5%AE%98%E6%96%B9dashboard%E6%A8%A1%E6%9D%BF_3.jpg" alt></p>
<p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/grafana%E5%AE%98%E6%96%B9dashboard%E6%A8%A1%E6%9D%BF_4.jpg" alt></p>
<p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/grafana%E5%AE%98%E6%96%B9dashboard%E6%A8%A1%E6%9D%BF_5.jpg" alt></p>
<p><img src="/2021/04/21/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-5-Spring-Boot%E7%89%B9%E6%80%A7%E4%B9%8BActuator/grafana%E5%AE%98%E6%96%B9dashboard%E6%A8%A1%E6%9D%BF_6.jpg" alt></p>
</li>
</ol>
]]></content>
      <categories>
        <category>微服务架构</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构-7-Spring-Cloud-Netflix-Config</title>
    <url>/2021/07/05/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-8-Spring-Cloud-Netflix-Config/</url>
    <content><![CDATA[<h1 id="搭建配置中心"><a href="#搭建配置中心" class="headerlink" title="搭建配置中心"></a>搭建配置中心</h1><blockquote>
<p>说明：配置中心的配置来源为git</p>
</blockquote>
<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">springcloud-config-server</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">9092</span></span><br><span class="line"><span class="comment">#配置git仓库地址</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.uri</span>=<span class="string">https://gitee.com/xxx/spring-cloud-config-server.git</span></span><br><span class="line"><span class="comment">#配置git仓库连接用户名</span></span><br><span class="line"><span class="comment">#spring.cloud.config.server.git.username=xxx</span></span><br><span class="line"><span class="comment">#配置git仓库连接用户密码</span></span><br><span class="line"><span class="comment">#spring.cloud.config.server.git.password=xxx</span></span><br><span class="line"><span class="comment">#配置仓库的分支</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.default-label</span>=<span class="string">master</span></span><br><span class="line"><span class="comment">#仓库文件夹目录，如果是/**，就是所有目录所有文件</span></span><br><span class="line"><span class="meta">spring.cloud.config.server.git.search-paths</span>=<span class="string">/**</span></span><br><span class="line"></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:9090/eureka</span></span><br></pre></td></tr></table></figure>

<p>开启配置中心服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringcloudConfigServerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringcloudConfigServerApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="配置中心客户端"><a href="#配置中心客户端" class="headerlink" title="配置中心客户端"></a>配置中心客户端</h1><blockquote>
<p>说明：从上面搭建的配置中心获取配置，根据项目名，获取匹配该项目名的相关配置</p>
</blockquote>
<p>pom.xml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--eureka必须引入web starter，否则无法注册--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>bootstrap.properties</p>
<blockquote>
<p>当需要从配置中心config server中获取配置数据时，需要在加载属性之前从config server上获取到配置文件，那spring.cloud.config相关配置需要最先加载，而bootstrap.properties加载顺序在application.properties之前，所以，config client要配置config的相关配置就只能写到bootstrap.properties里了</p>
</blockquote>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开启从配置中心获取配置</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment"># 配置中心的服务ID</span></span><br><span class="line"><span class="meta">spring.cloud.config.discovery.service-id</span>=<span class="string">springcloud-config-server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务注册中心</span></span><br><span class="line"><span class="meta">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:9090/eureka</span></span><br></pre></td></tr></table></figure>

<p>application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="meta">spring.application.name</span>=<span class="string">springcloud-config-service</span></span><br><span class="line"></span><br><span class="line"><span class="meta">server.port</span>=<span class="string">8080</span></span><br></pre></td></tr></table></figure>

<p>ConfigController.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;hello&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String config;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="刷新配置"><a href="#刷新配置" class="headerlink" title="刷新配置"></a>刷新配置</h1><blockquote>
<p>当配置修改时，config提供一种手动刷新机制来刷新配置信息，即使用actuator的refresh功能来刷新配置</p>
</blockquote>
<p>pom.xml 添加actuator依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.properties 添加刷新监控</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">management.endpoints.web.exposure.include</span>=<span class="string">refresh</span></span><br></pre></td></tr></table></figure>

<p>ConfigController.java 添加刷新范围注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加此配置，可以通过http请求，手动刷新配置信息。</span></span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;hello&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String config;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/config"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getConfigs</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过http工具调用actuator刷新请求，即可实现手动刷新配置</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">POST:http://localhost:8080/actuator/refresh</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>微服务架构</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构-6-Spring Cloud Netflix Ribbon</title>
    <url>/2021/05/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-6-Spring-Cloud-Netflix-Ribbon/</url>
    <content><![CDATA[<h1 id="Spring-Cloud-Ribbon"><a href="#Spring-Cloud-Ribbon" class="headerlink" title="Spring Cloud Ribbon"></a>Spring Cloud Ribbon</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li><p>解析配置中的服务器列表</p>
</li>
<li><p>基于负载均衡算法来实现请求的分发</p>
</li>
</ol>
<h2 id="负载均衡调用方式："><a href="#负载均衡调用方式：" class="headerlink" title="负载均衡调用方式："></a>负载均衡调用方式：</h2><ol>
<li>启动服务实例并注册到一个或多个注册中心</li>
<li>消费者通过调用被@LoadBalanced注解修饰过的RestTemplate来实现服务接口的调用</li>
</ol>
<h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><h3 id="1-getForEntity"><a href="#1-getForEntity" class="headerlink" title="1. getForEntity"></a>1. getForEntity</h3><p><strong>重载方法:</strong></p>
<p>getForEntity(String url, Class responseType, Object…urlVariable);</p>
<p>getForEntity(String url, Class responseType, Map urlVariable);</p>
<p>getForEntity(URI url, Class responseType);</p>
<p><strong>返回值:</strong>ResponseEntity对象，其中的body内容类型会根据第二个参数转换为对应的对象类型</p>
<p><strong>参数：</strong></p>
<p>url:请求地址。请求地址有两种形式：</p>
<p>​    1、String url:http请求地址</p>
<p>​    2、URI url:使用JDK java.net包下的一个类，表示统一资源标识符（Uniform Resource Identifier）引用。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">UriComponents uriComponents = UriComponentsBuilder.fromUriString(<span class="string">"http://host/user?name=&#123;name&#125;"</span>).build().expand(<span class="string">"dodo"</span>).encode();</span><br><span class="line">URI uri = uriComponents.toUri();</span><br><span class="line">ResponseEntity&lt;String&gt; responseENtity = restTemplate.getForEntity(uri, String<span class="class">.<span class="keyword">class</span>).<span class="title">getBody</span>()</span>;</span><br></pre></td></tr></table></figure>

<p>responseType:请求响应体body的包装类型</p>
<p>urlVariables:url中的参数绑定。该参数有两种形式：</p>
<p>​    1、Object…urlVariables:为数组时，数组顺序对应url中占位符定义的数字。比如：<a href="http://host/user?name={1}" target="_blank" rel="noopener">http://host/user?name={1}</a></p>
<p>​    2、Map urlVariables:为Map类型时，参数绑定对应占位符中指定的Map中的参数的key值。比如：<a href="http://host/user?name={name}" target="_blank" rel="noopener">http://host/user?name={name}</a></p>
<h3 id="2-getForObject"><a href="#2-getForObject" class="headerlink" title="2. getForObject"></a>2. getForObject</h3><p><strong>重载方法:</strong></p>
<p>getForObject(String url, Class responseType, Object…urlVariable);</p>
<p>getForObject(String url, Class responseType, Map urlVariable);</p>
<p>getForObject(URI url, Class responseType);</p>
<p><strong>返回值：</strong>返回第二个参数对应的对象类型</p>
<p><strong>参数：</strong>同上</p>
<h3 id="3-postForEntity"><a href="#3-postForEntity" class="headerlink" title="3. postForEntity"></a>3. postForEntity</h3><p><strong>重载方法:</strong></p>
<p>postForEntity(String url, Object request, Class responseType, Object…urlVariable);</p>
<p>postForEntity(String url, Object request, Class responseType, Map urlVariable);</p>
<p>postForEntity(URI url, Object request, Class responseType);</p>
<p><strong>返回值：</strong>ResponseEntity对象，其中的body内容类型会根据第二个参数转换为对应的对象类型</p>
<p><strong>参数：</strong></p>
<p>url:同上</p>
<p>request:普通对象或HttpEntity对象，包含了post请求的body内容和header内容。如果是普通对象，则会转换为一个HttpEntity对象来处理；而如果是一个HttpEntity对象，那么会欸当作一个完整的HTTP请求对象来处理。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RestTemplate restTemplate = <span class="keyword">new</span> RestTemplate();</span><br><span class="line">HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">MediaType type = MediaType.parseMediaType(<span class="string">"application/json; charset=UTF-8"</span>);</span><br><span class="line">headers.setContentType(type);</span><br><span class="line">headers.add(<span class="string">"Accept"</span>, MediaType.APPLICATION_JSON.toString());</span><br><span class="line"></span><br><span class="line">JSONObject param = <span class="keyword">new</span> JSONObject();</span><br><span class="line">param.put(<span class="string">"username"</span>, <span class="string">"123"</span>);</span><br><span class="line"><span class="comment">// 包装HttpEntity对象</span></span><br><span class="line">HttpEntity&lt;String&gt; formEntity = <span class="keyword">new</span> HttpEntity&lt;String&gt;(param, headers);</span><br><span class="line"></span><br><span class="line">String result = restTemplate.postForObject(url, formEntity, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>urlVariables:如果url地址上面需要传递一些动态参数，可以使用占位符的方式，具体的用法和使用GET方法请求是一致的。比如：</p>
<p><a href="http://host/{1}/{2}、http://host/{type}/{id}" target="_blank" rel="noopener">http://host/{1}/{2}、http://host/{type}/{id}</a></p>
<h3 id="4-postForObject"><a href="#4-postForObject" class="headerlink" title="4. postForObject"></a>4. postForObject</h3><h3 id="5-postForLocation"><a href="#5-postForLocation" class="headerlink" title="5. postForLocation"></a>5. postForLocation</h3><h3 id="6-put"><a href="#6-put" class="headerlink" title="6. put"></a>6. put</h3><h3 id="7-delete"><a href="#7-delete" class="headerlink" title="7. delete"></a>7. delete</h3><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="单机服务通过HTTP协议实现服务端接口请求调用"><a href="#单机服务通过HTTP协议实现服务端接口请求调用" class="headerlink" title="单机服务通过HTTP协议实现服务端接口请求调用"></a>单机服务通过HTTP协议实现服务端接口请求调用</h3><p>代码详见：springcloud-http-service和springcloud-http-client</p>
<h4 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h4><p>@PathVariable是spring3.0的一个新功能：接收请求路径中占位符的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请求路径：http:&#x2F;&#x2F;localhost:8080&#x2F;user&#x2F;1&#x2F;zm</span><br><span class="line">@RequestMapping(value&#x3D;”user&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;”)</span><br><span class="line"></span><br><span class="line">@PathVariable(&quot;xxx&quot;)</span><br><span class="line">通过 @PathVariable 可以将URL中占位符参数&#123;xxx&#125;绑定到处理器类的方法形参中@PathVariable(“xxx“)</span><br></pre></td></tr></table></figure>

<h3 id="集群服务通过Ribbon负载均衡算法实现服务端接口请求调用"><a href="#集群服务通过Ribbon负载均衡算法实现服务端接口请求调用" class="headerlink" title="集群服务通过Ribbon负载均衡算法实现服务端接口请求调用"></a>集群服务通过Ribbon负载均衡算法实现服务端接口请求调用</h3><p>代码详见：springcloud-ribbon-service和springcloud-ribbon-client</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>源码总体结构图</p>
<p>![](微服务架构-6-Spring-Cloud-Netflix-Ribbon/Spring Cloud Ribbon源码分析.jpg)</p>
<h2 id="RestTemplate实现负载均衡全流程解析"><a href="#RestTemplate实现负载均衡全流程解析" class="headerlink" title="RestTemplate实现负载均衡全流程解析"></a>RestTemplate实现负载均衡全流程解析</h2><p>从@LoadBalanced注解源码中可以看到，该注解是用来给RestTemplate做标记，以使用负载均衡客户端（LoadBalancerClient）来配置它。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation to mark a RestTemplate or WebClient bean to be configured to use a</span></span><br><span class="line"><span class="comment"> * LoadBalancerClient.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(&#123; ElementType.FIELD, ElementType.PARAMETER, ElementType.METHOD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Qualifier</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> LoadBalanced &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LoadBalancerClient.java</strong></p>
<p>spring-cloud-commons提供的负载均衡客户端接口，其他负载均衡组件实现该接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a client-side load balancer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancerClient</span> <span class="keyword">extends</span> <span class="title">ServiceInstanceChooser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Executes request using a ServiceInstance from the LoadBalancer for the specified</span></span><br><span class="line"><span class="comment">	 * service.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> serviceId The service ID to look up the LoadBalancer.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request Allows implementations to execute pre and post actions, such as</span></span><br><span class="line"><span class="comment">	 * incrementing metrics.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &lt;T&gt; type of the response</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException in case of IO issues.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The result of the LoadBalancerRequest callback on the selected</span></span><br><span class="line"><span class="comment">	 * ServiceInstance.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Executes request using a ServiceInstance from the LoadBalancer for the specified</span></span><br><span class="line"><span class="comment">	 * service.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> serviceId The service ID to look up the LoadBalancer.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> serviceInstance The service to execute the request to.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> request Allows implementations to execute pre and post actions, such as</span></span><br><span class="line"><span class="comment">	 * incrementing metrics.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> &lt;T&gt; type of the response</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> IOException in case of IO issues.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> The result of the LoadBalancerRequest callback on the selected</span></span><br><span class="line"><span class="comment">	 * ServiceInstance.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	&lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">			LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Creates a proper URI with a real host and port for systems to utilize. Some systems</span></span><br><span class="line"><span class="comment">	 * use a URI with the logical service name as the host, such as</span></span><br><span class="line"><span class="comment">	 * http://myservice/path/to/service. This will replace the service name with the</span></span><br><span class="line"><span class="comment">	 * host:port from the ServiceInstance.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> instance service instance to reconstruct the URI</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> original A URI with the host as a logical service name.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> A reconstructed URI.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">URI <span class="title">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>LoadBalancerAutoConfiguration.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Auto-configuration for Ribbon (client-side load balancing).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Will Tran</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Gang Li</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(RestTemplate<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnBean</span>(<span class="title">LoadBalancerClient</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(<span class="title">LoadBalancerRetryProperties</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">LoadBalancerAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注入所有被@LoadBalanced标记的RestTemplates</span></span><br><span class="line">	<span class="meta">@LoadBalanced</span></span><br><span class="line">	<span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">private</span> List&lt;LoadBalancerRequestTransformer&gt; transformers = Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置SmartInitializingSingleton，并依赖注入RestTemplateCustomizer包装类</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SmartInitializingSingleton <span class="title">loadBalancedRestTemplateInitializerDeprecated</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> () -&gt; restTemplateCustomizers.ifAvailable(customizers -&gt; &#123;</span><br><span class="line">			<span class="keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="keyword">this</span>.restTemplates) &#123;</span><br><span class="line">				<span class="keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">					customizer.customize(restTemplate);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置LoadBalancerRequestFactory，并依赖注入LoadBalancerClient。</span></span><br><span class="line">    <span class="comment">// LoadBalancerClient只是一个抽象的接口，本配置类中并未配置LoadBalancerClient具体实现，</span></span><br><span class="line">    <span class="comment">// 那么容器中一定会存在一个配置的LoadBalancerClient的bean的实现</span></span><br><span class="line">    <span class="comment">// 如使用Ribbon,则在RibbonAutoConfiguration中会配置一个实例对象为RibbonLoadBalancerClient的bean，这样，就接入到负载均衡的相关实现</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> LoadBalancerRequestFactory <span class="title">loadBalancerRequestFactory</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			LoadBalancerClient loadBalancerClient)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerRequestFactory(loadBalancerClient, <span class="keyword">this</span>.transformers);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从条件中可以看出，缺少RetryTemplate时使用该配置。即当使用RestTemplate时，该配置会生效</span></span><br><span class="line">	<span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line">	<span class="meta">@ConditionalOnMissingClass</span>(<span class="string">"org.springframework.retry.support.RetryTemplate"</span>)</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalancerInterceptorConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置拦截器LoadBalancerInterceptor</span></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> LoadBalancerInterceptor <span class="title">ribbonInterceptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">				LoadBalancerClient loadBalancerClient,</span></span></span><br><span class="line"><span class="function"><span class="params">				LoadBalancerRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置RestTemplateCustomizer包装类，为每个RestTemplate设置拦截器</span></span><br><span class="line">		<span class="meta">@Bean</span></span><br><span class="line">		<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> RestTemplateCustomizer <span class="title">restTemplateCustomizer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> restTemplate -&gt; &#123;</span><br><span class="line">				List&lt;ClientHttpRequestInterceptor&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(</span><br><span class="line">						restTemplate.getInterceptors());</span><br><span class="line">				list.add(loadBalancerInterceptor);</span><br><span class="line">                <span class="comment">// 设置拦截器，实际调用的是父类InterceptingHttpAccessor中的setInterceptors方法</span></span><br><span class="line">				restTemplate.setInterceptors(list);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RibbonAutoConfiguration.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Auto configuration for Ribbon (client side load balancing).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Biju Kunjummen</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional</span>(RibbonAutoConfiguration.RibbonClassesConditions<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">RibbonClients</span></span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span></span><br><span class="line"><span class="class">		<span class="title">name</span> </span>= <span class="string">"org.springframework.cloud.netflix.eureka.EurekaClientAutoConfiguration"</span>)</span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(&#123; LoadBalancerAutoConfiguration<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">AsyncLoadBalancerAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(</span>&#123; RibbonEagerLoadProperties<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">ServerIntrospectorProperties</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RibbonAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">	<span class="keyword">private</span> List&lt;RibbonClientSpecification&gt; configurations = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> RibbonEagerLoadProperties ribbonEagerLoadProperties;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HasFeatures <span class="title">ribbonFeature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> HasFeatures.namedFeature(<span class="string">"Ribbon"</span>, Ribbon<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置SpringClientFactory</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> SpringClientFactory <span class="title">springClientFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		SpringClientFactory factory = <span class="keyword">new</span> SpringClientFactory();</span><br><span class="line">		factory.setConfigurations(<span class="keyword">this</span>.configurations);</span><br><span class="line">		<span class="keyword">return</span> factory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置LoadBalancerClient，其实例对象为RibbonLoadBalancerClient</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(LoadBalancerClient<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">LoadBalancerClient</span> <span class="title">loadBalancerClient</span>() </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancerClient(springClientFactory());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> PropertiesFactory <span class="title">propertiesFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PropertiesFactory();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnProperty</span>(<span class="string">"ribbon.eager-load.enabled"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> RibbonApplicationContextInitializer <span class="title">ribbonApplicationContextInitializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RibbonApplicationContextInitializer(springClientFactory(),</span><br><span class="line">				ribbonEagerLoadProperties.getClients());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们看一下，RestTemplate发起的请求，是如何被拦截到的。看一下RestTemplate的类关系图</p>
<p><img src="/2021/05/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-6-Spring-Cloud-Netflix-Ribbon/RestTemplate%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt></p>
<p><strong>RestTemplate.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getForObject</span><span class="params">(String url, Class&lt;T&gt; responseType, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line">    RequestCallback requestCallback = acceptHeaderRequestCallback(responseType);</span><br><span class="line">    HttpMessageConverterExtractor&lt;T&gt; responseExtractor =</span><br><span class="line">        <span class="keyword">new</span> HttpMessageConverterExtractor&lt;&gt;(responseType, getMessageConverters(), logger);</span><br><span class="line">    <span class="keyword">return</span> execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;To provide a &#123;<span class="doctag">@code</span> RequestCallback&#125; or &#123;<span class="doctag">@code</span> ResponseExtractor&#125; only,</span></span><br><span class="line"><span class="comment"> * but not both, consider using:</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #acceptHeaderRequestCallback(Class)&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #httpEntityCallback(Object)&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #httpEntityCallback(Object, Type)&#125;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt;&#123;<span class="doctag">@link</span> #responseEntityExtractor(Type)&#125;</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String url, HttpMethod method, @Nullable RequestCallback requestCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">                     @Nullable ResponseExtractor&lt;T&gt; responseExtractor, Object... uriVariables)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">    URI expanded = getUriTemplateHandler().expand(url, uriVariables);</span><br><span class="line">    <span class="keyword">return</span> doExecute(expanded, method, requestCallback, responseExtractor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Execute the given method on the provided URI.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The &#123;<span class="doctag">@link</span> ClientHttpRequest&#125; is processed using the &#123;<span class="doctag">@link</span> RequestCallback&#125;;</span></span><br><span class="line"><span class="comment"> * the response with the &#123;<span class="doctag">@link</span> ResponseExtractor&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url the fully-expanded URL to connect to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method the HTTP method to execute (GET, POST, etc.)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> requestCallback object that prepares the request (can be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> responseExtractor object that extracts the return value from the response (can be &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an arbitrary object, as returned by the &#123;<span class="doctag">@link</span> ResponseExtractor&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doExecute</span><span class="params">(URI url, @Nullable HttpMethod method, @Nullable RequestCallback requestCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">                          @Nullable ResponseExtractor&lt;T&gt; responseExtractor)</span> <span class="keyword">throws</span> RestClientException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.notNull(url, <span class="string">"URI is required"</span>);</span><br><span class="line">    Assert.notNull(method, <span class="string">"HttpMethod is required"</span>);</span><br><span class="line">    ClientHttpResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个request</span></span><br><span class="line">        ClientHttpRequest request = createRequest(url, method);</span><br><span class="line">        <span class="keyword">if</span> (requestCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestCallback.doWithRequest(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行</span></span><br><span class="line">        response = request.execute();</span><br><span class="line">        handleResponse(url, method, response);</span><br><span class="line">        <span class="keyword">return</span> (responseExtractor != <span class="keyword">null</span> ? responseExtractor.extractData(response) : <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        String resource = url.toString();</span><br><span class="line">        String query = url.getRawQuery();</span><br><span class="line">        resource = (query != <span class="keyword">null</span> ? resource.substring(<span class="number">0</span>, resource.indexOf(<span class="string">'?'</span>)) : resource);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ResourceAccessException(<span class="string">"I/O error on "</span> + method.name() +</span><br><span class="line">                                          <span class="string">" request for \""</span> + resource + <span class="string">"\": "</span> + ex.getMessage(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (response != <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看到，在RestTemplate执行请求时，会先创建一个request，该方法是调用的HttpAccessor中的createRequest方法，</p>
<p><strong>HttpAccessor.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ClientHttpRequestFactory requestFactory = <span class="keyword">new</span> SimpleClientHttpRequestFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the request factory that this accessor uses for obtaining client request handles.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClientHttpRequestFactory <span class="title">getRequestFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.requestFactory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new &#123;<span class="doctag">@link</span> ClientHttpRequest&#125; via this template's &#123;<span class="doctag">@link</span> ClientHttpRequestFactory&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url the URL to connect to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method the HTTP method to execute (GET, POST, etc)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the created request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException in case of I/O errors</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getRequestFactory()</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ClientHttpRequestFactory#createRequest(URI, HttpMethod)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClientHttpRequest <span class="title">createRequest</span><span class="params">(URI url, HttpMethod method)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ClientHttpRequest request = getRequestFactory().createRequest(url, method);</span><br><span class="line">    initialize(request);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"HTTP "</span> + method.name() + <span class="string">" "</span> + url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> request;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用子类InterceptingHttpAccessor重写的方法getRequestFactory，并通过获得的requestFactory工厂创建一个request</p>
<p><strong>InterceptingHttpAccessor.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Overridden to expose an &#123;<span class="doctag">@link</span> InterceptingClientHttpRequestFactory&#125;</span></span><br><span class="line"><span class="comment"> * if necessary.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getInterceptors()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClientHttpRequestFactory <span class="title">getRequestFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;ClientHttpRequestInterceptor&gt; interceptors = getInterceptors();</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">        <span class="comment">// 当存在拦截器时，由此初始化工厂类InterceptingClientHttpRequestFactory</span></span><br><span class="line">        ClientHttpRequestFactory factory = <span class="keyword">this</span>.interceptingRequestFactory;</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> InterceptingClientHttpRequestFactory(<span class="keyword">super</span>.getRequestFactory(), interceptors);</span><br><span class="line">            <span class="keyword">this</span>.interceptingRequestFactory = factory;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不存在拦截器时，调用父类HttpAccessor的getRequestFactory，并初始化工厂类SimpleClientHttpRequestFactory</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getRequestFactory();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>HttpAccessor中调用的createRequest实际是通过InterceptingClientHttpRequestFactory工厂类来创建request，当存在拦截器时，走if里的逻辑，并初始化创建一个InterceptingClientHttpRequestFactory</p>
</li>
<li><p>InterceptingClientHttpRequestFactory构造方法中，会传入一个父类的getRequestFactory方法返回一个SimpleClientHttpRequestFactory并保存在其属性requestFactory中。</p>
</li>
<li><p>在createRequest时，通过new InterceptingClientHttpRequest(requestFactory, this.interceptors, uri, httpMethod)，将该requestFactory对象保存在InterceptingClientHttpRequest的requestFactory属性中。</p>
</li>
<li><p>后续回调apply时，调用requestFactory（SimpleClientHttpRequestFactory）的createRequest方法得到一个SimpleStreamingClientHttpRequest实例对象。</p>
<p>该工厂类的类图如下：</p>
</li>
</ol>
<p><img src="/2021/05/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-6-Spring-Cloud-Netflix-Ribbon/InterceptingClientHttpRequestFactory%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt></p>
<p><strong>InterceptingClientHttpRequestFactory.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClientHttpRequest <span class="title">createRequest</span><span class="params">(URI uri, HttpMethod httpMethod, ClientHttpRequestFactory requestFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InterceptingClientHttpRequest(requestFactory, <span class="keyword">this</span>.interceptors, uri, httpMethod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此便得到了一个InterceptingClientHttpRequest的实例对象。该对象的类图如下：</p>
<p><img src="/2021/05/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-6-Spring-Cloud-Netflix-Ribbon/InterceptingClientHttpRequest%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt></p>
<p>接着看RestTemplate下面的代码，会通过创建的InterceptingClientHttpRequest对象来调用其execute方法，而该类中并没有execute方法，故而实际调用的是其父类AbstractClientHttpRequest中的execute方法</p>
<p><strong>AbstractClientHttpRequest.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ClientHttpResponse <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    assertNotExecuted();</span><br><span class="line">    ClientHttpResponse result = executeInternal(<span class="keyword">this</span>.headers);</span><br><span class="line">    <span class="keyword">this</span>.executed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着调用由其子类AbstractBufferingClientHttpRequest实现的抽象方法executeInternal</p>
<p><strong>AbstractBufferingClientHttpRequest.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ClientHttpResponse <span class="title">executeInternal</span><span class="params">(HttpHeaders headers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">this</span>.bufferedOutput.toByteArray();</span><br><span class="line">    <span class="keyword">if</span> (headers.getContentLength() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        headers.setContentLength(bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line">    ClientHttpResponse result = executeInternal(headers, bytes);</span><br><span class="line">    <span class="keyword">this</span>.bufferedOutput = <span class="keyword">new</span> ByteArrayOutputStream(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，该方法中也会调用由其子类InterceptingClientHttpRequest实现的抽象方法executeInternal</p>
<p><strong>InterceptingClientHttpRequest.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrapper for a &#123;<span class="doctag">@link</span> ClientHttpRequest&#125; that has support for &#123;<span class="doctag">@link</span> ClientHttpRequestInterceptor</span></span><br><span class="line"><span class="comment"> * ClientHttpRequestInterceptors&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Arjen Poutsma</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterceptingClientHttpRequest</span> <span class="keyword">extends</span> <span class="title">AbstractBufferingClientHttpRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ClientHttpRequestFactory requestFactory;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;ClientHttpRequestInterceptor&gt; interceptors;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> HttpMethod method;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> URI uri;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="title">InterceptingClientHttpRequest</span><span class="params">(ClientHttpRequestFactory requestFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">			List&lt;ClientHttpRequestInterceptor&gt; interceptors, URI uri, HttpMethod method)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.requestFactory = requestFactory;</span><br><span class="line">		<span class="keyword">this</span>.interceptors = interceptors;</span><br><span class="line">		<span class="keyword">this</span>.method = method;</span><br><span class="line">		<span class="keyword">this</span>.uri = uri;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> HttpMethod <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.method;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMethodValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.method.name();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> URI <span class="title">getURI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.uri;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> ClientHttpResponse <span class="title">executeInternal</span><span class="params">(HttpHeaders headers, <span class="keyword">byte</span>[] bufferedOutput)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		InterceptingRequestExecution requestExecution = <span class="keyword">new</span> InterceptingRequestExecution();</span><br><span class="line">		<span class="keyword">return</span> requestExecution.execute(<span class="keyword">this</span>, bufferedOutput);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptingRequestExecution</span> <span class="keyword">implements</span> <span class="title">ClientHttpRequestExecution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Iterator&lt;ClientHttpRequestInterceptor&gt; iterator;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">InterceptingRequestExecution</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.iterator = interceptors.iterator();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">execute</span><span class="params">(HttpRequest request, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.iterator.hasNext()) &#123;</span><br><span class="line">				ClientHttpRequestInterceptor nextInterceptor = <span class="keyword">this</span>.iterator.next();</span><br><span class="line">				<span class="keyword">return</span> nextInterceptor.intercept(request, body, <span class="keyword">this</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				HttpMethod method = request.getMethod();</span><br><span class="line">				Assert.state(method != <span class="keyword">null</span>, <span class="string">"No standard HTTP method"</span>);</span><br><span class="line">				ClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);</span><br><span class="line">				request.getHeaders().forEach((key, value) -&gt; delegate.getHeaders().addAll(key, value));</span><br><span class="line">				<span class="keyword">if</span> (body.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (delegate <span class="keyword">instanceof</span> StreamingHttpOutputMessage) &#123;</span><br><span class="line">						StreamingHttpOutputMessage streamingOutputMessage = (StreamingHttpOutputMessage) delegate;</span><br><span class="line">						streamingOutputMessage.setBody(outputStream -&gt; StreamUtils.copy(body, outputStream));</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						StreamUtils.copy(body, delegate.getBody());</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span> delegate.execute();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中又调用了其内部类InterceptingRequestExecution的execute方法。execute方法中的iterator迭代器，就是RestTemplate设置的拦截器列表的迭代器。由此可见，如果存在拦截器，则会走if中的逻辑，否则走else中的逻辑。if中即调用了拦截器LoadBalancerInterceptor的intercept方法，其中第三个参数execution传的是当前类InterceptingRequestExecution的实例对象。</p>
<p><strong>LoadBalancerInterceptor.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">intercept</span><span class="params">(<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> URI originalUri = request.getURI();</span><br><span class="line">    String serviceName = originalUri.getHost();</span><br><span class="line">    Assert.state(serviceName != <span class="keyword">null</span>,</span><br><span class="line">                 <span class="string">"Request URI does not contain a valid hostname: "</span> + originalUri);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.loadBalancer.execute(serviceName,</span><br><span class="line">                                     <span class="keyword">this</span>.requestFactory.createRequest(request, body, execution));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法中通过依赖注入的LoadBalancerClient（实例对象为RibbonLoadBalancerClient）调用其execute方法。该方法中会通过依赖注入的LoadBalancerRequestFactory来创建一个request，execution仍然为上面传入过来的InterceptingRequestExecution的实例对象</p>
<p><strong>LoadBalancerRequestFactory.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> LoadBalancerRequest&lt;ClientHttpResponse&gt; <span class="title">createRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> HttpRequest request, <span class="keyword">final</span> <span class="keyword">byte</span>[] body,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> ClientHttpRequestExecution execution)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance -&gt; &#123;</span><br><span class="line">        HttpRequest serviceRequest = <span class="keyword">new</span> ServiceRequestWrapper(request, instance,</span><br><span class="line">                                                               <span class="keyword">this</span>.loadBalancer);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.transformers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (LoadBalancerRequestTransformer transformer : <span class="keyword">this</span>.transformers) &#123;</span><br><span class="line">                serviceRequest = transformer.transformRequest(serviceRequest,</span><br><span class="line">                                                              instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> execution.execute(serviceRequest, body);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法返回的是一个lambda表达式，实质是返回函数式接口LoadBalancerRequest，lambda表达式即为该函数式接口的apply方法。</p>
<p><strong>LoadBalancerRequest.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple interface used by LoadBalancerClient to apply metrics or pre and post actions</span></span><br><span class="line"><span class="comment"> * around load balancer requests.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; type of the response</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Spencer Gibb</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoadBalancerRequest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">apply</span><span class="params">(ServiceInstance instance)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然从上面的自动装配类中获知，LoadBalancerClient的实例对象为RibbonLoadBalancerClient，那么接下来看看RibbonLoadBalancerClient中的execute方法</p>
<p><strong>RibbonLoadBalancerClient.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> execute(serviceId, request, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * New: Execute a request by selecting server using a 'key'. The hint will have to be</span></span><br><span class="line"><span class="comment"> * the last parameter to not mess with the `execute(serviceId, ServiceInstance,</span></span><br><span class="line"><span class="comment"> * request)` method. This somewhat breaks the fluent coding style when using a lambda</span></span><br><span class="line"><span class="comment"> * to define the LoadBalancerRequest.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; returned request execution result type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serviceId id of the service to execute the request to</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request to be executed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hint used to choose appropriate &#123;<span class="doctag">@link</span> Server&#125; instance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> request execution result</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IOException executing the request may result in an &#123;<span class="doctag">@link</span> IOException&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, LoadBalancerRequest&lt;T&gt; request, Object hint)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 1.获取一个ILoadBalancer实例对象</span></span><br><span class="line">    ILoadBalancer loadBalancer = getLoadBalancer(serviceId);</span><br><span class="line">    <span class="comment">// 2.通过负载均衡选择一个目标服务</span></span><br><span class="line">    Server server = getServer(loadBalancer, hint);</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.将获取到的server包装成RibbonServer</span></span><br><span class="line">    RibbonServer ribbonServer = <span class="keyword">new</span> RibbonServer(serviceId, server,</span><br><span class="line">                                                 isSecure(server, serviceId),</span><br><span class="line">                                                 serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line">	<span class="comment">// 4.调用execute，其中通过request.apply调用传入的request的回调方法。</span></span><br><span class="line">    <span class="keyword">return</span> execute(serviceId, ribbonServer, request);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ILoadBalancer <span class="title">getLoadBalancer</span><span class="params">(String serviceId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.clientFactory.getLoadBalancer(serviceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(String serviceId, ServiceInstance serviceInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">                     LoadBalancerRequest&lt;T&gt; request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (serviceInstance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">        server = ((RibbonServer) serviceInstance).getServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No instances available for "</span> + serviceId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">        .getLoadBalancerContext(serviceId);</span><br><span class="line">    RibbonStatsRecorder statsRecorder = <span class="keyword">new</span> RibbonStatsRecorder(context, server);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 5.通过intercept中传入的request调用其apply方法（lambda表达式）</span></span><br><span class="line">        T returnVal = request.apply(serviceInstance);</span><br><span class="line">        statsRecorder.recordStats(returnVal);</span><br><span class="line">        <span class="keyword">return</span> returnVal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// catch IOException and rethrow so RestTemplate behaves correctly</span></span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        statsRecorder.recordStats(ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        statsRecorder.recordStats(ex);</span><br><span class="line">        ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Server <span class="title">getServer</span><span class="params">(ILoadBalancer loadBalancer, Object hint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (loadBalancer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Use 'default' on a null hint, or just pass it on?</span></span><br><span class="line">    <span class="keyword">return</span> loadBalancer.chooseServer(hint != <span class="keyword">null</span> ? hint : <span class="string">"default"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码中可以看到，</p>
<ol>
<li>第一步：调用getLoadBalancer获取一个负载均衡器，getLoadBalancer方法是通过SpringClientFactory中的通用方法来初始化创建一个ILoadBalancer接口指向的实例对象，该对象是通过RibbonClientConfiguration中注入到Spring容器中，即为ZoneAwareLoadBalancer的实例对象，通过该对象来实现负载均衡器。</li>
<li>第二步：调用getServer获取一个通过负载均衡策略分配到的一个目标服务实例对象Server。getServer中实际调用的是ZoneAwareLoadBalancer中的chooseServer方法，ZoneAwareLoadBalancer通过RibbonClientConfiguration配置类配置bean。</li>
<li>第三步：将获取到的server包装成RibbonServer。该对象除了存储了服务实例的信息之外，还增加了服务名serviceId、是否需要使用HTTPS的信息。</li>
<li>第四步：调用execute，其中通过request.apply调用传入的request的回调方法。这个request的实例对象，就是intercept方法中第一个参数创建的一个函数式接口LoadBalancerRequest的对象，调用的就是这个接口对象的apply方法（lambda表达式）。</li>
<li>第五步：apply方法中，调用传入的execution的execute方法，即上面的InterceptingRequestExecution的execute方法中，由于此时迭代器迭代拦截器已经完成了，所以走的是else中的逻辑，调用SimpleStreamingClientHttpRequest的execute方法，并向一个实际的具体服务实例发起请求，从而实现一开始以服务名为host的URI请求到host:port形式的实际访问地址的转换。</li>
</ol>
<p>再来单独看一下回调的apply方法中，所调用的execution中的execute方法</p>
<p><strong>InterceptingRequestExecution.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ClientHttpResponse <span class="title">execute</span><span class="params">(HttpRequest request, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.iterator.hasNext()) &#123;</span><br><span class="line">        ClientHttpRequestInterceptor nextInterceptor = <span class="keyword">this</span>.iterator.next();</span><br><span class="line">        <span class="keyword">return</span> nextInterceptor.intercept(request, body, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        HttpMethod method = request.getMethod();</span><br><span class="line">        Assert.state(method != <span class="keyword">null</span>, <span class="string">"No standard HTTP method"</span>);</span><br><span class="line">        ClientHttpRequest delegate = requestFactory.createRequest(request.getURI(), method);</span><br><span class="line">        request.getHeaders().forEach((key, value) -&gt; delegate.getHeaders().addAll(key, value));</span><br><span class="line">        <span class="keyword">if</span> (body.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (delegate <span class="keyword">instanceof</span> StreamingHttpOutputMessage) &#123;</span><br><span class="line">                StreamingHttpOutputMessage streamingOutputMessage = (StreamingHttpOutputMessage) delegate;</span><br><span class="line">                streamingOutputMessage.setBody(outputStream -&gt; StreamUtils.copy(body, outputStream));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                StreamUtils.copy(body, delegate.getBody());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> delegate.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意requestFactory.createRequest创建的request对象与参数中的request对象的区别：</p>
<ol>
<li>此处的requestFactory为上面提到的初始化InterceptingClientHttpRequest时所保存的requestFactory（SimpleClientHttpRequestFactory），并由其创建得到的SimpleStreamingClientHttpRequest。</li>
<li>参数中的request为apply方法中初始化并包装InterceptingClientHttpRequest所得到的ServiceRequestWrapper。</li>
</ol>
<p>那么，看一下request.getURI方法，此方法中</p>
<p><strong>ServiceRequestWrapper.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Ryan Baxter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRequestWrapper</span> <span class="keyword">extends</span> <span class="title">HttpRequestWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ServiceInstance instance;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> LoadBalancerClient loadBalancer;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ServiceRequestWrapper</span><span class="params">(HttpRequest request, ServiceInstance instance,</span></span></span><br><span class="line"><span class="function"><span class="params">			LoadBalancerClient loadBalancer)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(request);</span><br><span class="line">		<span class="keyword">this</span>.instance = instance;</span><br><span class="line">		<span class="keyword">this</span>.loadBalancer = loadBalancer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> URI <span class="title">getURI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		URI uri = <span class="keyword">this</span>.loadBalancer.reconstructURI(<span class="keyword">this</span>.instance, getRequest().getURI());</span><br><span class="line">		<span class="keyword">return</span> uri;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用loadBalancer（实际为RibbonLoadBalancerClient对象）的reconstructURI方法来重组uri，看一下该方法</p>
<p><strong>RibbonLoadBalancerClient.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">reconstructURI</span><span class="params">(ServiceInstance instance, URI original)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(instance, <span class="string">"instance can not be null"</span>);</span><br><span class="line">    String serviceId = instance.getServiceId();</span><br><span class="line">    RibbonLoadBalancerContext context = <span class="keyword">this</span>.clientFactory</span><br><span class="line">        .getLoadBalancerContext(serviceId);</span><br><span class="line"></span><br><span class="line">    URI uri;</span><br><span class="line">    Server server;</span><br><span class="line">    <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> RibbonServer) &#123;</span><br><span class="line">        RibbonServer ribbonServer = (RibbonServer) instance;</span><br><span class="line">        server = ribbonServer.getServer();</span><br><span class="line">        uri = updateToSecureConnectionIfNeeded(original, ribbonServer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        server = <span class="keyword">new</span> Server(instance.getScheme(), instance.getHost(),</span><br><span class="line">                            instance.getPort());</span><br><span class="line">        IClientConfig clientConfig = clientFactory.getClientConfig(serviceId);</span><br><span class="line">        ServerIntrospector serverIntrospector = serverIntrospector(serviceId);</span><br><span class="line">        uri = updateToSecureConnectionIfNeeded(original, clientConfig,</span><br><span class="line">                                               serverIntrospector, server);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context.reconstructURIWithServer(server, uri);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>根据ServiceInstance实例对象的serviceId，从SpringClientFactory类的clientFactory对象中获取对应的负载均衡器上下文RibbonLoadBalancerContext对象。</li>
<li>根据ServiceInstance中的信息来构建具体服务实例信息的Server对象，并使用RibbonLoadBalancerContext对象的reconstructURIWithServer来构建服务实例的URI。</li>
</ol>
<p><strong>LoadBalancerContext.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URI <span class="title">reconstructURIWithServer</span><span class="params">(Server server, URI original)</span> </span>&#123;</span><br><span class="line">    String host = server.getHost();</span><br><span class="line">    <span class="keyword">int</span> port = server.getPort();</span><br><span class="line">    String scheme = server.getScheme();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (host.equals(original.getHost()) </span><br><span class="line">        &amp;&amp; port == original.getPort()</span><br><span class="line">        &amp;&amp; scheme == original.getScheme()) &#123;</span><br><span class="line">        <span class="keyword">return</span> original;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (scheme == <span class="keyword">null</span>) &#123;</span><br><span class="line">        scheme = original.getScheme();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (scheme == <span class="keyword">null</span>) &#123;</span><br><span class="line">        scheme = deriveSchemeAndPortFromPartialUri(original).first();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.append(scheme).append(<span class="string">"://"</span>);</span><br><span class="line">        <span class="keyword">if</span> (!Strings.isNullOrEmpty(original.getRawUserInfo())) &#123;</span><br><span class="line">            sb.append(original.getRawUserInfo()).append(<span class="string">"@"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(host);</span><br><span class="line">        <span class="keyword">if</span> (port &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">":"</span>).append(port);</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(original.getRawPath());</span><br><span class="line">        <span class="keyword">if</span> (!Strings.isNullOrEmpty(original.getRawQuery())) &#123;</span><br><span class="line">            sb.append(<span class="string">"?"</span>).append(original.getRawQuery());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!Strings.isNullOrEmpty(original.getRawFragment())) &#123;</span><br><span class="line">            sb.append(<span class="string">"#"</span>).append(original.getRawFragment());</span><br><span class="line">        &#125;</span><br><span class="line">        URI newURI = <span class="keyword">new</span> URI(sb.toString());</span><br><span class="line">        <span class="keyword">return</span> newURI;            </span><br><span class="line">    &#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="负载均衡器"><a href="#负载均衡器" class="headerlink" title="负载均衡器"></a>负载均衡器</h2><p>通过查看配置类RibbonClientConfiguration，配置的ILoadBalancer实例对象为ZoneAwareLoadBalancer。所以，上面RibbonLoadBalancerClient中的getServer方法，所调用的loadBalancer.chooseServer(hint != null ? hint : “default”);其实就是调用的ZoneAwareLoadBalancer负载均衡器中的chooseServer方法。</p>
<p><strong>RibbonClientConfiguration.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Tim Ysewyn</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="comment">// Order is important here, last should be the default, first should be optional</span></span><br><span class="line"><span class="comment">// see</span></span><br><span class="line"><span class="comment">// https://github.com/spring-cloud/spring-cloud-netflix/issues/2086#issuecomment-316281653</span></span><br><span class="line"><span class="meta">@Import</span>(&#123; HttpClientConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">OkHttpRibbonConfiguration</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">RestClientRibbonConfiguration</span>.<span class="title">class</span>, <span class="title">HttpClientRibbonConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">RibbonClientConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Ribbon client default connect timeout.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONNECT_TIMEOUT = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Ribbon client default read timeout.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_READ_TIMEOUT = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Ribbon client default Gzip Payload flag.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEFAULT_GZIP_PAYLOAD = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RibbonClientName</span></span><br><span class="line">	<span class="keyword">private</span> String name = <span class="string">"client"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">TODO:</span> maybe re-instate autowired load balancers: identified by name they could be</span></span><br><span class="line">	<span class="comment">// associated with ribbon clients</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> PropertiesFactory propertiesFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置IClientConfig，包含默认的配置，如连接读取超时时间和解压缩</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IClientConfig <span class="title">ribbonClientConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		DefaultClientConfigImpl config = <span class="keyword">new</span> DefaultClientConfigImpl();</span><br><span class="line">		config.loadProperties(<span class="keyword">this</span>.name);</span><br><span class="line">		config.set(CommonClientConfigKey.ConnectTimeout, DEFAULT_CONNECT_TIMEOUT);</span><br><span class="line">		config.set(CommonClientConfigKey.ReadTimeout, DEFAULT_READ_TIMEOUT);</span><br><span class="line">		config.set(CommonClientConfigKey.GZipPayload, DEFAULT_GZIP_PAYLOAD);</span><br><span class="line">		<span class="keyword">return</span> config;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置IRule</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IRule <span class="title">ribbonRule</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IRule<span class="class">.<span class="keyword">class</span>, <span class="title">name</span>)) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IRule<span class="class">.<span class="keyword">class</span>, <span class="title">config</span>, <span class="title">name</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ZoneAvoidanceRule rule = <span class="keyword">new</span> ZoneAvoidanceRule();</span><br><span class="line">		rule.initWithNiwsConfig(config);</span><br><span class="line">		<span class="keyword">return</span> rule;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置IPing</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> IPing <span class="title">ribbonPing</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(IPing<span class="class">.<span class="keyword">class</span>, <span class="title">name</span>)) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(IPing<span class="class">.<span class="keyword">class</span>, <span class="title">config</span>, <span class="title">name</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DummyPing();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ServerList&lt;Server&gt; <span class="title">ribbonServerList</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ServerList<span class="class">.<span class="keyword">class</span>, <span class="title">name</span>)) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ServerList<span class="class">.<span class="keyword">class</span>, <span class="title">config</span>, <span class="title">name</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ConfigurationBasedServerList serverList = <span class="keyword">new</span> ConfigurationBasedServerList();</span><br><span class="line">		serverList.initWithNiwsConfig(config);</span><br><span class="line">		<span class="keyword">return</span> serverList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ServerListUpdater <span class="title">ribbonServerListUpdater</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PollingServerListUpdater(config);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置ILoadBalancer，其具体实例为ZoneAwareLoadBalancer的实例对象</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ILoadBalancer <span class="title">ribbonLoadBalancer</span><span class="params">(IClientConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">			ServerList&lt;Server&gt; serverList, ServerListFilter&lt;Server&gt; serverListFilter,</span></span></span><br><span class="line"><span class="function"><span class="params">			IRule rule, IPing ping, ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ILoadBalancer<span class="class">.<span class="keyword">class</span>, <span class="title">name</span>)) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ILoadBalancer<span class="class">.<span class="keyword">class</span>, <span class="title">config</span>, <span class="title">name</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ZoneAwareLoadBalancer&lt;&gt;(config, rule, ping, serverList,</span><br><span class="line">				serverListFilter, serverListUpdater);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ServerListFilter&lt;Server&gt; <span class="title">ribbonServerListFilter</span><span class="params">(IClientConfig config)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.propertiesFactory.isSet(ServerListFilter<span class="class">.<span class="keyword">class</span>, <span class="title">name</span>)) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.propertiesFactory.get(ServerListFilter<span class="class">.<span class="keyword">class</span>, <span class="title">config</span>, <span class="title">name</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ZonePreferenceServerListFilter filter = <span class="keyword">new</span> ZonePreferenceServerListFilter();</span><br><span class="line">		filter.initWithNiwsConfig(config);</span><br><span class="line">		<span class="keyword">return</span> filter;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置负载均衡器的上下文RibbonLoadBalancerContext</span></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> RibbonLoadBalancerContext <span class="title">ribbonLoadBalancerContext</span><span class="params">(ILoadBalancer loadBalancer,</span></span></span><br><span class="line"><span class="function"><span class="params">			IClientConfig config, RetryHandler retryHandler)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> RibbonLoadBalancerContext(loadBalancer, config, retryHandler);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ZoneAwareLoadBalancer类关系图如下：</p>
<p><img src="/2021/05/08/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-6-Spring-Cloud-Netflix-Ribbon/ZoneAwareLoadBalancer%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt></p>
<p><strong>ZoneAwareLoadBalancer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZoneAwareLoadBalancer</span><span class="params">(IClientConfig clientConfig, IRule rule,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 IPing ping, ServerList&lt;T&gt; serverList, ServerListFilter&lt;T&gt; filter,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(clientConfig, rule, ping, serverList, filter, serverListUpdater);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">chooseServer</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ENABLED.get() || getLoadBalancerStats().getAvailableZones().size() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Zone aware logic disabled or there is only one zone"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.chooseServer(key);</span><br><span class="line">    &#125;</span><br><span class="line">    Server server = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        LoadBalancerStats lbStats = getLoadBalancerStats();</span><br><span class="line">        Map&lt;String, ZoneSnapshot&gt; zoneSnapshot = ZoneAvoidanceRule.createSnapshot(lbStats);</span><br><span class="line">        logger.debug(<span class="string">"Zone snapshots: &#123;&#125;"</span>, zoneSnapshot);</span><br><span class="line">        <span class="keyword">if</span> (triggeringLoad == <span class="keyword">null</span>) &#123;</span><br><span class="line">            triggeringLoad = DynamicPropertyFactory.getInstance().getDoubleProperty(</span><br><span class="line">                <span class="string">"ZoneAwareNIWSDiscoveryLoadBalancer."</span> + <span class="keyword">this</span>.getName() + <span class="string">".triggeringLoadPerServerThreshold"</span>, <span class="number">0.2</span>d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (triggeringBlackoutPercentage == <span class="keyword">null</span>) &#123;</span><br><span class="line">            triggeringBlackoutPercentage = DynamicPropertyFactory.getInstance().getDoubleProperty(</span><br><span class="line">                <span class="string">"ZoneAwareNIWSDiscoveryLoadBalancer."</span> + <span class="keyword">this</span>.getName() + <span class="string">".avoidZoneWithBlackoutPercetage"</span>, <span class="number">0.99999</span>d);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;String&gt; availableZones = ZoneAvoidanceRule.getAvailableZones(zoneSnapshot, triggeringLoad.get(), triggeringBlackoutPercentage.get());</span><br><span class="line">        logger.debug(<span class="string">"Available zones: &#123;&#125;"</span>, availableZones);</span><br><span class="line">        <span class="keyword">if</span> (availableZones != <span class="keyword">null</span> &amp;&amp;  availableZones.size() &lt; zoneSnapshot.keySet().size()) &#123;</span><br><span class="line">            String zone = ZoneAvoidanceRule.randomChooseZone(zoneSnapshot, availableZones);</span><br><span class="line">            logger.debug(<span class="string">"Zone chosen: &#123;&#125;"</span>, zone);</span><br><span class="line">            <span class="keyword">if</span> (zone != <span class="keyword">null</span>) &#123;</span><br><span class="line">                BaseLoadBalancer zoneLoadBalancer = getLoadBalancer(zone);</span><br><span class="line">                server = zoneLoadBalancer.chooseServer(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(<span class="string">"Error choosing server using zone aware logic for load balancer=&#123;&#125;"</span>, name, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (server != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> server;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.debug(<span class="string">"Zone avoidance logic is not invoked."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.chooseServer(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在初始化ZoneAwareLoadBalancer实例对象时，会初始化父类DynamicServerListLoadBalancer的有参构造方法</p>
<p><strong>DynamicServerListLoadBalancer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化定义一个ServerListUpdater.UpdateAction，并实现其接口方法doUpdate()</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ServerListUpdater.UpdateAction updateAction = <span class="keyword">new</span> ServerListUpdater.UpdateAction() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        updateListOfServers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数，初始化相关属性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DynamicServerListLoadBalancer</span><span class="params">(IClientConfig clientConfig, IRule rule, IPing ping,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         ServerList&lt;T&gt; serverList, ServerListFilter&lt;T&gt; filter,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         ServerListUpdater serverListUpdater)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(clientConfig, rule, ping);</span><br><span class="line">    <span class="keyword">this</span>.serverListImpl = serverList;</span><br><span class="line">    <span class="keyword">this</span>.filter = filter;</span><br><span class="line">    <span class="keyword">this</span>.serverListUpdater = serverListUpdater;</span><br><span class="line">    <span class="keyword">if</span> (filter <span class="keyword">instanceof</span> AbstractServerListFilter) &#123;</span><br><span class="line">        ((AbstractServerListFilter) filter).setLoadBalancerStats(getLoadBalancerStats());</span><br><span class="line">    &#125;</span><br><span class="line">    restOfInit(clientConfig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restOfInit</span><span class="params">(IClientConfig clientConfig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> primeConnection = <span class="keyword">this</span>.isEnablePrimingConnections();</span><br><span class="line">    <span class="comment">// turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span></span><br><span class="line">    <span class="keyword">this</span>.setEnablePrimingConnections(<span class="keyword">false</span>);</span><br><span class="line">    enableAndInitLearnNewServersFeature();</span><br><span class="line"></span><br><span class="line">    updateListOfServers();</span><br><span class="line">    <span class="keyword">if</span> (primeConnection &amp;&amp; <span class="keyword">this</span>.getPrimeConnections() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.getPrimeConnections()</span><br><span class="line">            .primeConnections(getReachableServers());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.setEnablePrimingConnections(primeConnection);</span><br><span class="line">    LOGGER.info(<span class="string">"DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;"</span>, clientConfig.getClientName(), <span class="keyword">this</span>.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Feature that lets us add new instances (from AMIs) to the list of</span></span><br><span class="line"><span class="comment"> * existing servers that the LB will use Call this method if you want this</span></span><br><span class="line"><span class="comment"> * feature enabled</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enableAndInitLearnNewServersFeature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LOGGER.info(<span class="string">"Using serverListUpdater &#123;&#125;"</span>, serverListUpdater.getClass().getSimpleName());</span><br><span class="line">    serverListUpdater.start(updateAction);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateListOfServers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;T&gt; servers = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="keyword">if</span> (serverListImpl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        servers = serverListImpl.getUpdatedListOfServers();</span><br><span class="line">        LOGGER.debug(<span class="string">"List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">                     getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            servers = filter.getFilteredListOfServers(servers);</span><br><span class="line">            LOGGER.debug(<span class="string">"Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;"</span>,</span><br><span class="line">                         getIdentifier(), servers);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    updateAllServerList(servers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>PollingServerListUpdater.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">final</span> UpdateAction updateAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isActive.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Runnable wrapperRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!isActive.get()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (scheduledFuture != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        scheduledFuture.cancel(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    updateAction.doUpdate();</span><br><span class="line">                    lastUpdated = System.currentTimeMillis();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Failed one update cycle"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        scheduledFuture = getRefreshExecutor().scheduleWithFixedDelay(</span><br><span class="line">            wrapperRunnable,</span><br><span class="line">            initialDelayMs,</span><br><span class="line">            refreshIntervalMs,</span><br><span class="line">            TimeUnit.MILLISECONDS</span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.info(<span class="string">"Already active, no-op"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>定时获取服务实例列表，并缓存到本地内存中</li>
<li>对服务实例列表进行过滤</li>
</ol>
<p><strong>BaseLoadBalancer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Monitor</span>(name = PREFIX + <span class="string">"AllServerList"</span>, type = DataSourceType.INFORMATIONAL)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; allServerList = Collections</span><br><span class="line">    .synchronizedList(<span class="keyword">new</span> ArrayList&lt;Server&gt;());</span><br><span class="line"><span class="meta">@Monitor</span>(name = PREFIX + <span class="string">"UpServerList"</span>, type = DataSourceType.INFORMATIONAL)</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> List&lt;Server&gt; upServerList = Collections</span><br><span class="line">    .synchronizedList(<span class="keyword">new</span> ArrayList&lt;Server&gt;());</span><br></pre></td></tr></table></figure>

<ol>
<li>定义并维护两个存储服务实例Server的对象列表。一个用于存储所有服务实例的清单，一个用于存储正常服务的实例清单。</li>
</ol>
<h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2>]]></content>
      <categories>
        <category>微服务架构</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构-8-Spring-Cloud-Netflix-Eureka</title>
    <url>/2021/07/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-7-Spring-Cloud-Netflix-Eureka/</url>
    <content><![CDATA[<h1 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h1><p>Consistency：一致性，所有节点在同一时间的数据完全一致</p>
<p>Availability：可用性，服务一直可用，而且是正常响应时间</p>
<p>Partition tolerance：分区容错性，在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务</p>
<p><img src="/2021/07/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-7-Spring-Cloud-Netflix-Eureka/CAP.jpeg" alt></p>
<p>CAP理论指的是一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p>
<p>（1）满足CA舍弃P，也就是满足一致性和可用性，舍弃容错性。但是这也就意味着你的系统不是分布式的了，因为涉及分布式的想法就是把功能分开，部署到不同的机器上。</p>
<p>（2）满足CP舍弃A，也就是满足一致性和容错性，舍弃可用性。如果你的系统允许有段时间的访问失效等问题，这个是可以满足的。就好比多个人并发买票，后台网络出现故障，你买的时候系统就崩溃了。</p>
<p>（3）满足AP舍弃C，也就是满足可用性和容错性，舍弃一致性。这也就是意味着你的系统在并发访问的时候可能会出现数据不一致的情况。</p>
<p>实时证明，大多数都是牺牲了一致性。像12306还有淘宝网，就好比是你买火车票，本来你看到的是还有一张票，其实在这个时刻已经被买走了，你填好了信息准备买的时候发现系统提示你没票了。这就是牺牲了一致性。</p>
<p>但是不是说牺牲一致性一定是最好的。就好比mysql中的事务机制，张三给李四转了100块钱，这时候必须保证张三的账户上少了100，李四的账户多了100。因此需要数据的一致性，而且什么时候转钱都可以，也需要可用性。但是可以转钱失败是可以允许的。</p>
<h1 id="SmartLifecycle"><a href="#SmartLifecycle" class="headerlink" title="SmartLifecycle"></a>SmartLifecycle</h1><p>在使用Spring开发时，所有bean都交给Spring容器来统一管理，其中包括每一个bean的加载和初始化。 有时候我们需要在Spring加载和初始化所有bean后，接着执行一些任务或者业务逻辑。这时SmartLifecycle接口就派上用场了。<strong>SmartLifecycle 是一个接口。当Spring容器加载所有bean并完成初始化之后，会接着回调实现该接口的类中对应的方法（start()方法）</strong>。源码如下</p>
<p>SmartLifecycle.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartLifecycle</span> <span class="keyword">extends</span> <span class="title">Lifecycle</span>, <span class="title">Phased</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The default phase for &#123;<span class="doctag">@code</span> SmartLifecycle&#125;: &#123;<span class="doctag">@code</span> Integer.MAX_VALUE&#125;.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This is different from the common phase &#123;<span class="doctag">@code</span> 0&#125; associated with regular</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> Lifecycle&#125; implementations, putting the typically auto-started</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> SmartLifecycle&#125; beans into a later startup phase and an earlier</span></span><br><span class="line"><span class="comment">	 * shutdown phase.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@since</span> 5.1</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getPhase()</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.context.support.DefaultLifecycleProcessor#getPhase(Lifecycle)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">int</span> DEFAULT_PHASE = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Returns &#123;<span class="doctag">@code</span> true&#125; if this &#123;<span class="doctag">@code</span> Lifecycle&#125; component should get</span></span><br><span class="line"><span class="comment">	 * started automatically by the container at the time that the containing</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> ApplicationContext&#125; gets refreshed.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;A value of &#123;<span class="doctag">@code</span> false&#125; indicates that the component is intended to</span></span><br><span class="line"><span class="comment">	 * be started through an explicit &#123;<span class="doctag">@link</span> #start()&#125; call instead, analogous</span></span><br><span class="line"><span class="comment">	 * to a plain &#123;<span class="doctag">@link</span> Lifecycle&#125; implementation.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation returns &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #start()</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getPhase()</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> LifecycleProcessor#onRefresh()</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> ConfigurableApplicationContext#refresh()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Indicates that a Lifecycle component must stop if it is currently running.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The provided callback is used by the &#123;<span class="doctag">@link</span> LifecycleProcessor&#125; to support</span></span><br><span class="line"><span class="comment">	 * an ordered, and potentially concurrent, shutdown of all components having a</span></span><br><span class="line"><span class="comment">	 * common shutdown order value. The callback &lt;b&gt;must&lt;/b&gt; be executed after</span></span><br><span class="line"><span class="comment">	 * the &#123;<span class="doctag">@code</span> SmartLifecycle&#125; component does indeed stop.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The &#123;<span class="doctag">@link</span> LifecycleProcessor&#125; will call &lt;i&gt;only&lt;/i&gt; this variant of the</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> stop&#125; method; i.e. &#123;<span class="doctag">@link</span> Lifecycle#stop()&#125; will not be called for</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@code</span> SmartLifecycle&#125; implementations unless explicitly delegated to within</span></span><br><span class="line"><span class="comment">	 * the implementation of this method.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation delegates to &#123;<span class="doctag">@link</span> #stop()&#125; and immediately</span></span><br><span class="line"><span class="comment">	 * triggers the given callback in the calling thread. Note that there is no</span></span><br><span class="line"><span class="comment">	 * synchronization between the two, so custom implementations may at least</span></span><br><span class="line"><span class="comment">	 * want to put the same steps within their common lifecycle monitor (if any).</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #stop()</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #getPhase()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">		stop();</span><br><span class="line">		callback.run();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Return the phase that this lifecycle object is supposed to run in.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;The default implementation returns &#123;<span class="doctag">@link</span> #DEFAULT_PHASE&#125; in order to</span></span><br><span class="line"><span class="comment">	 * let &#123;<span class="doctag">@code</span> stop()&#125; callbacks execute after regular &#123;<span class="doctag">@code</span> Lifecycle&#125;</span></span><br><span class="line"><span class="comment">	 * implementations.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #isAutoStartup()</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #start()</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> #stop(Runnable)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.context.support.DefaultLifecycleProcessor#getPhase(Lifecycle)</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> DEFAULT_PHASE;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父类Lifecycle.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Start this component.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Should not throw an exception if the component is already running.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;In the case of a container, this will propagate the start signal to all</span></span><br><span class="line"><span class="comment">	 * components that apply.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> SmartLifecycle#isAutoStartup()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Stop this component, typically in a synchronous fashion, such that the component is</span></span><br><span class="line"><span class="comment">	 * fully stopped upon return of this method. Consider implementing &#123;<span class="doctag">@link</span> SmartLifecycle&#125;</span></span><br><span class="line"><span class="comment">	 * and its &#123;<span class="doctag">@code</span> stop(Runnable)&#125; variant when asynchronous stop behavior is necessary.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Note that this stop notification is not guaranteed to come before destruction:</span></span><br><span class="line"><span class="comment">	 * On regular shutdown, &#123;<span class="doctag">@code</span> Lifecycle&#125; beans will first receive a stop notification</span></span><br><span class="line"><span class="comment">	 * before the general destruction callbacks are being propagated; however, on hot</span></span><br><span class="line"><span class="comment">	 * refresh during a context's lifetime or on aborted refresh attempts, a given bean's</span></span><br><span class="line"><span class="comment">	 * destroy method will be called without any consideration of stop signals upfront.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;Should not throw an exception if the component is not running (not started yet).</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;In the case of a container, this will propagate the stop signal to all components</span></span><br><span class="line"><span class="comment">	 * that apply.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> SmartLifecycle#stop(Runnable)</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.DisposableBean#destroy()</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Check whether this component is currently running.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;In the case of a container, this will return &#123;<span class="doctag">@code</span> true&#125; only if &lt;i&gt;all&lt;/i&gt;</span></span><br><span class="line"><span class="comment">	 * components that apply are currently running.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> whether the component is currently running</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例：在一个Spring项目中实现SmartLifecycle</strong></p>
<p>TestSmartLifecycle.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSmartLifecycle</span> <span class="keyword">implements</span> <span class="title">SmartLifecycle</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----Start-----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"-----Stop-----"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="/2021/07/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-7-Spring-Cloud-Netflix-Eureka/TestSmartLifecycle%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C.jpg" alt></p>
<p>接下来我们来看该接口在Eureka里的实现</p>
<p>spring-cloud-netflix-eureka-server:EurekaServerInitializerConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServerInitializerConfiguration</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ServletContextAware</span>, <span class="title">SmartLifecycle</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory</span><br><span class="line">			.getLog(EurekaServerInitializerConfiguration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> EurekaServerConfig eurekaServerConfig;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ServletContext servletContext;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> EurekaServerBootstrap eurekaServerBootstrap;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> running;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> order = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServletContext</span><span class="params">(ServletContext servletContext)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.servletContext = servletContext;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// <span class="doctag">TODO:</span> is this class even needed now?</span></span><br><span class="line">				eurekaServerBootstrap.contextInitialized(</span><br><span class="line">						EurekaServerInitializerConfiguration.<span class="keyword">this</span>.servletContext);</span><br><span class="line">				log.info(<span class="string">"Started Eureka Server"</span>);</span><br><span class="line"></span><br><span class="line">				publish(<span class="keyword">new</span> EurekaRegistryAvailableEvent(getEurekaServerConfig()));</span><br><span class="line">				EurekaServerInitializerConfiguration.<span class="keyword">this</span>.running = <span class="keyword">true</span>;</span><br><span class="line">				publish(<span class="keyword">new</span> EurekaServerStartedEvent(getEurekaServerConfig()));</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">				<span class="comment">// Help!</span></span><br><span class="line">				log.error(<span class="string">"Could not initialize Eureka servlet context"</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> EurekaServerConfig <span class="title">getEurekaServerConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.eurekaServerConfig;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.applicationContext.publishEvent(event);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.running = <span class="keyword">false</span>;</span><br><span class="line">		eurekaServerBootstrap.contextDestroyed(<span class="keyword">this</span>.servletContext);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.running;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">		callback.run();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.order;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>spring-cloud-netflix-eureka-client: EurekaAutoServiceRegistration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaAutoServiceRegistration</span> <span class="keyword">implements</span> <span class="title">AutoServiceRegistration</span>,</span></span><br><span class="line"><span class="class">		<span class="title">SmartLifecycle</span>, <span class="title">Ordered</span>, <span class="title">SmartApplicationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(EurekaAutoServiceRegistration<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> AtomicBoolean running = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> order = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> AtomicInteger port = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> EurekaServiceRegistry serviceRegistry;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> EurekaRegistration registration;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EurekaAutoServiceRegistration</span><span class="params">(ApplicationContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">			EurekaServiceRegistry serviceRegistry, EurekaRegistration registration)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.context = context;</span><br><span class="line">		<span class="keyword">this</span>.serviceRegistry = serviceRegistry;</span><br><span class="line">		<span class="keyword">this</span>.registration = registration;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// only set the port if the nonSecurePort or securePort is 0 and this.port != 0</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.port.get() != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.registration.getNonSecurePort() == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">this</span>.registration.setNonSecurePort(<span class="keyword">this</span>.port.get());</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.registration.getSecurePort() == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.registration.isSecure()) &#123;</span><br><span class="line">				<span class="keyword">this</span>.registration.setSecurePort(<span class="keyword">this</span>.port.get());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// only initialize if nonSecurePort is greater than 0 and it isn't already running</span></span><br><span class="line">		<span class="comment">// because of containerPortInitializer below</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.running.get() &amp;&amp; <span class="keyword">this</span>.registration.getNonSecurePort() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>.serviceRegistry.register(<span class="keyword">this</span>.registration);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">this</span>.context.publishEvent(<span class="keyword">new</span> InstanceRegisteredEvent&lt;&gt;(<span class="keyword">this</span>,</span><br><span class="line">					<span class="keyword">this</span>.registration.getInstanceConfig()));</span><br><span class="line">			<span class="keyword">this</span>.running.set(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.serviceRegistry.deregister(<span class="keyword">this</span>.registration);</span><br><span class="line">		<span class="keyword">this</span>.running.set(<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRunning</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.running.get();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPhase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAutoStartup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">		stop();</span><br><span class="line">		callback.run();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.order;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsEventType</span><span class="params">(Class&lt;? extends ApplicationEvent&gt; eventType)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> WebServerInitializedEvent<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">eventType</span>)</span></span><br><span class="line"><span class="class">				|| <span class="title">ContextClosedEvent</span>.<span class="title">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">eventType</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event <span class="keyword">instanceof</span> WebServerInitializedEvent) &#123;</span><br><span class="line">			onApplicationEvent((WebServerInitializedEvent) event);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ContextClosedEvent) &#123;</span><br><span class="line">			onApplicationEvent((ContextClosedEvent) event);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(WebServerInitializedEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// <span class="doctag">TODO:</span> take SSL into account</span></span><br><span class="line">		String contextName = event.getApplicationContext().getServerNamespace();</span><br><span class="line">		<span class="keyword">if</span> (contextName == <span class="keyword">null</span> || !contextName.equals(<span class="string">"management"</span>)) &#123;</span><br><span class="line">			<span class="keyword">int</span> localPort = event.getWebServer().getPort();</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.port.get() == <span class="number">0</span>) &#123;</span><br><span class="line">				log.info(<span class="string">"Updating port to "</span> + localPort);</span><br><span class="line">				<span class="keyword">this</span>.port.compareAndSet(<span class="number">0</span>, localPort);</span><br><span class="line">				start();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextClosedEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.getApplicationContext() == context) &#123;</span><br><span class="line">			stop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Spring-Cloud-Eureka"><a href="#Spring-Cloud-Eureka" class="headerlink" title="Spring Cloud Eureka"></a>Spring Cloud Eureka</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol>
<li>服务的上下线感知</li>
<li>服务的维护问题</li>
</ol>
<h2 id="服务的注册（Register）"><a href="#服务的注册（Register）" class="headerlink" title="服务的注册（Register）"></a>服务的注册（Register）</h2><h3 id="Eureka-Server接收注册请求"><a href="#Eureka-Server接收注册请求" class="headerlink" title="Eureka Server接收注册请求"></a>Eureka Server接收注册请求</h3><ul>
<li><strong>Eureka Server如何接收请求</strong></li>
<li><strong>Eureka Server如何存储服务地址</strong></li>
</ul>
<p><strong>Eureka Core提供基于jersey的RESTFUL请求实现服务的注册</strong></p>
<p>applicationResource.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &lt;em&gt;jersey&lt;/em&gt; resource that handles request related to a particular</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> com.netflix.discovery.shared.Application&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Karthik Ranganathan, Greg Kim</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/xml"</span>, <span class="string">"application/json"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ApplicationResource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String appName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaServerConfig serverConfig;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResponseCache responseCache;</span><br><span class="line"></span><br><span class="line">    ApplicationResource(String appName,</span><br><span class="line">                        EurekaServerConfig serverConfig,</span><br><span class="line">                        PeerAwareInstanceRegistry registry) &#123;</span><br><span class="line">        <span class="keyword">this</span>.appName = appName.toUpperCase();</span><br><span class="line">        <span class="keyword">this</span>.serverConfig = serverConfig;</span><br><span class="line">        <span class="keyword">this</span>.registry = registry;</span><br><span class="line">        <span class="keyword">this</span>.responseCache = registry.getResponseCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAppName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets information about a particular &#123;<span class="doctag">@link</span> com.netflix.discovery.shared.Application&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version</span></span><br><span class="line"><span class="comment">     *            the version of the request.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acceptHeader</span></span><br><span class="line"><span class="comment">     *            the accept header of the request to indicate whether to serve</span></span><br><span class="line"><span class="comment">     *            JSON or XML data.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the response containing information about a particular</span></span><br><span class="line"><span class="comment">     *         application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">getApplication</span><span class="params">(@PathParam(<span class="string">"version"</span>)</span> String version,</span></span><br><span class="line"><span class="function">                                   @<span class="title">HeaderParam</span><span class="params">(<span class="string">"Accept"</span>)</span> <span class="keyword">final</span> String acceptHeader,</span></span><br><span class="line"><span class="function">                                   @<span class="title">HeaderParam</span><span class="params">(EurekaAccept.HTTP_X_EUREKA_ACCEPT)</span> String eurekaAccept) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!registry.shouldAllowAccess(<span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(Status.FORBIDDEN).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        EurekaMonitors.GET_APPLICATION.increment();</span><br><span class="line"></span><br><span class="line">        CurrentRequestVersion.set(Version.toEnum(version));</span><br><span class="line">        KeyType keyType = Key.KeyType.JSON;</span><br><span class="line">        <span class="keyword">if</span> (acceptHeader == <span class="keyword">null</span> || !acceptHeader.contains(<span class="string">"json"</span>)) &#123;</span><br><span class="line">            keyType = Key.KeyType.XML;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Key cacheKey = <span class="keyword">new</span> Key(</span><br><span class="line">                Key.EntityType.Application,</span><br><span class="line">                appName,</span><br><span class="line">                keyType,</span><br><span class="line">                CurrentRequestVersion.get(),</span><br><span class="line">                EurekaAccept.fromString(eurekaAccept)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        String payLoad = responseCache.get(cacheKey);</span><br><span class="line">        CurrentRequestVersion.remove();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (payLoad != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Found: &#123;&#125;"</span>, appName);</span><br><span class="line">            <span class="keyword">return</span> Response.ok(payLoad).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">"Not Found: &#123;&#125;"</span>, appName);</span><br><span class="line">            <span class="keyword">return</span> Response.status(Status.NOT_FOUND).build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets information about a particular instance of an application.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     *            the unique identifier of the instance.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> information about a particular instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Path</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InstanceResource <span class="title">getInstanceInfo</span><span class="params">(@PathParam(<span class="string">"id"</span>)</span> String id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InstanceResource(<span class="keyword">this</span>, id, serverConfig, registry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Registers information about a particular instance for an</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> com.netflix.discovery.shared.Application&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> info</span></span><br><span class="line"><span class="comment">     *            &#123;<span class="doctag">@link</span> InstanceInfo&#125; information of the instance.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isReplication</span></span><br><span class="line"><span class="comment">     *            a header parameter containing information whether this is</span></span><br><span class="line"><span class="comment">     *            replicated from other nodes.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@POST</span></span><br><span class="line">    <span class="meta">@Consumes</span>(&#123;<span class="string">"application/json"</span>, <span class="string">"application/xml"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">addInstance</span><span class="params">(InstanceInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                @HeaderParam(PeerEurekaNode.HEADER_REPLICATION)</span> String isReplication) </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"Registering instance &#123;&#125; (replication=&#123;&#125;)"</span>, info.getId(), isReplication);</span><br><span class="line">        <span class="comment">// validate that the instanceinfo contains all the necessary required fields</span></span><br><span class="line">        <span class="keyword">if</span> (isBlank(info.getId())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing instanceId"</span>).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getHostName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing hostname"</span>).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getIPAddr())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing ip address"</span>).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBlank(info.getAppName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing appName"</span>).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!appName.equals(info.getAppName())) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Mismatched appName, expecting "</span> + appName + <span class="string">" but was "</span> + info.getAppName()).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info.getDataCenterInfo() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing dataCenterInfo"</span>).build();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info.getDataCenterInfo().getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(<span class="string">"Missing dataCenterInfo Name"</span>).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// handle cases where clients may be registering with bad DataCenterInfo with missing data</span></span><br><span class="line">        DataCenterInfo dataCenterInfo = info.getDataCenterInfo();</span><br><span class="line">        <span class="keyword">if</span> (dataCenterInfo <span class="keyword">instanceof</span> UniqueIdentifier) &#123;</span><br><span class="line">            String dataCenterInfoId = ((UniqueIdentifier) dataCenterInfo).getId();</span><br><span class="line">            <span class="keyword">if</span> (isBlank(dataCenterInfoId)) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> experimental = <span class="string">"true"</span>.equalsIgnoreCase(serverConfig.getExperimental(<span class="string">"registration.validation.dataCenterInfoId"</span>));</span><br><span class="line">                <span class="keyword">if</span> (experimental) &#123;</span><br><span class="line">                    String entity = <span class="string">"DataCenterInfo of type "</span> + dataCenterInfo.getClass() + <span class="string">" must contain a valid id"</span>;</span><br><span class="line">                    <span class="keyword">return</span> Response.status(<span class="number">400</span>).entity(entity).build();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dataCenterInfo <span class="keyword">instanceof</span> AmazonInfo) &#123;</span><br><span class="line">                    AmazonInfo amazonInfo = (AmazonInfo) dataCenterInfo;</span><br><span class="line">                    String effectiveId = amazonInfo.get(AmazonInfo.MetaDataKey.instanceId);</span><br><span class="line">                    <span class="keyword">if</span> (effectiveId == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        amazonInfo.getMetadata().put(AmazonInfo.MetaDataKey.instanceId.getName(), info.getId());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Registering DataCenterInfo of type &#123;&#125; without an appropriate id"</span>, dataCenterInfo.getClass());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        registry.register(info, <span class="string">"true"</span>.equals(isReplication));</span><br><span class="line">        <span class="keyword">return</span> Response.status(<span class="number">204</span>).build();  <span class="comment">// 204 to be backwards compatible</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the application name of a particular application.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the application name of a particular application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> appName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isBlank</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str == <span class="keyword">null</span> || str.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>applicationsResource.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A &lt;em&gt;jersey&lt;/em&gt; resource that handles request related to all</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> com.netflix.discovery.shared.Applications&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Karthik Ranganathan, Greg Kim</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Path</span>(<span class="string">"/&#123;version&#125;/apps"</span>)</span><br><span class="line"><span class="meta">@Produces</span>(&#123;<span class="string">"application/xml"</span>, <span class="string">"application/json"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationsResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADER_ACCEPT = <span class="string">"Accept"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADER_ACCEPT_ENCODING = <span class="string">"Accept-Encoding"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADER_CONTENT_ENCODING = <span class="string">"Content-Encoding"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADER_CONTENT_TYPE = <span class="string">"Content-Type"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADER_GZIP_VALUE = <span class="string">"gzip"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HEADER_JSON_VALUE = <span class="string">"json"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EurekaServerConfig serverConfig;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PeerAwareInstanceRegistry registry;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResponseCache responseCache;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    ApplicationsResource(EurekaServerContext eurekaServer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.serverConfig = eurekaServer.getServerConfig();</span><br><span class="line">        <span class="keyword">this</span>.registry = eurekaServer.getRegistry();</span><br><span class="line">        <span class="keyword">this</span>.responseCache = registry.getResponseCache();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationsResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(EurekaServerContextHolder.getInstance().getServerContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets information about a particular &#123;<span class="doctag">@link</span> com.netflix.discovery.shared.Application&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version</span></span><br><span class="line"><span class="comment">     *            the version of the request.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> appId</span></span><br><span class="line"><span class="comment">     *            the unique application identifier (which is the name) of the</span></span><br><span class="line"><span class="comment">     *            application.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> information about a particular application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Path</span>(<span class="string">"&#123;appId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationResource <span class="title">getApplicationResource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @PathParam(<span class="string">"version"</span>)</span> String version,</span></span><br><span class="line"><span class="function">            @<span class="title">PathParam</span><span class="params">(<span class="string">"appId"</span>)</span> String appId) </span>&#123;</span><br><span class="line">        CurrentRequestVersion.set(Version.toEnum(version));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ApplicationResource(appId, serverConfig, registry);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            CurrentRequestVersion.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get information about all &#123;<span class="doctag">@link</span> com.netflix.discovery.shared.Applications&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version the version of the request.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acceptHeader the accept header to indicate whether to serve JSON or XML data.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acceptEncoding the accept header to indicate whether to serve compressed or uncompressed data.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eurekaAccept an eureka accept extension, see &#123;<span class="doctag">@link</span> com.netflix.appinfo.EurekaAccept&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriInfo the &#123;<span class="doctag">@link</span> java.net.URI&#125; information of the request made.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> regionsStr A comma separated list of remote regions from which the instances will also be returned.</span></span><br><span class="line"><span class="comment">     *                   The applications returned from the remote region can be limited to the applications</span></span><br><span class="line"><span class="comment">     *                   returned by &#123;<span class="doctag">@link</span> EurekaServerConfig#getRemoteRegionAppWhitelist(String)&#125;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a response containing information about all &#123;<span class="doctag">@link</span> com.netflix.discovery.shared.Applications&#125;</span></span><br><span class="line"><span class="comment">     *         from the &#123;<span class="doctag">@link</span> AbstractInstanceRegistry&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">getContainers</span><span class="params">(@PathParam(<span class="string">"version"</span>)</span> String version,</span></span><br><span class="line"><span class="function">                                  @<span class="title">HeaderParam</span><span class="params">(HEADER_ACCEPT)</span> String acceptHeader,</span></span><br><span class="line"><span class="function">                                  @<span class="title">HeaderParam</span><span class="params">(HEADER_ACCEPT_ENCODING)</span> String acceptEncoding,</span></span><br><span class="line"><span class="function">                                  @<span class="title">HeaderParam</span><span class="params">(EurekaAccept.HTTP_X_EUREKA_ACCEPT)</span> String eurekaAccept,</span></span><br><span class="line"><span class="function">                                  @Context UriInfo uriInfo,</span></span><br><span class="line"><span class="function">                                  @Nullable @<span class="title">QueryParam</span><span class="params">(<span class="string">"regions"</span>)</span> String regionsStr) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isRemoteRegionRequested = <span class="keyword">null</span> != regionsStr &amp;&amp; !regionsStr.isEmpty();</span><br><span class="line">        String[] regions = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isRemoteRegionRequested) &#123;</span><br><span class="line">            EurekaMonitors.GET_ALL.increment();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            regions = regionsStr.toLowerCase().split(<span class="string">","</span>);</span><br><span class="line">            Arrays.sort(regions); <span class="comment">// So we don't have different caches for same regions queried in different order.</span></span><br><span class="line">            EurekaMonitors.GET_ALL_WITH_REMOTE_REGIONS.increment();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if the server allows the access to the registry. The server can</span></span><br><span class="line">        <span class="comment">// restrict access if it is not</span></span><br><span class="line">        <span class="comment">// ready to serve traffic depending on various reasons.</span></span><br><span class="line">        <span class="keyword">if</span> (!registry.shouldAllowAccess(isRemoteRegionRequested)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(Status.FORBIDDEN).build();</span><br><span class="line">        &#125;</span><br><span class="line">        CurrentRequestVersion.set(Version.toEnum(version));</span><br><span class="line">        KeyType keyType = Key.KeyType.JSON;</span><br><span class="line">        String returnMediaType = MediaType.APPLICATION_JSON;</span><br><span class="line">        <span class="keyword">if</span> (acceptHeader == <span class="keyword">null</span> || !acceptHeader.contains(HEADER_JSON_VALUE)) &#123;</span><br><span class="line">            keyType = Key.KeyType.XML;</span><br><span class="line">            returnMediaType = MediaType.APPLICATION_XML;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Key cacheKey = <span class="keyword">new</span> Key(Key.EntityType.Application,</span><br><span class="line">                ResponseCacheImpl.ALL_APPS,</span><br><span class="line">                keyType, CurrentRequestVersion.get(), EurekaAccept.fromString(eurekaAccept), regions</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        Response response;</span><br><span class="line">        <span class="keyword">if</span> (acceptEncoding != <span class="keyword">null</span> &amp;&amp; acceptEncoding.contains(HEADER_GZIP_VALUE)) &#123;</span><br><span class="line">            response = Response.ok(responseCache.getGZIP(cacheKey))</span><br><span class="line">                    .header(HEADER_CONTENT_ENCODING, HEADER_GZIP_VALUE)</span><br><span class="line">                    .header(HEADER_CONTENT_TYPE, returnMediaType)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response = Response.ok(responseCache.get(cacheKey))</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        CurrentRequestVersion.remove();</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Get information about all delta changes in &#123;<span class="doctag">@link</span> com.netflix.discovery.shared.Applications&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The delta changes represent the registry information change for a period</span></span><br><span class="line"><span class="comment">     * as configured by</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> EurekaServerConfig#getRetentionTimeInMSInDeltaQueue()&#125;. The</span></span><br><span class="line"><span class="comment">     * changes that can happen in a registry include</span></span><br><span class="line"><span class="comment">     * &lt;em&gt;Registrations,Cancels,Status Changes and Expirations&lt;/em&gt;. Normally</span></span><br><span class="line"><span class="comment">     * the changes to the registry are infrequent and hence getting just the</span></span><br><span class="line"><span class="comment">     * delta will be much more efficient than getting the complete registry.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Since the delta information is cached over a period of time, the requests</span></span><br><span class="line"><span class="comment">     * may return the same data multiple times within the window configured by</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> EurekaServerConfig#getRetentionTimeInMSInDeltaQueue()&#125;.The clients</span></span><br><span class="line"><span class="comment">     * are expected to handle this duplicate information.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> version the version of the request.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acceptHeader the accept header to indicate whether to serve  JSON or XML data.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> acceptEncoding the accept header to indicate whether to serve compressed or uncompressed data.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> eurekaAccept an eureka accept extension, see &#123;<span class="doctag">@link</span> com.netflix.appinfo.EurekaAccept&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> uriInfo  the &#123;<span class="doctag">@link</span> java.net.URI&#125; information of the request made.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> response containing the delta information of the</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@link</span> AbstractInstanceRegistry&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Path</span>(<span class="string">"delta"</span>)</span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">getContainerDifferential</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @PathParam(<span class="string">"version"</span>)</span> String version,</span></span><br><span class="line"><span class="function">            @<span class="title">HeaderParam</span><span class="params">(HEADER_ACCEPT)</span> String acceptHeader,</span></span><br><span class="line"><span class="function">            @<span class="title">HeaderParam</span><span class="params">(HEADER_ACCEPT_ENCODING)</span> String acceptEncoding,</span></span><br><span class="line"><span class="function">            @<span class="title">HeaderParam</span><span class="params">(EurekaAccept.HTTP_X_EUREKA_ACCEPT)</span> String eurekaAccept,</span></span><br><span class="line"><span class="function">            @Context UriInfo uriInfo, @Nullable @<span class="title">QueryParam</span><span class="params">(<span class="string">"regions"</span>)</span> String regionsStr) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> isRemoteRegionRequested = <span class="keyword">null</span> != regionsStr &amp;&amp; !regionsStr.isEmpty();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the delta flag is disabled in discovery or if the lease expiration</span></span><br><span class="line">        <span class="comment">// has been disabled, redirect clients to get all instances</span></span><br><span class="line">        <span class="keyword">if</span> ((serverConfig.shouldDisableDelta()) || (!registry.shouldAllowAccess(isRemoteRegionRequested))) &#123;</span><br><span class="line">            <span class="keyword">return</span> Response.status(Status.FORBIDDEN).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] regions = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!isRemoteRegionRequested) &#123;</span><br><span class="line">            EurekaMonitors.GET_ALL_DELTA.increment();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            regions = regionsStr.toLowerCase().split(<span class="string">","</span>);</span><br><span class="line">            Arrays.sort(regions); <span class="comment">// So we don't have different caches for same regions queried in different order.</span></span><br><span class="line">            EurekaMonitors.GET_ALL_DELTA_WITH_REMOTE_REGIONS.increment();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CurrentRequestVersion.set(Version.toEnum(version));</span><br><span class="line">        KeyType keyType = Key.KeyType.JSON;</span><br><span class="line">        String returnMediaType = MediaType.APPLICATION_JSON;</span><br><span class="line">        <span class="keyword">if</span> (acceptHeader == <span class="keyword">null</span> || !acceptHeader.contains(HEADER_JSON_VALUE)) &#123;</span><br><span class="line">            keyType = Key.KeyType.XML;</span><br><span class="line">            returnMediaType = MediaType.APPLICATION_XML;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Key cacheKey = <span class="keyword">new</span> Key(Key.EntityType.Application,</span><br><span class="line">                ResponseCacheImpl.ALL_APPS_DELTA,</span><br><span class="line">                keyType, CurrentRequestVersion.get(), EurekaAccept.fromString(eurekaAccept), regions</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Response response;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (acceptEncoding != <span class="keyword">null</span> &amp;&amp; acceptEncoding.contains(HEADER_GZIP_VALUE)) &#123;</span><br><span class="line">             response = Response.ok(responseCache.getGZIP(cacheKey))</span><br><span class="line">                    .header(HEADER_CONTENT_ENCODING, HEADER_GZIP_VALUE)</span><br><span class="line">                    .header(HEADER_CONTENT_TYPE, returnMediaType)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            response = Response.ok(responseCache.get(cacheKey)).build();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        CurrentRequestVersion.remove();</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Eureka-Client注册服务"><a href="#Eureka-Client注册服务" class="headerlink" title="Eureka Client注册服务"></a>Eureka Client注册服务</h3><ol>
<li><p>Eureka Client注册服务，通过实现spring-cloud-commons包的ServiceRegistry统一接口来实现服务的注册，实现类为EurekaServiceRegistry.java，如下为EurekaServiceRegistry的类关系图以及相关源码。</p>
<p>spring-cloud-commons包定义的服务注册接口ServiceRegistry类关系图</p>
<p><img src="/2021/07/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-7-Spring-Cloud-Netflix-Eureka/ServiceRegistry%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt></p>
<p>EurekaServiceRegistry.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServiceRegistry</span> <span class="keyword">implements</span> <span class="title">ServiceRegistry</span>&lt;<span class="title">EurekaRegistration</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(EurekaServiceRegistry<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EurekaRegistration reg)</span> </span>&#123;</span><br><span class="line">		maybeInitializeClient(reg);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (log.isInfoEnabled()) &#123;</span><br><span class="line">			log.info(<span class="string">"Registering application "</span></span><br><span class="line">					+ reg.getApplicationInfoManager().getInfo().getAppName()</span><br><span class="line">					+ <span class="string">" with eureka with status "</span></span><br><span class="line">					+ reg.getInstanceConfig().getInitialStatus());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		reg.getApplicationInfoManager()</span><br><span class="line">				.setInstanceStatus(reg.getInstanceConfig().getInitialStatus());</span><br><span class="line"></span><br><span class="line">		reg.getHealthCheckHandler().ifAvailable(healthCheckHandler -&gt; reg</span><br><span class="line">				.getEurekaClient().registerHealthCheck(healthCheckHandler));</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>EurekaAutoServiceRegistration.java实现SmartLifecycle接口，并在start方法中调用了EurekaServiceRegistry的注册方法register，最终完成服务初始化注册。这两个类均有EurekaClientAutoConfiguration.java自动装配初始化bean</p>
<p>EurekaClientAutoConfiguration.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(EurekaClientConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnProperty</span>(<span class="title">value</span> </span>= <span class="string">"eureka.client.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@ConditionalOnDiscoveryEnabled</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(&#123; NoopDiscoveryClientAutoConfiguration<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">CommonsClientAutoConfiguration</span>.<span class="title">class</span>, <span class="title">ServiceRegistryAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(<span class="title">name</span> </span>= &#123;</span><br><span class="line">		<span class="string">"org.springframework.cloud.netflix.eureka.config.DiscoveryClientOptionalArgsConfiguration"</span>,</span><br><span class="line">		<span class="string">"org.springframework.cloud.autoconfigure.RefreshAutoConfiguration"</span>,</span><br><span class="line">		<span class="string">"org.springframework.cloud.netflix.eureka.EurekaDiscoveryClientConfiguration"</span>,</span><br><span class="line">		<span class="string">"org.springframework.cloud.client.serviceregistry.AutoServiceRegistrationAutoConfiguration"</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientAutoConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ConfigurableEnvironment env;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EurekaClientAutoConfiguration</span><span class="params">(ConfigurableEnvironment env)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.env = env;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> EurekaServiceRegistry <span class="title">eurekaServiceRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> EurekaServiceRegistry();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnBean</span>(AutoServiceRegistrationProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	@<span class="title">ConditionalOnProperty</span>(</span></span><br><span class="line"><span class="class">			<span class="title">value</span> </span>= <span class="string">"spring.cloud.service-registry.auto-registration.enabled"</span>,</span><br><span class="line">			matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> EurekaAutoServiceRegistration <span class="title">eurekaAutoServiceRegistration</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ApplicationContext context, EurekaServiceRegistry registry,</span></span></span><br><span class="line"><span class="function"><span class="params">			EurekaRegistration registration)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> EurekaAutoServiceRegistration(context, registry, registration);</span><br><span class="line">	&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h2 id="服务的查询-发现（Get-Registry）"><a href="#服务的查询-发现（Get-Registry）" class="headerlink" title="服务的查询/发现（Get Registry）"></a>服务的查询/发现（Get Registry）</h2><h2 id="服务的续约-Renew"><a href="#服务的续约-Renew" class="headerlink" title="服务的续约(Renew)"></a>服务的续约(Renew)</h2><p><strong>心跳失败</strong>的比例在15分钟之内，低于85%的节点，Eureka Server会认为这个实例出现网络故障，直接剔除这个有问题的服务。</p>
<p>减少网络抖动或者网络不稳定的情况下，避免误删除。那么这个服务不会被剔除。</p>
<ul>
<li>Eureka Server不会剔除因为长时间没有收到心跳数据的过期服务。</li>
<li>Eureka Server仍然能接收新的服务的注册与查询。</li>
</ul>
<p>AbstractInstanceRegistry.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">int</span> numberOfRenewsPerMinThreshold; <span class="comment">// 每分钟最小续约数量</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">int</span> expectedNumberOfClientsSendingRenews; <span class="comment">// 预期每分钟收到续约的客户端数量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 以服务注册中心注册了5个服务实例为例：</span></span><br><span class="line"><span class="comment"> * expectedNumberOfClientsSendingRenews = 5</span></span><br><span class="line"><span class="comment"> * getExpectedClientRenewalIntervalSeconds 默认为30S，即每分钟发送两个心跳数据包</span></span><br><span class="line"><span class="comment"> * getRenewalPercentThreshold 默认为85%，即心跳失败比例达到85%</span></span><br><span class="line"><span class="comment"> * numberOfRenewsPerMinThreshold = 5 * （60.0 / 30.0） * 85% = 取整（8.5） = 8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">updateRenewsPerMinThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.numberOfRenewsPerMinThreshold = (<span class="keyword">int</span>) (<span class="keyword">this</span>.expectedNumberOfClientsSendingRenews</span><br><span class="line">                                                * (<span class="number">60.0</span> / serverConfig.getExpectedClientRenewalIntervalSeconds())</span><br><span class="line">                                                * serverConfig.getRenewalPercentThreshold());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>微服务架构</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件-1-RabbitMQ</title>
    <url>/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/</url>
    <content><![CDATA[<h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="一、消息与消息队列"><a href="#一、消息与消息队列" class="headerlink" title="一、消息与消息队列"></a>一、消息与消息队列</h2><p>消息（Message）是指在应用间传送的数据。消息可以非常简单，比如只包含文本字符串，也可以更复杂，可能包含嵌入对象。<br>消息队列（Message Queue）是一种应用间的通信方式，消息发送后可以立即返回，由消息系统来确保消息的可靠传递。消息发布者只管把消息发布到MQ中而不用管谁来取，消息使用者只管从MQ中取消息而不管是谁发布的。这样发布者和使用者都不用知道对方的存在。</p>
<h2 id="二、消息队列应用场景"><a href="#二、消息队列应用场景" class="headerlink" title="二、消息队列应用场景"></a>二、消息队列应用场景</h2><p>从上面的描述中可以看出消息队列是一种应用间的异步协作机制，那什么时候需要使用MQ呢？<br>以常见的订单系统为例，用户点击【下单】按钮之后的业务逻辑可能包括：扣减库存、生成相应单据、发红包、发短信通知。在业务发展初期这些逻辑可能放在一起同步执行，随着业务的发展订单量增长，需要提升系统服务的性能，这时可以将一些不需要立即生效的操作拆分出来异步执行，比如发放红包、发短信通知等。这种场景下就可以用MQ，在下单的主流程（比如扣减库存、生成相应单据）完成之后<br>发送一条消息到MQ让主流程快速完结，而由另外的单独线程拉取MQ的消息（或者由MQ推送消息），当发现MQ中有发红包或发短信之类的消息时，执行相应的业务逻辑。<br>以上是用于业务解耦的情况，其它常见场景包括最终一致性、广播、错峰流控等等。即异步、削峰、解耦。</p>
<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。</p>
<h2 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h2><p>AMQP：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。<br>RabbitMQ最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：</p>
<ol>
<li>可靠性（Reliability）<br>RabbitMQ使用一些机制来保证可靠性，如持久化、传输确认、发布确认。</li>
<li>灵活的路由（Flexible Routing）<br>在消息进入队列之前，通过Exchange来路由消息的。对于典型的路由功能，RabbitMQ已经提供了一些内置的Exchange来实现。针对更复杂的路由功能，可以将多个Exchange绑定在一起，也通过插件机制实现自己的Exchange。</li>
<li>消息集群（Clustering）<br>多个RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li>
<li>高可用（Highly Available Queues）<br>队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。</li>
<li>多种协议（Multi-protocol）<br>RabbitMQ支持多种消息队列协议，比如STOMP、MQTT等等。</li>
<li>多语言客户端（Many Clients）<br>RabbitMQ几乎支持所有常用语言，比如Java、.NET、Ruby等等。</li>
<li>管理界面（Management UI）<br>RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息Broker的许多方面。</li>
<li>跟踪机制（Tracing）<br>如果消息异常，RabbitMQ提供了消息跟踪机制，使用者可以找出发生了什么。</li>
<li>插件机制（Plugin System）<br>RabbitMQ提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。</li>
</ol>
<h2 id="三、单节点安装和使用"><a href="#三、单节点安装和使用" class="headerlink" title="三、单节点安装和使用"></a>三、单节点安装和使用</h2><h3 id="1-安装依赖环境"><a href="#1-安装依赖环境" class="headerlink" title="1.安装依赖环境"></a>1.安装依赖环境</h3><ol>
<li><p>在 <a href="http://www.rabbitmq.com/which-erlang.html" target="_blank" rel="noopener">http://www.rabbitmq.com/which-erlang.html</a> 页面查看安装rabbitmq需要安装erlang对应的版本</p>
</li>
<li><p>在 <a href="https://github.com/rabbitmq/erlang-rpm/releases" target="_blank" rel="noopener">https://github.com/rabbitmq/erlang-rpm/releases</a> 页面找到需要下载的erlang版本，erlang-*.centos.x86_64.rpm就是centos版本的。其中el7,el8,el9标识系统版本要求，EL是Red Hat Enterprise Linux（EL）的缩写，EL7是Red Hat 7.x,CentOS7.x，EL8是Red Hat8.x,CentOS8.x。所以当我们使用centos7的时候应该使用包含el7的包，不能使用其它的。但在centos8中有时可以使用el7的包，一般不推荐这样做。</p>
</li>
<li><p>复制下载地址后，使用wget命令下载</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -P /home/download https://github.com/rabbitmq/erlang-</span><br><span class="line">rpm/releases/download/v23.3.3/erlang-23.3.3-1.el7.x86_64.rpm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装Erlang</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rpm -Uvh /home/download/erlang-21.2.3-1.el7.centos.x86_64.rpm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装socat</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y socat</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-安装RabbitMQ"><a href="#2-安装RabbitMQ" class="headerlink" title="2.安装RabbitMQ"></a>2.安装RabbitMQ</h3><ol>
<li><p>在官方下载页面找到CentOS7版本的下载链接，下载rpm安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget -P /home/download https://github.com/rabbitmq/rabbitmq-</span><br><span class="line">server/releases/download/v3.8.15/rabbitmq-server-3.8.15-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装RabbitMQ</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rpm -Uvh /home/download/rabbitmq-server-3.7.9-1.el7.noarch.rpm</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="3-启动和关闭"><a href="#3-启动和关闭" class="headerlink" title="3.启动和关闭"></a>3.启动和关闭</h3><ul>
<li><p>启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start rabbitmq-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status rabbitmq-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop rabbitmq-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable rabbitmq-server</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="4-开启Web管理插件"><a href="#4-开启Web管理插件" class="headerlink" title="4.开启Web管理插件"></a>4.开启Web管理插件</h3><ol>
<li><p>开启插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>

<blockquote>
<p>说明：rabbitmq有一个默认的guest用户，但只能通过localhost访问，所以需要添加一个能够远程访问的用户。</p>
</blockquote>
</li>
<li><p>添加用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl add_user admin admin</span><br></pre></td></tr></table></figure>
</li>
<li><p>为用户分配操作权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator</span><br></pre></td></tr></table></figure>
</li>
<li><p>为用户分配资源权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"</span><br></pre></td></tr></table></figure>
</li>
<li><p>其他用户操作相关命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看当前用户列表</span></span><br><span class="line">rabbitmqctl list_users</span><br><span class="line"><span class="meta">#</span><span class="bash">删除一个用户</span></span><br><span class="line">rabbitmqctl delete_user Username</span><br><span class="line"><span class="meta">#</span><span class="bash">修改用户密码</span></span><br><span class="line">rabbitmqctl change_password Username Newpassword</span><br></pre></td></tr></table></figure>
</li>
<li><p>rabbitmqctl命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 表示stop在rabbitmq服务器上运行得一个Erlang节点，可以指定一个pid_file，表示会等待这个指定的程序结束</span></span><br><span class="line">rabbitmqctl stop &#123;pid_file&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示终止rabbitmq服务器上的Erlang进程，如果终止失败，会返回非零数字</span></span><br><span class="line">rabbitmqctl shutdown</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示终止rabbitmq的应用，但是erlang节点还在运行。该命令典型的运行在一些需要rabbitmq应用被停止的管理行为之前，例如reset</span></span><br><span class="line">rabbitmqctl -n nodeName stop_app</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示启动rabbitmq的应用。该命令典型的运行在一些需要rabbitmq应用被停止的管理行为之后，例如reset</span></span><br><span class="line">rabbitmqctl -n nodeName start_app</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示设置rabbitmq节点为原始状态。会从该节点所属的cluster中都删除，从管理数据库中删除所有数据，例如配置的用户和vhost，还会删除所有的持久消息。要想reset和force_reset操作执行成功，rabbitmq应用需要处于停止状态，即执行过stop_app</span></span><br><span class="line">rabbitmqctl -n nodeName reset</span><br><span class="line"><span class="meta">#</span><span class="bash"> 表示强制性的设置rabbitmq节点为原始状态，与reset的区别在于，可以忽略目前管理数据库的状态和cluster的配置，无条件的reset</span></span><br><span class="line">rabbitmqctl -n nodeName force_reset</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="5-防火墙添加端口"><a href="#5-防火墙添加端口" class="headerlink" title="5.防火墙添加端口"></a>5.防火墙添加端口</h3><p>RabbitMQ 服务启动后，还不能进行外部通信，需要将端口添加都防火墙</p>
<ol>
<li><p>添加端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --zone=public --add-port=4369/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=5672/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=25672/tcp --permanent</span><br><span class="line">sudo firewall-cmd --zone=public --add-port=15672/tcp --permanent</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="6-卸载"><a href="#6-卸载" class="headerlink" title="6.卸载"></a>6.卸载</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 卸载erlang</span></span><br><span class="line">yum list | grep erlang</span><br><span class="line">yum -y remove erlang-*</span><br><span class="line">rm -rf /usr/lib64/erlang</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载RabbitMQ</span></span><br><span class="line">yum list | grep rabbitmq</span><br><span class="line">yum -y remove rabbitmq-server.noarch</span><br><span class="line">find / -name rabbit*</span><br><span class="line">rm -rf 依次删除</span><br></pre></td></tr></table></figure>

<h2 id="四、RabbitMQ基本配置"><a href="#四、RabbitMQ基本配置" class="headerlink" title="四、RabbitMQ基本配置"></a>四、RabbitMQ基本配置</h2><p>RabbitMQ有一套默认的配置，能够满足日常开发需求，如果需要修改，需要自己创建一个配置文件touch/etc/rabbitmq/rabbitmq.conf<br>配置文件示例：<br><a href="https://github.com/rabbitmq/rabbitmq-server/blob/master/deps/rabbit/docs/rabbitmq.conf.example" target="_blank" rel="noopener">https://github.com/rabbitmq/rabbitmq-server/blob/master/deps/rabbit/docs/rabbitmq.conf.example</a><br>配置项说明：<br><a href="https://www.rabbitmq.com/configure.html#config-items" target="_blank" rel="noopener">https://www.rabbitmq.com/configure.html#config-items</a></p>
<p>RabbitMQ会绑定一些端口，安装完后，需要将这些端口添加至防火墙。</p>
<ul>
<li>4369：是Erlang的端口/结点名称映射程序，用来跟踪节点名称监听地址，在集群中起到一个类似DNS的作用。</li>
<li>5672, 5671：AMQP 0-9-1 和 1.0 客户端端口，没有使用SSL和使用SSL的端口。</li>
<li>25672：用于RabbitMQ节点间和CLI工具通信，配合4369使用。</li>
<li>15672：HTTP_API端口，管理员用户才能访问，用于管理RbbitMQ，需要启用management插件。</li>
<li>61613,61614：当STOMP插件启用的时候打开，作为STOMP客户端端口（根据是否使用TLS选择）。</li>
<li>1883, 8883：当MQTT插件启用的时候打开，作为MQTT客户端端口（根据是否使用TLS选择）。</li>
<li>15674：基于WebSocket的STOMP客户端端口（当插件Web STOMP启用的时候打开）</li>
<li>15675：基于WebSocket的MQTT客户端端口（当插件Web MQTT启用的时候打开）</li>
</ul>
<h2 id="五、RabbitMQ管理界面"><a href="#五、RabbitMQ管理界面" class="headerlink" title="五、RabbitMQ管理界面"></a>五、RabbitMQ管理界面</h2><p>RabbitMQ安装包中带有管理插件，但需要手动激活</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>

<p>RabbitMQ有一个默认的用户“guest”，但这个用户默认只能通过本机访问，要让其它机器可以访问，需要创建一个新用户，为其分配权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加用户</span></span><br><span class="line">rabbitmqctl add_user admin admin</span><br><span class="line"><span class="meta">#</span><span class="bash">为用户分配权限</span></span><br><span class="line">rabbitmqctl set_user_tags admin administrator</span><br><span class="line"><span class="meta">#</span><span class="bash">为用户分配资源权限</span></span><br><span class="line">rabbitmqctl set_permissions -p / admin ".*" ".*" ".*"</span><br></pre></td></tr></table></figure>

<h2 id="六、RabbitMQ角色分类"><a href="#六、RabbitMQ角色分类" class="headerlink" title="六、RabbitMQ角色分类"></a>六、RabbitMQ角色分类</h2><p>RabbitMQ的用户角色分类：none、management、policymaker、monitoring、administrator</p>
<ul>
<li><p>none：不能访问management plugin</p>
</li>
<li><p>management：用户可以通过AMQP做的任何事外加：</p>
<ul>
<li>列出自己可以通过AMQP登入的virtual hosts</li>
<li>查看自己的virtual hosts中的queues,exchanges和bindings</li>
<li>查看和关闭自己的channels和connections</li>
<li>查看有关自己的virtual hosts的“全局”的统计信息，包含其他用户在这些virtual hosts中的活动。</li>
</ul>
</li>
<li><p>policymaker：management可以做的任何事外加：</p>
<ul>
<li>查看、创建和删除自己的virtual hosts所属的policies和parameters</li>
</ul>
</li>
<li><p>monitoring：management可以做的任何事外加：</p>
<ul>
<li>列出所有virtual hosts，包括他们不能登录的virtual hosts</li>
<li>查看其他用户的connections和channels</li>
<li>查看节点级别的数据如clustering和memory使用情况</li>
<li>查看真正的关于所有virtual hosts的全局的统计信息</li>
</ul>
</li>
<li><p>administrator：policymaker和monitoring可以做的任何事外加：</p>
<ul>
<li>创建和删除virtual hosts</li>
<li>查看、创建和删除users</li>
<li>查看创建和删除permissions</li>
<li>关闭其他用户的connections</li>
</ul>
</li>
</ul>
<h2 id="七、简单使用示例"><a href="#七、简单使用示例" class="headerlink" title="七、简单使用示例"></a>七、简单使用示例</h2><p>RabbitMQ支持多种语言访问，以Java为例看下一般使用RabbitMQ的步骤。<br>1、maven工程的pom文件中添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>amqp-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2、消息生产者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.gupaoedu.rabbitmq;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">    <span class="comment">//创建连接工厂</span></span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">    factory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">    <span class="comment">//设置 RabbitMQ 地址</span></span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    <span class="comment">//建立到代理服务器到连接</span></span><br><span class="line">    Connection conn = factory.newConnection();</span><br><span class="line">    <span class="comment">//获得信道</span></span><br><span class="line">    Channel channel = conn.createChannel();</span><br><span class="line">    <span class="comment">//声明交换器</span></span><br><span class="line">    String exchangeName = <span class="string">"hello-exchange"</span>;</span><br><span class="line">    channel.exchangeDeclare(exchangeName, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line"> </span><br><span class="line">    String routingKey = <span class="string">"hola"</span>;</span><br><span class="line">    <span class="comment">//发布消息</span></span><br><span class="line">    <span class="keyword">byte</span>[] messageBodyBytes = <span class="string">"quit"</span>.getBytes();</span><br><span class="line">    channel.basicPublish(exchangeName, routingKey, <span class="keyword">null</span>, messageBodyBytes);</span><br><span class="line"> </span><br><span class="line">    channel.close();</span><br><span class="line">    conn.close();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、消息消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.gupaoedu.rabbitmq;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line">    ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">    factory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">    factory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">    factory.setHost(<span class="string">"localhost"</span>);</span><br><span class="line">    <span class="comment">//建立到代理服务器到连接</span></span><br><span class="line">    Connection conn = factory.newConnection();</span><br><span class="line">    <span class="comment">//获得信道</span></span><br><span class="line">    <span class="keyword">final</span> Channel channel = conn.createChannel();</span><br><span class="line">    <span class="comment">//声明交换器</span></span><br><span class="line">    String exchangeName = <span class="string">"hello-exchange"</span>;</span><br><span class="line">    channel.exchangeDeclare(exchangeName, <span class="string">"direct"</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//声明队列</span></span><br><span class="line">    String queueName = channel.queueDeclare().getQueue();</span><br><span class="line">    String routingKey = <span class="string">"hola"</span>;</span><br><span class="line">    <span class="comment">//绑定队列，通过键 hola 将队列和交换器绑定起来</span></span><br><span class="line">    channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="comment">//消费消息</span></span><br><span class="line">      <span class="keyword">boolean</span> autoAck = <span class="keyword">false</span>;</span><br><span class="line">      String consumerTag = <span class="string">""</span>;</span><br><span class="line">      channel.basicConsume(queueName, autoAck, consumerTag, <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">                     Envelope envelope,</span></span></span><br><span class="line"><span class="function"><span class="params">                     AMQP.BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">          String routingKey = envelope.getRoutingKey();</span><br><span class="line">          String contentType = properties.getContentType();</span><br><span class="line">          System.out.println(<span class="string">"消费的路由键："</span> + routingKey);</span><br><span class="line">          System.out.println(<span class="string">"消费的内容类型："</span> + contentType);</span><br><span class="line">          <span class="keyword">long</span> deliveryTag = envelope.getDeliveryTag();</span><br><span class="line">          <span class="comment">//确认消息</span></span><br><span class="line">          channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">          System.out.println(<span class="string">"消费的消息体内容："</span>);</span><br><span class="line">          String bodyStr = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</span><br><span class="line">          System.out.println(bodyStr);</span><br><span class="line"> </span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、运行Consumer</p>
<p>先运行Consumer，这样当生产者发送消息的时候能在消费者后端看到消息记录。</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220330212400447.png" alt></p>
<p>5、运行Producer<br>接着运行Producer,发布一条消息，在Consumer的控制台能看到接收的消息：</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220330212506996.png" alt></p>
<h2 id="八、AMQP协议"><a href="#八、AMQP协议" class="headerlink" title="八、AMQP协议"></a>八、AMQP协议</h2><p>AMQP（Advanced Message Queuing Protocol）高级消息队列协议，是应用层协议的一个开放标准，为面向消息的中间件设计。</p>
<ul>
<li><p>AMQP结构</p>
<ul>
<li>Module Layer：位于协议最高层，主要定义了一些供客户端调用的命令，客户端可以利用这些命令实现自己的业务逻辑。例如，客户端可以使用Queue.Declare命令声明一个队列或者使用Basic.Consume订阅消费一个队列中的消息。</li>
<li>Session Layer：位于中间层，主要负责将客户端的命令发送给服务器，再将服务端的应答返回给客户端，主要为客户端与服务器之间的通信提供可靠性同步机制和错误处理。</li>
<li>Transport Layer：位于最底层，主要传输二进制数据流，提供帧的处理、信道复用、错误检测和数据表示等。</li>
</ul>
</li>
</ul>
<p>AMQP说到底还是一个通信协议，通信协议都会涉及报文交互从low-level举例来说，AMQP本身是应用层的协议，其填充于TCP协议层的数据部分。从high-level来说，AMQP是通过协议命令进行交互的。AMQP协议可以看作一系列结构化命令的集合，这里的命令代表一种操作，类似于HTTP中的方法(GET、POST、PUT、DELETE等)。</p>
<ul>
<li><p>AMQP生产者流转过程</p>
<p>当客户端与Broker建立连接的时候，会调用factory.newConnection方法，这个方法会进一步封装成Protocol Header 0-9-1的报文头发送给Broker，以此通知Broker本次交互采用的是AMQP0-9-1协议，紧接着Broker返回Connection.Start来建立连接，在连接的过程中涉及Connection.Start/.Start-OK、Connection.Tune/.Tune-Ok，Connection.Open/.Open-Ok这6个命令的交互。</p>
<p>当客户端调用connection.createChannel方法准备开启信道的时候，其包装Channel.Open命令发送给Broker，等待Channel.Open-Ok命令。</p>
<p>当客户端发送消息的时候，需要调用channel.basicPublish方法，对应的AQMP命令为Basic.Publish，注意这个命令和前面涉及的命令略有不同，这个命令还包含了ContentHeader和Content Body。Content Header里面包含的是消息体的属性，例如，投递模式、优先级等。而Content Body包含消息体本身。当客户端发送完消息需要关闭资源时，涉及Channel.Close/.Close-Ok与Connection.Close/.Close-Ok的命令交互。</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220426153604039.png" alt="AMQP生产者流转过程"></p>
</li>
<li><p>AMQP消费者流转过程</p>
<p>消费者客户端同样需要与Broker建立连接与生产者客户端一样，协议交互同样涉及Connection.Start/.Start-Ok、Connection.Tune/.Tune-Ok和Connection.Open/.Open-Ok等，这里中省略了这些步骤紧接着也少不了在Connection之上建立Channel，和生产者客户端一样，协议涉及Channel.Open/Open-Ok。</p>
<p>如果在消费之前调用了channel.basicQos(int prefetchCount)的方法来设置消费者客户端最大能“保持”的未确认的消息数，那么协议流转会涉及Basic.Qos/.Qos-Ok这两个AMQP命令。</p>
<p>在真正消费之前，消费者客户端需要向Broker发送Basic.Consume命令(即调用channel.basicConsume方法〉将Channel置为接收模式，之后Broker回执Basic.Consume-Ok以告诉消费者客户端准备好消费消息。紧接着Broker向消费者客户端推送(Push)消息，即Basic.Deliver命令，有意思的是这个和Basic.Publish命令一样会携带Content Header和Content Body 。<br>消费者接收到消息并正确消费之后，向Broker发送确认，即Basic.Ack命令。在消费者停止消费的时候，主动关闭连接，这点和生产者一样，涉及Channel.Close/.Close-Ok手口Connection.Close/.Close-Ok。<br>AMQP还有很多其它命令，不在此介绍</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220426153648347.png" alt="AMQP消费者流转过程"></p>
</li>
</ul>
<h1 id="RabbitMQ中的概念模型"><a href="#RabbitMQ中的概念模型" class="headerlink" title="RabbitMQ中的概念模型"></a>RabbitMQ中的概念模型</h1><h2 id="一、消息模型"><a href="#一、消息模型" class="headerlink" title="一、消息模型"></a>一、消息模型</h2><p>所有MQ产品从模型抽象上来说都是一样的过程：消费者（consumer）订阅某个队列。生产者（producer）创建消息，然后发布到队列（queue）中，最后将消息发送到监听的消费者。</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220331172238142.png" alt="消息流"></p>
<h2 id="二、RabbitMQ基本概念"><a href="#二、RabbitMQ基本概念" class="headerlink" title="二、RabbitMQ基本概念"></a>二、RabbitMQ基本概念</h2><p>上面只是最简单抽象的描述，具体到RabbitMQ则有更详细的概念需要解释。上面介绍过RabbitMQ是AMQP协议的一个开源实现，所以其内部实际上也是AMQP中的基本概念：</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220331172319038.png" alt="RabbitMQ内部结构"></p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="基本架构图"></p>
<ol>
<li><p>Message</p>
<p>消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。</p>
</li>
<li><p>Publisher</p>
<p>消息的生产者，也是一个向交换器发布消息的客户端应用程序。</p>
</li>
<li><p>Exchange</p>
<p>交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。</p>
</li>
<li><p>Binding</p>
<p>绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。</p>
</li>
<li><p>Queue</p>
<p>消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。</p>
</li>
<li><p>Connection</p>
<p>网络连接，比如一个TCP连接。</p>
</li>
<li><p>Channel</p>
<p>信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条TCP连接。</p>
</li>
<li><p>Consumer</p>
<p>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。消费者的消费模式分为两种：</p>
<p>一种是通过basic.consume命令（push），订阅某一个队列中的消息,channel会自动在处理完上一条消息之后，接收下一条消息。（同一个channel消息处理是串行的）。除非关闭channel或者取消订阅，否则客户端将会一直接收队列的消息。</p>
<p>一种是通过basic.get命令（pull），主动获取队列中的消息，但是绝对不可以通过循环调用basic.get来代替basic.consume，这是因为basic.get RabbitMQ在实际执行的时候，是首先consume某一个队列，然后检索第一条消息，然后再取消订阅。如果是高吞吐率的消费者，最好还是建议使用basic.consume。</p>
</li>
<li><p>Virtual Host</p>
<p>虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个vhost本质上就是一个mini版的RabbitMQ服务器，拥有自己的队列、交换器、绑定和权限机制。vhost是AMQP概念的基础，必须在连接时指定，RabbitMQ默认的vhost是/。</p>
</li>
<li><p>Broker</p>
<p>表示消息队列服务器实体。</p>
</li>
</ol>
<h2 id="三、AMQP中的消息路由"><a href="#三、AMQP中的消息路由" class="headerlink" title="三、AMQP中的消息路由"></a>三、AMQP中的消息路由</h2><p>AMQP中消息的路由过程和Java开发者熟悉的JMS存在一些差别，AMQP中增加了Exchange和Binding的角色。生产者把消息发布到Exchange上，消息最终到达队列并被消费者接收，而Binding决定交换器的消息应该发送到那个队列。</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220331172615010.png" alt="AMQP的消息路由过程"></p>
<h2 id="四、Exchange类型"><a href="#四、Exchange类型" class="headerlink" title="四、Exchange类型"></a>四、Exchange类型</h2><p>Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers。headers匹配AMQP消息的header而不是路由键，此外headers交换器和direct交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：</p>
<p>1、direct</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220331172805639.png" alt="direct交换器"></p>
<p>消息中的路由键（routingkey）如果和Binding中的bindingkey一致，交换器就将消息发到对应的队列中。路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为“dog”，则只转发routingkey标记为“dog”的消息，不会转发“dog.puppy”，也不会转发“dog.guard”等等。它是完全匹配、单播的模式。</p>
<p>2、fanout</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220331172850500.png" alt="fanout交换器"></p>
<p>每个发到fanout类型交换器的消息都会分到所有绑定的队列上去。fanout交换器不处理路由键，只是简单的将队列绑定到交换器上，每个发送到交换器的消息都会被转发到与该交换器绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout类型转发消息是最快的。</p>
<p>3、topic</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220331172922540.png" alt="topic交换器"></p>
<p>topic交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配0个或多个单词，匹配不多不少一个单词。</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220331173011456.png" alt></p>
<h1 id="消息可靠性"><a href="#消息可靠性" class="headerlink" title="消息可靠性"></a>消息可靠性</h1><p>RabbitMQ消息的可靠性投递主要两种实现：<br>1、通过实现消费的重试机制，通过@Retryable来实现重试，可以设置重试次数和重试频率；<br>2、生产端实现消息可靠性投递。<br>两种方法消费端都可能收到重复消息，要求消费端必须实现幂等性消费。</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220408163933663.png" alt="消息可靠性"></p>
<h2 id="消息的可靠投递"><a href="#消息的可靠投递" class="headerlink" title="消息的可靠投递"></a>消息的可靠投递</h2><p>RabbitMQ 的消息可靠性，一般是业务系统接入消息中间件时首要考虑的问题，一般通过三个方面保障</p>
<ul>
<li>发送可靠性：确保消息成功发送到Broker</li>
<li>存储可靠性：Broker对消息持久化，确保消息不会丢失</li>
<li>消费可靠性：确保消息成功被消费，消费者在消费消息的同时，需要将autoAck设置为false，然后通过手动确认的方式去确认己经正确消费的消息，以免在消费端引起不必要的消息丢失。</li>
</ul>
<p>一般消息发送可靠性分为三个层级：</p>
<ul>
<li>At most once：最多一次，消息可能会丢失 ，但绝不会重复传输</li>
<li>At least once：最少一次，消息绝不会丢失，但可能会重复传输</li>
<li>Exactly once：恰好一次，每条消息肯定会被传输一次且仅传输一次</li>
</ul>
<p>RabbitMQ 支持其中的“最多一次”和“最少一次”，其中“最少一次”投递实现需要考虑以下这个几个方面的内容：</p>
<ul>
<li>消息生产者需要开启事务机制或者publisher confirm机制，以确保消息可以可靠地传输到RabbitMQ 中。</li>
<li>消息生产者需要配合使用mandatory参数或者备份交换器来确保消息能够从交换器路由到队列中，进而能够保存下来而不会被丢弃。</li>
</ul>
<p>“最多一次”的方式就无须考虑以上那些方面，生产者随意发送，不过这样很难确保消息会成功发送。</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220426154738540.png" alt></p>
<h3 id="生产端"><a href="#生产端" class="headerlink" title="生产端"></a>生产端</h3><p>在使用RabbitMQ的时候，作为消息发送方希望杜绝任何消息丢失或者投递失败场景。RabbitMQ为我<br>们提供了两种方式用来控制消息的投递可靠性模式</p>
<ul>
<li>confirm确认模式</li>
<li>return退回模式</li>
</ul>
<p><strong>1. 消息投递到exchange的确认模式</strong></p>
<p>rabbitmq的消息投递的过程为：</p>
<p>producer–&gt;broker–&gt;exchange–&gt;queue–&gt;consumer</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220408165331501.png" alt="confirm模式"></p>
<ul>
<li>生产端开启confirm模式，channel.confirmSelect()</li>
<li>生产端发送消息到rabbitmq后，异步接收从rabbitmq返回的ack确认消息</li>
<li>生产端通过channel.addConfirmListener()可以监听到消息ack状态，通过handleAck与handleNack来分别处理投递成功的消息与投递失败的消息</li>
</ul>
<blockquote>
<p>具体代码见rabbitmq-study代码</p>
</blockquote>
<p><strong>2. 消息未投递到queue的退回模式</strong></p>
<p>消息从exchange–&gt;queue投递失败，如无法路由到对应的队列，可设置mandatory为true，则可通过channel.addReturnListener()监听到return消息，如设置为false，则消息自动删除或进入死信队列。</p>
<h3 id="消费端"><a href="#消费端" class="headerlink" title="消费端"></a>消费端</h3><p><strong>消息确认机制ack</strong></p>
<p>ack指Acknowledge确认。表示消费端收到消息后的确认方式。消费端消息的确认分为：自动确认（默认）、手动确认、不确认。</p>
<p>其中自动确认是指，当消息一旦被consumer接收到，则自动确认收到，并将相应message从RabbitMQ的消息缓存中移除。但是在实际业务处理中，很可能消息接收到，业务处理出现异常，那么该消息就会丢失。如果设置了手动确认方式，则需要在业务处理成功后，调用channel.basicAck()，手动签收，如果出现异常，则调用channel.basicNack()方法。</p>
<h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><p>假设一个场景，首先，我们Rabbitmq服务器积压了有上万条未处理的消息，我们随便打开一个消费者客户端，会出现这样情况:巨量的消息瞬间全部推送过来，但是我们单个客户端无法同时处理这么多数据!</p>
<p>当数据量特别大的时候，我们对生产端限流肯定是不科学的，因为有时候并发量就是特别大，有时候并发量又特别少，我们无法约束生产端，这是用户的行为。所以我们应该对消费端限流，用于保持消费端的稳定，当消息数量激增的时候很有可能造成资源耗尽，以及影响服务的性能，导致系统的卡顿甚至直接崩溃。可通过channel.basicQos()来设置消费端的处理消息数量，此时需设置为手动ack。</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220408174944533.png" alt="消费端限流"></p>
<h2 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h2><p>Time To Live，消息过期时间设置声明队列时，指定即可</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220408180519486.png" alt="TTL"></p>
<p>设置消息过期时间有以下两种方式：</p>
<ul>
<li>队列统一过期：队列过期后，会将队列所有消息全部移除</li>
<li>消息单独过期：消息过期后，只有消息在队列顶端，才会判断其是否过期（移除掉）</li>
</ul>
<p>如果设置了消息的过期时间，也设置了队列的过期时间，它以时间短的为准。</p>
<h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>死信队列，英文缩写：DLX。Dead Letter Exchange（死信交换机），当消息成为Dead message后，可以被重新发送到另一个交换机，这个交换机就是DLX。</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220408181010053.png" alt="DLX"></p>
<p>消息成为死信的三种情况：</p>
<ol>
<li>队列消息长度到达限制；</li>
<li>消费者拒接消费消息，basicNack/basicReject,并且不把消息重新放入原目标队列,requeue=false；</li>
<li>原队列存在消息过期设置，消息到达超时时间未被消费；</li>
</ol>
<p>队列绑定死信交换机：</p>
<p>给队列设置参数：x-dead-letter-exchange和x-dead-letter-routing-key也就是说此时Queue作为”生产者”</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220408181128300.png" alt="绑定死信交换机"></p>
<h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费</p>
<p>需求：下单后，30分钟未支付，取消订单，回滚库存。新用户注册成功7天后，发送短信问候。<br>实现方式：定时器（×）延迟队列（√）</p>
<p>实现步骤：</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220408181237989.png" alt></p>
<p>在RabbitMQ中并未提供延迟队列功能</p>
<p>替代实现：TTL+死信队列组合实现延迟队列的效果</p>
<p><img src="/2022/03/30/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-1-RabbitMQ/image-20220408181307143.png" alt></p>
<h1 id="集群部署方式"><a href="#集群部署方式" class="headerlink" title="集群部署方式"></a>集群部署方式</h1><h2 id="多机多节点集群部署"><a href="#多机多节点集群部署" class="headerlink" title="多机多节点集群部署"></a>多机多节点集群部署</h2><h2 id="单机多节点部署"><a href="#单机多节点部署" class="headerlink" title="单机多节点部署"></a>单机多节点部署</h2><p><strong>1.保证当前安装的rabbitmq程序正常，并正常启动过。</strong></p>
<p><strong>2.停掉rabbitmq节点，保证服务未在运行中。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl stop</span><br></pre></td></tr></table></figure>

<p><strong>3.设置环境变量指定端口和节点名称</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit-1</span><br></pre></td></tr></table></figure>

<p><strong>4.后台启动节点</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmq-server -detached</span><br></pre></td></tr></table></figure>

<p><strong>5.启动第二个节点</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RABBITMQ_NODE_PORT=5673 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [&#123;port,15673&#125;]" RABBITMQ_NODENAME=rabbit-2 rabbitmq-server -detached</span><br></pre></td></tr></table></figure>

<p><strong>6.启动第三个节点</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">RABBITMQ_NODE_PORT=5674 RABBITMQ_SERVER_START_ARGS="-rabbitmq_management listener [&#123;port,15674&#125;]" RABBITMQ_NODENAME=rabbit-3 rabbitmq-server -detached</span><br></pre></td></tr></table></figure>

<p><strong>7.将rabbit-2加入到集群</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止 rabbit-2 的应用</span></span><br><span class="line">rabbitmqctl -n rabbit-2 stop_app</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置 rabbit-2 的设置</span></span><br><span class="line">rabbitmqctl -n rabbit-2 reset</span><br><span class="line"><span class="meta">#</span><span class="bash"> rabbit-2 节点加入到 rabbit1的集群中</span></span><br><span class="line">rabbitmqctl -n rabbit-2 join_cluster rabbit-1 --ram</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 rabbit-2 节点</span></span><br><span class="line">rabbitmqctl -n rabbit-2 start_app</span><br></pre></td></tr></table></figure>

<p><strong>8.将rabbit-3加入到集群</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 停止 rabbit-3 的应用</span></span><br><span class="line">rabbitmqctl -n rabbit-3 stop_app</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置 rabbit-3 的设置</span></span><br><span class="line">rabbitmqctl -n rabbit-3 reset</span><br><span class="line"><span class="meta">#</span><span class="bash"> rabbit-3 节点加入到 rabbit-1的集群中</span></span><br><span class="line">rabbitmqctl -n rabbit-3 join_cluster rabbit-1 --ram</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 rabbit-3 节点</span></span><br><span class="line">rabbitmqctl -n rabbit-3 start_app</span><br></pre></td></tr></table></figure>

<p><strong>9.查看集群状态，看到 {running_nodes,[rabbit3@node1,rabbit2@node1,rabbit1@node1]} 说明节点已启动成功。</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl -n rabbit-1 cluster_status</span><br></pre></td></tr></table></figure>

<p><strong>10.移除节点</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">首先将要移除的节点停机</span></span><br><span class="line">rabbitmqctl -n rabbit-3 stop_app</span><br><span class="line"><span class="meta">#</span><span class="bash">在主节点,也就是发起进群的主机上进行节点的移除</span></span><br><span class="line">rabbitmqctl -n rabbit-1 forget_cluster_node rabbit-3</span><br></pre></td></tr></table></figure>

<p><strong>11.设置高可用集群</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rabbitmqctl set_policy ha-all "^" '&#123;"ha-mode":"all"&#125;'</span><br></pre></td></tr></table></figure>

<h2 id="镜像队列模式集群"><a href="#镜像队列模式集群" class="headerlink" title="镜像队列模式集群"></a>镜像队列模式集群</h2><ul>
<li><p>镜像队列属于RabbitMQ的高可用方案，见：<a href="https://www.rabbitmq.com/ha.html#mirroring-arguments" target="_blank" rel="noopener">https://www.rabbitmq.com/ha.html#mirroring-arguments</a></p>
</li>
<li><p>通过前面的步骤搭建的集群属于普通模式集群，是通过共享元数据实现集群</p>
</li>
<li><p>开启镜像队列模式需要在管理页面添加策略，添加方式：</p>
<ol>
<li>进入管理页面-&gt;Admin-&gt;Policies（在页面右侧）-&gt;Add/update a policy</li>
<li>在表单中填入：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: ha-all</span><br><span class="line">Pattern: ^</span><br><span class="line">Apply to: Queues</span><br><span class="line">Priority: 0</span><br><span class="line">Definition: ha-mode &#x3D; all</span><br></pre></td></tr></table></figure>

<p><strong>参数说明</strong></p>
<p>name:策略名称，如果使用已有的名称，保存后将会修改原来的信息</p>
<p>Apply to：策略应用到什么对象上</p>
<p>Pattern：策略应用到对象时，对象名称的匹配规则（正则表达式）</p>
<p>Priority：优先级，数值越大，优先级越高，相同优先级取最后一个</p>
<p>Definition：策略定义的类容，对于镜像队列的配置来说，只需要包含3个部分:ha-mode、ha-params和ha-sync-mode。其中，ha-sync-mode是同步的方式，自动还是手动，默认是自动。ha-mode和ha-params组合使用。组合方式如下：</p>
<table>
<thead>
<tr>
<th>ha-mode</th>
<th>ha-params</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>all</td>
<td>(empty)</td>
<td>队列镜像到集群类所有节点</td>
</tr>
<tr>
<td>exactly</td>
<td>count</td>
<td>队列镜像到集群内指定数量的节点。如果集群内节点数少于此值，队列将会镜像到所有节点。如果大于此值，而且一个包含镜像的节点停止，则新的镜像不会在其它节点创建。</td>
</tr>
<tr>
<td>nodes</td>
<td>nodename</td>
<td>队列镜像到指定节点，指定的节点不在集群中不会报错。当队列申明时，如果指定的节点不在线，则队列会被创建在客户端所连接的节点上。</td>
</tr>
</tbody></table>
</li>
<li><p>镜像队列模式相比较普通模式，镜像模式会占用更多的带宽来进行同步，所以镜像队列的吞吐量会低于普通模式</p>
</li>
<li><p>但普通模式不能实现高可用，某个节点挂了后，这个节点上的消息将无法被消费，需要等待节点启动后才能被消费。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>消息中间件</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件-3-RocketMQ</title>
    <url>/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/</url>
    <content><![CDATA[<h1 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h1><h1 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h1><p><strong>1、消息模型（Message Model）</strong></p>
<p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责生产消息，Consumer 负责消费消息，Broker 负责存储消息。Broker 在实际部署过程中对应一台服务器，每个 Broker 可以存储多个Topic的消息，每个Topic的消息也可以分片存储于不同的 Broker。Message Queue 用于存储消息的物理地址，每个Topic中的消息地址存储于多个 Message Queue 中。ConsumerGroup 由多个Consumer 实例构成。</p>
<p><strong>2、消息生产者（Producer）</strong></p>
<p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种发送方式，<strong>同步发送、异步发送、顺序发送、单向发送</strong>。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p>
<p><strong>3、消息消费者（Consumer）</strong></p>
<p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：拉取式消费、推动式消费。</p>
<p><strong>4、主题（Topic）</strong></p>
<p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。</p>
<p><strong>5、代理服务器（Broker Server）</strong></p>
<p>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>
<p><strong>6、名字服务（Name Server）</strong></p>
<p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p>
<p><strong>7、拉取式消费（Pull Consumer）</strong></p>
<p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。</p>
<p><strong>8、推动式消费（Push Consumer）</strong></p>
<p>Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。</p>
<p><strong>9、生产者组（Producer Group）</strong></p>
<p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。</p>
<p><strong>10、消费者组（Consumer Group）</strong></p>
<p>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。RocketMQ 支持两种消息模式：集群消费（Clustering）和广播消费（Broadcasting）。</p>
<p><strong>11、集群消费（Clustering）</strong></p>
<p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p>
<p><strong>12、广播消费（Broadcasting）</strong></p>
<p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p>
<p><strong>13、普通顺序消息（Normal Ordered Message）</strong></p>
<p>普通顺序消费模式下，消费者通过同一个消息队列（ Topic 分区，称作 Message Queue） 收到的消息是有顺序的，不同消息队列收到的消息则可能是无顺序的。</p>
<p><strong>14、严格顺序消息（Strictly Ordered Message）</strong></p>
<p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p>
<p><strong>15、消息（Message）</strong></p>
<p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。系统提供了通过Message ID和Key查询消息的功能。</p>
<p><strong>16、标签（Tag）</strong></p>
<p>为消息设置的标志，用于同一主题下区分不同类型的消息。来自同一业务单元的消息，可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消费逻辑，实现更好的扩展性。</p>
<h1 id="二、特性"><a href="#二、特性" class="headerlink" title="二、特性"></a>二、特性</h1><p><strong>1、订阅与发布</strong></p>
<p>消息的发布是指某个生产者向某个topic发送消息；消息的订阅是指某个消费者关注了某个topic中带有某些tag的消息，进而从该topic消费数据。</p>
<p><strong>2、消息顺序</strong></p>
<p>消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了三条消息分别是订单创建、订单付款、订单完成。消费时要按照这个顺序消费才能有意义，但是同时订单之间是可以并行消费的。RocketMQ可以严格的保证消息有序。</p>
<p>顺序消息分为全局顺序消息与分区顺序消息，全局顺序是指某个Topic下的所有消息都要保证顺序；部分顺序消息只要保证每一组消息被顺序消费即可。</p>
<ul>
<li>全局顺序<br>对于指定的一个 Topic，所有消息按照严格的先入先出（FIFO）的顺序进行发布和消费。<br>适用场景：性能要求不高，所有的消息严格按照 FIFO 原则进行消息发布和消费的场景</li>
<li>分区顺序<br>对于指定的一个 Topic，所有消息根据 sharding key 进行区块分区。 同一个分区内的消息按照严格的 FIFO 顺序进行发布和消费。 Sharding key 是顺序消息中用来区分不同分区的关键字段，和普通消息的 Key 是完全不同的概念。<br>适用场景：性能要求高，以 sharding key 作为分区字段，在同一个区块中严格的按照 FIFO 原则进行消息发布和消费的场景。</li>
</ul>
<p><strong>3、消息过滤</strong></p>
<p>RocketMQ的消费者可以根据Tag进行消息过滤，也支持自定义属性过滤。消息过滤目前是在Broker端实现的，优点是减少了对于Consumer无用消息的网络传输，缺点是增加了Broker的负担、而且实现相对复杂。</p>
<p><strong>4消息可靠性</strong></p>
<p>RocketMQ支持消息的高可靠，影响消息可靠性的几种情况：</p>
<p>1) Broker非正常关闭<br>2) Broker异常Crash<br>3) OS Crash<br>4) 机器掉电，但是能立即恢复供电情况<br>5) 机器无法开机（可能是cpu、主板、内存等关键设备损坏）<br>6) 磁盘设备损坏</p>
<p>1)、2)、3)、4) 四种情况都属于硬件资源可立即恢复情况，RocketMQ在这四种情况下能保证消息不丢，或者丢失少量数据（依赖刷盘方式是同步还是异步）。</p>
<p>5)、6)属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。RocketMQ在这两种情况下，通过异步复制，可保证99%的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术可以完全避免单点，同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与Money相关的应用。注：RocketMQ从3.0版本开始支持同步双写。</p>
<p><strong>5、至少一次</strong></p>
<p>至少一次(At least Once)指每个消息必须投递一次。Consumer先Pull消息到本地，消费完成后，才向服务器返回ack，如果没有消费一定不会ack消息，所以RocketMQ可以很好的支持此特性。</p>
<p><strong>6、回溯消费</strong></p>
<p>回溯消费是指Consumer已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker在向Consumer投递成功消息后，消息仍然需要保留。并且重新消费一般是按照时间维度，例如由于Consumer系统故障，恢复后需要重新消费1小时前的数据，那么Broker要提供一种机制，可以按照时间维度来回退消费进度。RocketMQ支持按照时间回溯消费，时间维度精确到毫秒。</p>
<p><strong>7、事务消息</strong></p>
<p>RocketMQ事务消息（Transactional Message）是指应用本地事务和发送消息操作可以被定义到全局事务中，要么同时成功，要么同时失败。RocketMQ的事务消息提供类似 X/Open XA 的分布事务功能，通过事务消息能达到分布式事务的最终一致。</p>
<p><strong>8、定时消息</strong></p>
<p>定时消息（延迟队列）是指消息发送到broker后，不会立即被消费，等待特定时间投递给真正的topic。<br>broker有配置项messageDelayLevel，默认值为“1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h”，18个level。可以配置自定义messageDelayLevel。注意，messageDelayLevel是broker的属性，不属于某个topic。发消息时，设置delayLevel等级即可：msg.setDelayLevel(level)。level有以下三种情况：</p>
<ul>
<li>level == 0，消息为非延迟消息</li>
<li>1&lt;=level&lt;=maxLevel，消息延迟特定时间，例如level==1，延迟1s</li>
<li>level &gt; maxLevel，则level== maxLevel，例如level==20，延迟2h</li>
</ul>
<p>定时消息会暂存在名为SCHEDULE_TOPIC_XXXX的topic中，并根据delayTimeLevel存入特定的queue，queueId = delayTimeLevel – 1，即一个queue只存相同延迟的消息，保证具有相同发送延迟的消息能够顺序消费。broker会调度地消费SCHEDULE_TOPIC_XXXX，将消息写入真实的topic。</p>
<p>需要注意的是，定时消息会在第一次写入和调度写入真实topic时都会计数，因此发送数量、tps都会变高。</p>
<p><strong>9、消息重试</strong></p>
<p>Consumer消费消息失败后，要提供一种重试机制，令消息再消费一次。Consumer消费消息失败通常可以认为有以下几种情况：</p>
<ul>
<li>由于消息本身的原因，例如反序列化失败，消息数据本身无法处理（例如话费充值，当前消息的手机号被注销，无法充值）等。这种错误通常需要跳过这条消息，再消费其它消息，而这条失败的消息即使立刻重试消费，99%也不成功，所以最好提供一种定时重试机制，即过10秒后再重试。</li>
<li>由于依赖的下游应用服务不可用，例如db连接不可用，外系统网络不可达等。遇到这种错误，即使跳过当前失败的消息，消费其他消息同样也会报错。这种情况建议应用sleep 30s，再消费下一条消息，这样可以减轻Broker重试消息的压力。</li>
</ul>
<p>RocketMQ会为每个消费组都设置一个Topic名称为“%RETRY%+consumerGroup”的重试队列（这里需要注意的是，这个Topic的重试队列是针对消费组，而不是针对每个Topic设置的），用于暂时保存因为各种异常而导致Consumer端无法消费的消息。考虑到异常恢复起来需要一些时间，会为重试队列设置多个重试级别，每个重试级别都有与之对应的重新投递延时，重试次数越多投递延时就越大。RocketMQ对于重试消息的处理是先保存至Topic名称为“SCHEDULE_TOPIC_XXXX”的延迟队列中，后台定时任务按照对应的时间进行Delay后重新保存至“%RETRY%+consumerGroup”的重试队列中。</p>
<p><strong>10、消息重投</strong></p>
<p>生产者在发送消息时，同步消息失败会重投，异步消息有重试，oneway没有任何保证。消息重投保证消息尽可能发送成功、不丢失，但可能会造成消息重复，消息重复在RocketMQ中是无法避免的问题。消息重复在一般情况下不会发生，当出现消息量大、网络抖动，消息重复就会是大概率事件。另外，生产者主动重发、consumer负载变化也会导致重复消息。如下方法可以设置消息重试策略：</p>
<ul>
<li>retryTimesWhenSendFailed:同步发送失败重投次数，默认为2，因此生产者会最多尝试发送retryTimesWhenSendFailed + 1次。不会选择上次失败的broker，尝试向其他broker发送，最大程度保证消息不丢。超过重投次数，抛出异常，由客户端保证消息不丢。当出现RemotingException、MQClientException和部分MQBrokerException时会重投。</li>
<li>retryTimesWhenSendAsyncFailed:异步发送失败重试次数，异步重试不会选择其他broker，仅在同一个broker上做重试，不保证消息不丢。</li>
<li>retryAnotherBrokerWhenNotStoreOK:消息刷盘（主或备）超时或slave不可用（返回状态非SEND_OK），是否尝试发送到其他broker，默认false。十分重要消息可以开启。</li>
</ul>
<p><strong>11、流量控制</strong></p>
<p>生产者流控，因为broker处理能力达到瓶颈；消费者流控，因为消费能力达到瓶颈。</p>
<p>生产者流控：</p>
<ul>
<li>commitLog文件被锁时间超过osPageCacheBusyTimeOutMills时，参数默认为1000ms，返回流控。</li>
<li>如果开启transientStorePoolEnable == true，且broker为异步刷盘的主机，且transientStorePool中资源不足，拒绝当前send请求，返回流控。</li>
<li>broker每隔10ms检查send请求队列头部请求的等待时间，如果超过waitTimeMillsInSendQueue，默认200ms，拒绝当前send请求，返回流控。</li>
<li>broker通过拒绝send 请求方式实现流量控制。</li>
</ul>
<p>注意，生产者流控，不会尝试消息重投。</p>
<p>消费者流控：</p>
<ul>
<li>消费者本地缓存消息数超过pullThresholdForQueue时，默认1000。</li>
<li>消费者本地缓存消息大小超过pullThresholdSizeForQueue时，默认100MB。</li>
<li>消费者本地缓存消息跨度超过consumeConcurrentlyMaxSpan时，默认2000。</li>
</ul>
<p>消费者流控的结果是降低拉取频率。</p>
<p><strong>12、死信队列</strong></p>
<p>死信队列用于处理无法被正常消费的消息。当一条消息初次消费失败，消息队列会自动进行消息重试；达到最大重试次数后，若消费依然失败，则表明消费者在正常情况下无法正确地消费该消息，此时，消息队列 不会立刻将消息丢弃，而是将其发送到该消费者对应的特殊队列中。</p>
<p>RocketMQ将这种正常情况下无法被消费的消息称为死信消息（Dead-Letter Message），将存储死信消息的特殊队列称为死信队列（Dead-Letter Queue）。在RocketMQ中，可以通过使用console控制台对死信队列中的消息进行重发来使得消费者实例再次进行消费。</p>
<h1 id="三、架构设计"><a href="#三、架构设计" class="headerlink" title="三、架构设计"></a>三、架构设计</h1><h2 id="1、技术架构"><a href="#1、技术架构" class="headerlink" title="1、技术架构"></a>1、技术架构</h2><p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_architecture_1.png" alt="rocketmq_architecture_1"></p>
<p>RocketMQ架构上主要分为四部分，如上图所示:</p>
<ul>
<li><p>Producer：消息发布的角色，支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的Broker集群队列进行消息投递，投递的过程支持快速失败并且低延迟。</p>
</li>
<li><p>Consumer：消息消费的角色，支持分布式集群方式部署。支持以push推，pull拉两种模式对消息进行消费。同时也支持集群方式和广播方式的消费，它提供实时消息订阅机制，可以满足大多数用户的需求。</p>
</li>
<li><p>NameServer：NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的zookeeper，支持Broker的动态注册与发现。主要包括两个功能：Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活；路由信息管理，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线了，Broker仍然可以向其它NameServer同步其路由信息，Producer和Consumer仍然可以动态感知Broker的路由的信息。 </p>
</li>
<li><p>BrokerServer：Broker主要负责消息的存储、投递和查询以及服务高可用保证，为了实现这些功能，Broker包含了以下几个重要子模块。</p>
<ol>
<li>Remoting Module：整个Broker的实体，负责处理来自Client端的请求。</li>
<li>Client Manager：负责管理客户端(Producer/Consumer)和维护Consumer的Topic订阅信息。</li>
<li>Store Service：提供方便简单的API接口处理消息存储到物理硬盘和查询功能。</li>
<li>HA Service：高可用服务，提供Master Broker 和 Slave Broker之间的数据同步功能。</li>
<li>Index Service：根据特定的Message key对投递到Broker的消息进行索引服务，以提供消息的快速查询。</li>
</ol>
</li>
</ul>
<p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_architecture_2.png" alt="rocketmq_architecture_2"></p>
<h2 id="2、部署架构"><a href="#2、部署架构" class="headerlink" title="2、部署架构"></a>2、部署架构</h2><p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_architecture_3.png" alt="rocketmq_architecture_3"></p>
<h3 id="RocketMQ-网络部署特点"><a href="#RocketMQ-网络部署特点" class="headerlink" title="RocketMQ 网络部署特点"></a>RocketMQ 网络部署特点</h3><ul>
<li><p>NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步。</p>
</li>
<li><p>Broker部署相对复杂，Broker分为Master与Slave，一个Master可以对应多个Slave，但是一个Slave只能对应一个Master，Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1的从服务器才会参与消息的读负载。</p>
</li>
<li><p>Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。</p>
</li>
<li><p>Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还是Slave拉取。</p>
</li>
</ul>
<p>结合部署架构图，描述集群工作流程：</p>
<ul>
<li>启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。</li>
<li>Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。</li>
<li>收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。</li>
<li>Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。</li>
<li>Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息。</li>
</ul>
<h2 id="3、设计"><a href="#3、设计" class="headerlink" title="3、设计"></a>3、设计</h2><h3 id="3-1-消息存储"><a href="#3-1-消息存储" class="headerlink" title="3.1 消息存储"></a>3.1 消息存储</h3><p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_design_1.png" alt="rocketmq_design_1">消息存储是RocketMQ中最为复杂和最为重要的一部分，本节将分别从RocketMQ的消息存储整体架构、PageCache与Mmap内存映射以及RocketMQ中两种不同的刷盘方式三方面来分别展开叙述。</p>
<h4 id="3-1-1-消息存储整体架构"><a href="#3-1-1-消息存储整体架构" class="headerlink" title="3.1.1 消息存储整体架构"></a>3.1.1 消息存储整体架构</h4><p>消息存储架构图中主要有下面三个跟消息存储相关的文件构成。</p>
<p>(1) CommitLog：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G, 文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件；</p>
<p>(2) ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能，由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件中根据topic检索消息是非常低效的。Consumer即可根据ConsumeQueue来查找待消费的消息。其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。consumequeue文件可以看成是基于topic的commitlog索引文件，故consumequeue文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M；</p>
<p>(3) IndexFile：IndexFile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。Index文件的存储位置是：$HOME \store\index${fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。</p>
<p>在上面的RocketMQ的消息存储整体架构图中可以看出，RocketMQ采用的是混合型的存储结构，即为Broker单个实例下所有的队列共用一个日志数据文件（即为CommitLog）来存储。RocketMQ的混合型存储结构(多个Topic的消息实体内容都存储于一个CommitLog中)针对Producer和Consumer分别采用了数据和索引部分相分离的存储结构，Producer发送消息至Broker端，然后Broker端使用同步或者异步的方式对消息刷盘持久化，保存至CommitLog中。只要消息被刷盘持久化至磁盘文件CommitLog中，那么Producer发送的消息就不会丢失。正因为如此，Consumer也就肯定有机会去消费这条消息。当无法拉取到消息后，可以等下一次消息拉取，同时服务端也支持长轮询模式，如果一个消息拉取请求未拉取到消息，Broker允许等待30s的时间，只要这段时间内有新消息到达，将直接返回给消费端。这里，RocketMQ的具体做法是，使用Broker端的后台服务线程—ReputMessageService不停地分发请求并异步构建ConsumeQueue（逻辑消费队列）和IndexFile（索引文件）数据。</p>
<h4 id="3-1-2-页缓存与内存映射"><a href="#3-1-2-页缓存与内存映射" class="headerlink" title="3.1.2 页缓存与内存映射"></a>3.1.2 页缓存与内存映射</h4><p>页缓存（PageCache)是OS对文件的缓存，用于加速对文件的读写。一般来说，程序对文件进行顺序读写的速度几乎接近于内存的读写速度，主要原因就是由于OS使用PageCache机制对读写访问操作进行了性能优化，将一部分的内存用作PageCache。对于数据的写入，OS会先写入至Cache内，随后通过异步的方式由pdflush内核线程将Cache内的数据刷盘至物理磁盘上。对于数据的读取，如果一次读取文件时出现未命中PageCache的情况，OS从物理磁盘上访问读取文件的同时，会顺序对其他相邻块的数据文件进行预读取。</p>
<p>在RocketMQ中，ConsumeQueue逻辑消费队列存储的数据较少，并且是顺序读取，在page cache机制的预读取作用下，Consume Queue文件的读性能几乎接近读内存，即使在有消息堆积情况下也不会影响性能。而对于CommitLog消息存储的日志数据文件来说，读取消息内容时候会产生较多的随机访问读取，严重影响性能。如果选择合适的系统IO调度算法，比如设置调度算法为“Deadline”（此时块存储采用SSD的话），随机读的性能也会有所提升。</p>
<p>另外，RocketMQ主要通过MappedByteBuffer对文件进行读写操作。其中，利用了NIO中的FileChannel模型将磁盘上的物理文件直接映射到用户态的内存地址中（这种Mmap的方式减少了传统IO将磁盘文件数据在操作系统内核地址空间的缓冲区和用户应用程序地址空间的缓冲区之间来回进行拷贝的性能开销），将对文件的操作转化为直接对内存地址进行操作，从而极大地提高了文件的读写效率（正因为需要使用内存映射机制，故RocketMQ的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存）。</p>
<h4 id="3-1-3-消息刷盘"><a href="#3-1-3-消息刷盘" class="headerlink" title="3.1.3 消息刷盘"></a>3.1.3 消息刷盘</h4><p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_design_2.png" alt="rocketmq_design_2"></p>
<p>(1) 同步刷盘：如上图所示，只有在消息真正持久化至磁盘后RocketMQ的Broker端才会真正返回给Producer端一个成功的ACK响应。同步刷盘对MQ消息可靠性来说是一种不错的保障，但是性能上会有较大影响，一般适用于金融业务应用该模式较多。</p>
<p>(2) 异步刷盘：能够充分利用OS的PageCache的优势，只要消息写入PageCache即可将成功的ACK返回给Producer端。消息刷盘采用后台异步线程提交的方式进行，降低了读写延迟，提高了MQ的性能和吞吐量。</p>
<h3 id="3-2-通信机制"><a href="#3-2-通信机制" class="headerlink" title="3.2 通信机制"></a>3.2 通信机制</h3><p>RocketMQ消息队列集群主要包括NameServer、Broker(Master/Slave)、Producer、Consumer4个角色，基本通讯流程如下：</p>
<p>(1) Broker启动后需要完成一次将自己注册至NameServer的操作；随后每隔30s时间定时向NameServer上报Topic路由信息。</p>
<p>(2) 消息生产者Producer作为客户端发送消息时候，需要根据消息的Topic从本地缓存的TopicPublishInfoTable获取路由信息。如果没有则更新路由信息会从NameServer上重新拉取，同时Producer会默认每隔30s向NameServer拉取一次路由信息。</p>
<p>(3) 消息生产者Producer根据2）中获取的路由信息选择一个队列（MessageQueue）进行消息发送；Broker作为消息的接收者接收消息并落盘存储。</p>
<p>(4) 消息消费者Consumer根据2）中获取的路由信息，并再完成客户端的负载均衡后，选择其中的某一个或者某几个消息队列来拉取消息并进行消费。</p>
<p>从上面1）~3）中可以看出在消息生产者, Broker和NameServer之间都会发生通信（这里只说了MQ的部分通信），因此如何设计一个良好的网络通信模块在MQ中至关重要，它将决定RocketMQ集群整体的消息传输能力与最终的性能。</p>
<p>rocketmq-remoting 模块是 RocketMQ消息队列中负责网络通信的模块，它几乎被其他所有需要网络通信的模块（诸如rocketmq-client、rocketmq-broker、rocketmq-namesrv）所依赖和引用。为了实现客户端与服务器之间高效的数据请求与接收，RocketMQ消息队列自定义了通信协议并在Netty的基础之上扩展了通信模块。</p>
<h4 id="3-2-1-Remoting通信类结构"><a href="#3-2-1-Remoting通信类结构" class="headerlink" title="3.2.1 Remoting通信类结构"></a>3.2.1 Remoting通信类结构</h4><p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_design_3.png" alt="rocketmq_design_3"></p>
<h4 id="3-2-2-协议设计与编解码"><a href="#3-2-2-协议设计与编解码" class="headerlink" title="3.2.2 协议设计与编解码"></a>3.2.2 协议设计与编解码</h4><p>在Client和Server之间完成一次消息发送时，需要对发送的消息进行一个协议约定，因此就有必要自定义RocketMQ的消息协议。同时，为了高效地在网络中传输消息和对收到的消息读取，就需要对消息进行编解码。在RocketMQ中，RemotingCommand这个类在消息传输过程中对所有数据内容的封装，不但包含了所有的数据结构，还包含了编码解码操作。</p>
<table>
<thead>
<tr>
<th>Header字段</th>
<th>类型</th>
<th>Request说明</th>
<th>Response说明</th>
</tr>
</thead>
<tbody><tr>
<td>code</td>
<td>int</td>
<td>请求操作码，应答方根据不同的请求码进行不同的业务处理</td>
<td>应答响应码。0表示成功，非0则表示各种错误</td>
</tr>
<tr>
<td>language</td>
<td>LanguageCode</td>
<td>请求方实现的语言</td>
<td>应答方实现的语言</td>
</tr>
<tr>
<td>version</td>
<td>int</td>
<td>请求方程序的版本</td>
<td>应答方程序的版本</td>
</tr>
<tr>
<td>opaque</td>
<td>int</td>
<td>相当于requestId，在同一个连接上的不同请求标识码，与响应消息中的相对应</td>
<td>应答不做修改直接返回</td>
</tr>
<tr>
<td>flag</td>
<td>int</td>
<td>区分是普通RPC还是onewayRPC的标志</td>
<td>区分是普通RPC还是onewayRPC的标志</td>
</tr>
<tr>
<td>remark</td>
<td>String</td>
<td>传输自定义文本信息</td>
<td>传输自定义文本信息</td>
</tr>
<tr>
<td>extFields</td>
<td>HashMap&lt;String, String&gt;</td>
<td>请求自定义扩展信息</td>
<td>响应自定义扩展信息</td>
</tr>
</tbody></table>
<p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_design_4.png" alt="rocketmq_design_4"></p>
<p>可见传输内容主要可以分为以下4部分：</p>
<p>(1) 消息长度：总长度，四个字节存储，占用一个int类型；</p>
<p>(2) 序列化类型&amp;消息头长度：同样占用一个int类型，第一个字节表示序列化类型，后面三个字节表示消息头长度；</p>
<p>(3) 消息头数据：经过序列化后的消息头数据；</p>
<p>(4) 消息主体数据：消息主体的二进制字节数据内容；</p>
<h4 id="3-2-3-消息的通信方式和流程"><a href="#3-2-3-消息的通信方式和流程" class="headerlink" title="3.2.3 消息的通信方式和流程"></a>3.2.3 消息的通信方式和流程</h4><p>在RocketMQ消息队列中支持通信的方式主要有同步(sync)、异步(async)、单向(oneway)<br>三种。其中“单向”通信模式相对简单，一般用在发送心跳包场景下，无需关注其Response。这里，主要介绍RocketMQ的异步通信流程。</p>
<p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_design_5.png" alt="rocketmq_design_5"></p>
<h4 id="3-2-4-Reactor多线程设计"><a href="#3-2-4-Reactor多线程设计" class="headerlink" title="3.2.4 Reactor多线程设计"></a>3.2.4 Reactor多线程设计</h4><p>RocketMQ的RPC通信采用Netty组件作为底层通信库，同样也遵循了Reactor多线程模型，同时又在这之上做了一些扩展和优化。</p>
<p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_design_6.png" alt="rocketmq_design_6"></p>
<p>上面的框图中可以大致了解RocketMQ中NettyRemotingServer的Reactor 多线程模型。一个 Reactor 主线程（eventLoopGroupBoss，即为上面的1）负责监听 TCP网络连接请求，建立好连接，创建SocketChannel，并注册到selector上。RocketMQ的源码中会自动根据OS的类型选择NIO和Epoll，也可以通过参数配置）,然后监听真正的网络数据。拿到网络数据后，再丢给Worker线程池（eventLoopGroupSelector，即为上面的“N”，源码中默认设置为3），在真正执行业务逻辑之前需要进行SSL验证、编解码、空闲检查、网络连接管理，这些工作交给defaultEventExecutorGroup（即为上面的“M1”，源码中默认设置为8）去做。而处理业务操作放在业务线程池中执行，根据 RomotingCommand 的业务请求码code去processorTable这个本地缓存变量中找到对应的 processor，然后封装成task任务后，提交给对应的业务processor处理线程池来执行（sendMessageExecutor，以发送消息为例，即为上面的 “M2”）。从入口到业务逻辑的几个步骤中线程池一直再增加，这跟每一步逻辑复杂性相关，越复杂，需要的并发通道越宽。</p>
<table>
<thead>
<tr>
<th>线程数</th>
<th>线程名</th>
<th>线程具体说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>NettyBoss_%d</td>
<td>Reactor 主线程</td>
</tr>
<tr>
<td>N</td>
<td>NettyServerEPOLLSelector_%d_%d</td>
<td>Reactor 线程池</td>
</tr>
<tr>
<td>M1</td>
<td>NettyServerCodecThread_%d</td>
<td>Worker线程池</td>
</tr>
<tr>
<td>M2</td>
<td>RemotingExecutorThread_%d</td>
<td>业务processor处理线程池</td>
</tr>
</tbody></table>
<h3 id="3-3-消息过滤"><a href="#3-3-消息过滤" class="headerlink" title="3.3 消息过滤"></a>3.3 消息过滤</h3><p>RocketMQ分布式消息队列的消息过滤方式有别于其它MQ中间件，是在Consumer端订阅消息时再做消息过滤的。RocketMQ这么做是在于其Producer端写入消息和Consumer端订阅消息采用分离存储的机制来实现的，Consumer端订阅消息是需要通过ConsumeQueue这个消息消费的逻辑队列拿到一个索引，然后再从CommitLog里面读取真正的消息实体内容，所以说到底也是还绕不开其存储结构。其ConsumeQueue的存储结构如下，可以看到其中有8个字节存储的Message Tag的哈希值，基于Tag的消息过滤正是基于这个字段值的。</p>
<p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_design_7.png" alt="rocketmq_design_7"></p>
<p>主要支持如下2种的过滤方式<br>(1) Tag过滤方式：Consumer端在订阅消息时除了指定Topic还可以指定TAG，如果一个消息有多个TAG，可以用||分隔。其中，Consumer端会将这个订阅请求构建成一个 SubscriptionData，发送一个Pull消息的请求给Broker端。Broker端从RocketMQ的文件存储层—Store读取数据之前，会用这些数据先构建一个MessageFilter，然后传给Store。Store从 ConsumeQueue读取到一条记录后，会用它记录的消息tag hash值去做过滤，由于在服务端只是根据hashcode进行判断，无法精确对tag原始字符串进行过滤，故在消息消费端拉取到消息后，还需要对消息的原始tag字符串进行比对，如果不同，则丢弃该消息，不进行消息消费。</p>
<p>(2) SQL92的过滤方式：这种方式的大致做法和上面的Tag过滤方式一样，只是在Store层的具体过滤过程不太一样，真正的 SQL expression 的构建和执行由rocketmq-filter模块负责的。每次过滤都去执行SQL表达式会影响效率，所以RocketMQ使用了BloomFilter避免了每次都去执行。SQL92的表达式上下文为消息的属性。</p>
<h3 id="3-4-负载均衡"><a href="#3-4-负载均衡" class="headerlink" title="3.4 负载均衡"></a>3.4 负载均衡</h3><p>RocketMQ中的负载均衡都在Client端完成，具体来说的话，主要可以分为Producer端发送消息时候的负载均衡和Consumer端订阅消息的负载均衡。</p>
<h4 id="3-4-1-Producer的负载均衡"><a href="#3-4-1-Producer的负载均衡" class="headerlink" title="3.4.1 Producer的负载均衡"></a>3.4.1 Producer的负载均衡</h4><p>Producer端在发送消息的时候，会先根据Topic找到指定的TopicPublishInfo，在获取了TopicPublishInfo路由信息后，RocketMQ的客户端在默认方式下selectOneMessageQueue()方法会从TopicPublishInfo中的messageQueueList中选择一个队列（MessageQueue）进行发送消息。具体的容错策略均在MQFaultStrategy这个类中定义。这里有一个sendLatencyFaultEnable开关变量，如果开启，在随机递增取模的基础上，再过滤掉not available的Broker代理。所谓的”latencyFaultTolerance”，是指对之前失败的，按一定的时间做退避。例如，如果上次请求的latency超过550Lms，就退避3000Lms；超过1000L，就退避60000L；如果关闭，采用随机递增取模的方式选择一个队列（MessageQueue）来发送消息，latencyFaultTolerance机制是实现消息发送高可用的核心关键所在。</p>
<h4 id="3-4-2-Consumer的负载均衡"><a href="#3-4-2-Consumer的负载均衡" class="headerlink" title="3.4.2 Consumer的负载均衡"></a>3.4.2 Consumer的负载均衡</h4><p>在RocketMQ中，Consumer端的两种消费模式（Push/Pull）都是基于拉模式来获取消息的，而在Push模式只是对pull模式的一种封装，其本质实现为消息拉取线程在从服务器拉取到一批消息后，然后提交到消息消费线程池后，又“马不停蹄”的继续向服务器再次尝试拉取消息。如果未拉取到消息，则延迟一下又继续拉取。在两种基于拉模式的消费方式（Push/Pull）中，均需要Consumer端知道从Broker端的哪一个消息队列中去获取消息。因此，有必要在Consumer端来做负载均衡，即Broker端中多个MessageQueue分配给同一个ConsumerGroup中的哪些Consumer消费。</p>
<p>1、Consumer端的心跳包发送</p>
<p>在Consumer启动后，它就会通过定时任务不断地向RocketMQ集群中的所有Broker实例发送心跳包（其中包含了，消息消费分组名称、订阅关系集合、消息通信模式和客户端id的值等信息）。Broker端在收到Consumer的心跳消息后，会将它维护在ConsumerManager的本地缓存变量—consumerTable，同时并将封装后的客户端网络通道信息保存在本地缓存变量—channelInfoTable中，为之后做Consumer端的负载均衡提供可以依据的元数据信息。</p>
<p>2、Consumer端实现负载均衡的核心类—RebalanceImpl</p>
<p>在Consumer实例的启动流程中的启动MQClientInstance实例部分，会完成负载均衡服务线程—RebalanceService的启动（每隔20s执行一次）。通过查看源码可以发现，RebalanceService线程的run()方法最终调用的是RebalanceImpl类的rebalanceByTopic()方法，该方法是实现Consumer端负载均衡的核心。这里，rebalanceByTopic()方法会根据消费者通信类型为“广播模式”还是“集群模式”做不同的逻辑处理。这里主要来看下集群模式下的主要处理流程：</p>
<p>(1) 从rebalanceImpl实例的本地缓存变量—topicSubscribeInfoTable中，获取该Topic主题下的消息消费队列集合（mqSet）；</p>
<p>(2) 根据topic和consumerGroup为参数调用mQClientFactory.findConsumerIdList()方法向Broker端发送获取该消费组下消费者Id列表的RPC通信请求（Broker端基于前面Consumer端上报的心跳包数据而构建的consumerTable做出响应返回，业务请求码：GET_CONSUMER_LIST_BY_GROUP）；</p>
<p>(3) 先对Topic下的消息消费队列、消费者Id排序，然后用消息队列分配策略算法（默认为：消息队列的平均分配算法），计算出待拉取的消息队列。这里的平均分配算法，类似于分页的算法，将所有MessageQueue排好序类似于记录，将所有消费端Consumer排好序类似页数，并求出每一页需要包含的平均size和每个页面记录的范围range，最后遍历整个range而计算出当前Consumer端应该分配到的记录（这里即为：MessageQueue）。</p>
<p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_design_8.png" alt="rocketmq_design_8"></p>
<p>(4) 然后，调用updateProcessQueueTableInRebalance()方法，具体的做法是，先将分配到的消息队列集合（mqSet）与processQueueTable做一个过滤比对。</p>
<p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_design_9.png" alt="rocketmq_design_9"></p>
<ul>
<li>上图中processQueueTable标注的红色部分，表示与分配到的消息队列集合mqSet互不包含。将这些队列设置Dropped属性为true，然后查看这些队列是否可以移除出processQueueTable缓存变量，这里具体执行removeUnnecessaryMessageQueue()方法，即每隔1s 查看是否可以获取当前消费处理队列的锁，拿到的话返回true。如果等待1s后，仍然拿不到当前消费处理队列的锁则返回false。如果返回true，则从processQueueTable缓存变量中移除对应的Entry；</li>
<li>上图中processQueueTable的绿色部分，表示与分配到的消息队列集合mqSet的交集。判断该ProcessQueue是否已经过期了，在Pull模式的不用管，如果是Push模式的，设置Dropped属性为true，并且调用removeUnnecessaryMessageQueue()方法，像上面一样尝试移除Entry；</li>
</ul>
<p>最后，为过滤后的消息队列集合（mqSet）中的每个MessageQueue创建一个ProcessQueue对象并存入RebalanceImpl的processQueueTable队列中（其中调用RebalanceImpl实例的computePullFromWhere(MessageQueue mq)方法获取该MessageQueue对象的下一个进度消费值offset，随后填充至接下来要创建的pullRequest对象属性中），并创建拉取请求对象—pullRequest添加到拉取列表—pullRequestList中，最后执行dispatchPullRequest()方法，将Pull消息的请求对象PullRequest依次放入PullMessageService服务线程的阻塞队列pullRequestQueue中，待该服务线程取出后向Broker端发起Pull消息的请求。其中，可以重点对比下，RebalancePushImpl和RebalancePullImpl两个实现类的dispatchPullRequest()方法不同，RebalancePullImpl类里面的该方法为空，这样子也就回答了上一篇中最后的那道思考题了。</p>
<p>消息消费队列在同一消费组不同消费者之间的负载均衡，其核心设计理念是在一个消息消费队列在同一时间只允许被同一消费组内的一个消费者消费，一个消息消费者能同时消费多个消息队列。</p>
<h3 id="3-5-事务消息"><a href="#3-5-事务消息" class="headerlink" title="3.5 事务消息"></a>3.5 事务消息</h3><p>Apache RocketMQ在4.3.0版中已经支持分布式事务消息，这里RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。</p>
<p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_design_10.png" alt="rocketmq_design_10"></p>
<h4 id="3-5-1-RocketMQ事务消息流程概要"><a href="#3-5-1-RocketMQ事务消息流程概要" class="headerlink" title="3.5.1 RocketMQ事务消息流程概要"></a>3.5.1 RocketMQ事务消息流程概要</h4><p>上图说明了事务消息的大致方案，其中分为两个流程：正常事务消息的发送及提交、事务消息的补偿流程。</p>
<p>1.事务消息发送及提交：</p>
<p>(1) 发送消息（half消息）。</p>
<p>(2) 服务端响应消息写入结果。</p>
<p>(3) 根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p>
<p>(4) 根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p>
<p>2.补偿流程：</p>
<p>(1) 对没有Commit/Rollback的事务消息（pending状态的消息），从服务端发起一次“回查”</p>
<p>(2) Producer收到回查消息，检查回查消息对应的本地事务的状态</p>
<p>(3) 根据本地事务状态，重新Commit或者Rollback</p>
<p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p>
<h4 id="3-5-2-RocketMQ事务消息设计"><a href="#3-5-2-RocketMQ事务消息设计" class="headerlink" title="3.5.2 RocketMQ事务消息设计"></a>3.5.2 RocketMQ事务消息设计</h4><p>1.事务消息在一阶段对用户不可见</p>
<p>在RocketMQ事务消息的主要流程中，一阶段的消息如何对用户不可见。其中，事务消息相对普通消息最大的特点就是一阶段发送的消息对用户是不可见的。那么，如何做到写入消息但是对用户不可见呢？RocketMQ事务消息的做法是：如果消息是half消息，将备份原消息的主题与消息消费队列，然后改变主题为RMQ_SYS_TRANS_HALF_TOPIC。由于消费组未订阅该主题，故消费端无法消费half类型的消息，然后RocketMQ会开启一个定时任务，从Topic为RMQ_SYS_TRANS_HALF_TOPIC中拉取消息进行消费，根据生产者组获取一个服务提供者发送回查事务状态请求，根据事务状态来决定是提交或回滚消息。</p>
<p>在RocketMQ中，消息在服务端的存储结构如下，每条消息都会有对应的索引信息，Consumer通过ConsumeQueue这个二级索引来读取消息实体内容，其流程如下：</p>
<p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_design_11.png" alt="rocketmq_design_11"></p>
<p>RocketMQ的具体实现策略是：写入的如果事务消息，对消息的Topic和Queue等属性进行替换，同时将原来的Topic和Queue信息存储到消息的属性中，正因为消息主题被替换，故消息并不会转发到该原主题的消息消费队列，消费者无法感知消息的存在，不会消费。其实改变消息主题是RocketMQ的常用“套路”，回想一下延时消息的实现机制。</p>
<p>2.Commit和Rollback操作以及Op消息的引入</p>
<p>在完成一阶段写入一条对用户不可见的消息后，二阶段如果是Commit操作，则需要让消息对用户可见；如果是Rollback则需要撤销一阶段的消息。先说Rollback的情况。对于Rollback，本身一阶段的消息对用户是不可见的，其实不需要真正撤销消息（实际上RocketMQ也无法去真正的删除一条消息，因为是顺序写文件的）。但是区别于这条消息没有确定状态（Pending状态，事务悬而未决），需要一个操作来标识这条消息的最终状态。RocketMQ事务消息方案中引入了Op消息的概念，用Op消息标识事务消息已经确定的状态（Commit或者Rollback）。如果一条事务消息没有对应的Op消息，说明这个事务的状态还无法确定（可能是二阶段失败了）。引入Op消息后，事务消息无论是Commit或者Rollback都会记录一个Op操作。Commit相对于Rollback只是在写入Op消息前创建Half消息的索引。</p>
<p>3.Op消息的存储和对应关系</p>
<p>RocketMQ将Op消息写入到全局一个特定的Topic中通过源码中的方法—TransactionalMessageUtil.buildOpTopic()；这个Topic是一个内部的Topic（像Half消息的Topic一样），不会被用户消费。Op消息的内容为对应的Half消息的存储的Offset，这样通过Op消息能索引到Half消息进行后续的回查操作。</p>
<p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_design_12.png" alt="rocketmq_design_12"></p>
<p>4.Half消息的索引构建</p>
<p>在执行二阶段Commit操作时，需要构建出Half消息的索引。一阶段的Half消息由于是写到一个特殊的Topic，所以二阶段构建索引时需要读取出Half消息，并将Topic和Queue替换成真正的目标的Topic和Queue，之后通过一次普通消息的写入操作来生成一条对用户可见的消息。所以RocketMQ事务消息二阶段其实是利用了一阶段存储的消息的内容，在二阶段时恢复出一条完整的普通消息，然后走一遍消息写入流程。</p>
<p>5.如何处理二阶段失败的消息？</p>
<p>如果在RocketMQ事务消息的二阶段过程中失败了，例如在做Commit操作时，出现网络问题导致Commit失败，那么需要通过一定的策略使这条消息最终被Commit。RocketMQ采用了一种补偿机制，称为“回查”。Broker端对未确定状态的消息发起回查，将消息发送到对应的Producer端（同一个Group的Producer），由Producer根据消息来检查本地事务的状态，进而执行Commit或者Rollback。Broker端通过对比Half消息和Op消息进行事务消息的回查并且推进CheckPoint（记录那些事务消息的状态是确定的）。</p>
<p>值得注意的是，rocketmq并不会无休止的的信息事务状态回查，默认回查15次，如果15次回查还是无法得知事务状态，rocketmq默认回滚该消息。</p>
<h3 id="3-6-消息查询"><a href="#3-6-消息查询" class="headerlink" title="3.6 消息查询"></a>3.6 消息查询</h3><p>RocketMQ支持按照下面两种维度（“按照Message Id查询消息”、“按照Message Key查询消息”）进行消息查询。</p>
<h4 id="3-6-1-按照MessageId查询消息"><a href="#3-6-1-按照MessageId查询消息" class="headerlink" title="3.6.1   按照MessageId查询消息"></a>3.6.1   按照MessageId查询消息</h4><p>RocketMQ中的MessageId的长度总共有16字节，其中包含了消息存储主机地址（IP地址和端口），消息Commit Log offset。“按照MessageId查询消息”在RocketMQ中具体做法是：Client端从MessageId中解析出Broker的地址（IP地址和端口）和Commit Log的偏移地址后封装成一个RPC请求后通过Remoting通信层发送（业务请求码：VIEW_MESSAGE_BY_ID）。Broker端走的是QueryMessageProcessor，读取消息的过程用其中的 commitLog offset 和 size 去 commitLog 中找到真正的记录并解析成一个完整的消息返回。</p>
<h4 id="3-6-2-按照Message-Key查询消息"><a href="#3-6-2-按照Message-Key查询消息" class="headerlink" title="3.6.2  按照Message Key查询消息"></a>3.6.2  按照Message Key查询消息</h4><p>“按照Message Key查询消息”，主要是基于RocketMQ的IndexFile索引文件来实现的。RocketMQ的索引文件逻辑结构，类似JDK中HashMap的实现。索引文件的具体结构如下：</p>
<p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/rocketmq_design_13.png" alt="rocketmq_design_13"></p>
<p>IndexFile索引文件为用户提供通过“按照Message Key查询消息”的消息索引查询服务，IndexFile文件的存储位置是：$HOME\store\index${fileName}，文件名fileName是以创建时的时间戳命名的，文件大小是固定的，等于40+500W*4+2000W*20= 420000040个字节大小。如果消息的properties中设置了UNIQ_KEY这个属性，就用 topic + “#” + UNIQ_KEY的value作为 key 来做写入操作。如果消息设置了KEYS属性（多个KEY以空格分隔），也会用 topic + “#” + KEY 来做索引。</p>
<p>其中的索引数据包含了Key Hash/CommitLog Offset/Timestamp/NextIndex offset 这四个字段，一共20 Byte。NextIndex offset 即前面读出来的 slotValue，如果有 hash冲突，就可以用这个字段将所有冲突的索引用链表的方式串起来了。Timestamp记录的是消息storeTimestamp之间的差，并不是一个绝对的时间。整个Index File的结构如图，40 Byte 的Header用于保存一些总的统计信息，4*500W的 Slot Table并不保存真正的索引数据，而是保存每个槽位对应的单向链表的头。20*2000W 是真正的索引数据，即一个 Index File 可以保存 2000W个索引。</p>
<p>“按照Message Key查询消息”的方式，RocketMQ的具体做法是，主要通过Broker端的QueryMessageProcessor业务处理器来查询，读取消息的过程就是用topic和key找到IndexFile索引文件中的一条记录，根据其中的commitLog offset从CommitLog文件中读取消息的实体内容。</p>
<h1 id="四、安装"><a href="#四、安装" class="headerlink" title="四、安装"></a>四、安装</h1><h2 id="单实例安装-amp-启动"><a href="#单实例安装-amp-启动" class="headerlink" title="单实例安装&amp;启动"></a>单实例安装&amp;启动</h2><h3 id="1、安装-目录规划"><a href="#1、安装-目录规划" class="headerlink" title="1、安装-目录规划"></a>1、安装-目录规划</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/rocketmq</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载RocketMQ二进制压缩包</span></span><br><span class="line">wget https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.9.3/rocketmq-all-4.9.3-source-release.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装unzip解压</span></span><br><span class="line">yum install -y unzip</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">unzip rocketmq-all-4.9.3-source-release.zip</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重命名</span></span><br><span class="line">mv rocketmq-all-4.9.3-source-release.zip rocketmq-4.9.3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 为了替换版本方便，创建软链</span></span><br><span class="line">ln -s /usr/rocketmq/rocketmq-4.9.3 /usr/local/rocketmq</span><br></pre></td></tr></table></figure>

<h3 id="2、启动-amp-停止NameServer、Broker"><a href="#2、启动-amp-停止NameServer、Broker" class="headerlink" title="2、启动&amp;停止NameServer、Broker"></a>2、启动&amp;停止NameServer、Broker</h3><p>先启动NameServer，然后启动Broker，并向NameServer注册自己</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## NameServer ###################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动之前根据本机内存大小，看看是否需要修改 JAVA_OPT 的内存设置</span></span><br><span class="line">cd /usr/rocketmq/rocketmq-4.9.3/bin</span><br><span class="line">sed -i 's/-Xms4g -Xmx4g -Xmn2g/-Xms256m -Xmx256m -Xmn128m/g' ./runserver.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动NameServer</span></span><br><span class="line">nohup /usr/rocketmq/rocketmq-4.9.3/bin/mqnamesrv &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看NameServer启动日志</span></span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭 NameServer</span></span><br><span class="line">/usr/rocketmq/rocketmq-4.9.3/bin/mqshutdown namesrv</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################## Broker ###################</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动之前根据本机内存大小，看看是否需要修改 JAVA_OPT 的内存设置</span></span><br><span class="line">cd /usr/rocketmq/rocketmq-4.9.3/bin</span><br><span class="line">sed -i 's/-Xms8g -Xmx8g -Xmn4g/-Xms256m -Xmx256m -Xmn128m/g' ./runbroker.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 Broker</span></span><br><span class="line">nohup /usr/rocketmq/rocketmq-4.9.3/bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 我的测试版本4.7.1，需要加上autoCreateTopicEnable=<span class="literal">true</span> 参数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 否则在测试发送消息的时候会报异常</span></span><br><span class="line">nohup /usr/rocketmq/rocketmq-4.9.3/bin/mqbroker -n localhost:9876 autoCreateTopicEnable=true &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看 Broker 启动日志</span></span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 2.关闭Broker</span></span></span><br><span class="line">/usr/rocketmq/rocketmq-4.9.3/bin/mqshutdown broker</span><br></pre></td></tr></table></figure>

<h3 id="3、验证"><a href="#3、验证" class="headerlink" title="3、验证"></a>3、验证</h3><p>查看JAVA进程，是否存在NamesrvStartup、BrokerStartup， 如果没有则查看LOG日志查找问题。</p>
<p><img src="/2022/04/20/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-3-RocketMQ/image-20220506113146187.png" alt></p>
<p>发送和接收消息测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/rocketmq/rocketmq-4.9.3/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建topic</span></span><br><span class="line">sh mqadmin updateTopic -n localhost:9876 -b localhost:10911 -t TopicTest</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置临时环境变量</span></span><br><span class="line">export NAMESRV_ADDR=localhost:9876</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启自带的生产者</span></span><br><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.Producer</span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启自带的消费者</span></span><br><span class="line">sh tools.sh org.apache.rocketmq.example.quickstart.Consumer</span><br></pre></td></tr></table></figure>

<h3 id="4、排坑"><a href="#4、排坑" class="headerlink" title="4、排坑"></a>4、排坑</h3><p><strong>设置broker的ip地址，需要在启动的时候导入配置文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入rocketmq根目录</span></span><br><span class="line">cd /usr/rocketmq/rocketmq-4.9.3</span><br><span class="line"><span class="meta">#</span><span class="bash">启动 mqnamesrv</span></span><br><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编写配置文件，并写好配置</span></span><br><span class="line">echo "brokerIP1=192.168.18.24" &gt;&gt; conf/broker.properties</span><br><span class="line"><span class="meta">#</span><span class="bash">重点：mrbroker 启动时通过 -c 加载配置文件</span></span><br><span class="line">nohup sh bin/mqbroker -n 192.168.18.24:9876 -c /usr/rocketmq/rocketmq-4.9.3/conf/broker.conf &amp;</span><br></pre></td></tr></table></figure>

<p><strong>原因：</strong></p>
<p>RocketMQ的broker启动类org.apache.rocketmq.broker.BrokerStartup启动的时候会读取代码中的默认配置，关于 broker的配置在org.apache.rocketmq.common.BrokerConfig中，根据源代码可以得知，broker使用的默认IP为本机Ip，brokerIP1 = RemotingUtil.getLocalAddress();得到选取ip的思路是，遍历本地的所有网卡ip，过滤掉 “127.0” 和“192.168”开头的ip地址然后得到第一个ip，为本机ip。</p>
<h3 id="5、RocketMQ-Web管理页面"><a href="#5、RocketMQ-Web管理页面" class="headerlink" title="5、RocketMQ Web管理页面"></a>5、RocketMQ Web管理页面</h3><blockquote>
<p>rocketmq提供多种管理方式,命令行和界面等；但是rocketmq默认不带可视化控制台，需要去单独编译apache提供一个开源的扩展项目 <a href="https://github.com/apache/rocketmq-externals" target="_blank" rel="noopener">https://github.com/apache/rocketmq-externals</a></p>
</blockquote>
<p>1、git clone源码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/apache/rocketmq-externals</span><br></pre></td></tr></table></figure>

<p>2、进入到 rocketmq-console 目录，执行 maven 编译打包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入目录</span></span><br><span class="line">cd rocketmq-externals</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换分支</span></span><br><span class="line">git checkoutrelease-rocketmq-console-1.0.0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行maven编辑打包</span></span><br><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>

<p>3、启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> jar包在target目录下面，你可以copy到其他目录去运行</span></span><br><span class="line">java -jar rocketmq-console-ng-1.0.0.jar --server.port=8081 --rocketmq.config.namesrvAddr=192.168.100.201:9876 &gt; /usr/rocketmq/rocketmq-externals/rocketmq-console/logs/mq-console.log 2&gt;&amp;1 &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> --server.port springboot内置tomcat的端口号，默认8080；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --rocketmq.config.namesrvAddr nameserver的地址</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>消息中间件</category>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>RocketMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>微服务架构-9-Spring-Cloud-Netflix-Hystrix</title>
    <url>/2021/07/06/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84-9-Spring-Cloud-Netflix-Hystrix/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>微服务架构</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>微服务架构</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>消息中间件-2-kafka</title>
    <url>/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/</url>
    <content><![CDATA[<h1 id="apache-kafka"><a href="#apache-kafka" class="headerlink" title="apache kafka"></a>apache kafka</h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>kafka是最初由Linkedin公司开发，使用Scala语言编写，Kafka是一个分布式、分区的、多副本的、多订阅者的日志系统(分布式MQ系统)，可以用于web/nginx日志，搜索日志，监控日志，访问日志等等。kafka目前支持多种客户端语言：java，python，c++，php等等。</p>
<h2 id="二、总体架构"><a href="#二、总体架构" class="headerlink" title="二、总体架构"></a>二、总体架构</h2><p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220413183641716.png" alt="整体架构"></p>
<p><strong>kafka名词解释和工作方式：</strong></p>
<ul>
<li>Broker ：一台kafka服务器就是一个broker。一个集群由多个broker组成。一个broker可以容纳多个topic。</li>
<li>Topic ：可以理解为一个队列。</li>
<li>Partition：为了实现扩展性，一个非常大的topic可以分布到多个broker（即服务器）上，一个topic可以分为多个partition，每个partition是一个有序的队列。partition中的每条消息都会被分配一个有序的id（offset）。kafka只保证按一个partition中的顺序将消息发给consumer，不保证一个topic的整体（多个partition间）的顺序。</li>
<li>Producer ：消息生产者，就是向kafka broker发消息的客户端。</li>
<li>Consumer ：消息消费者，向kafka broker取消息的客户端。</li>
<li>Consumer Group （CG）：这是kafka用来实现一个topic消息的广播（发给所有的consumer）和单播（发给任意一个consumer）的手段。一个topic可以有多个CG。topic的消息会复制（不是真的复制，是概念上的）到所有的CG，但每个CG只会把消息发给该CG中的一个consumer。如果需要实现广播，只要每个consumer有一个独立的CG就可以了。要实现单播只要所有的consumer在同一个CG。用CG还可以将consumer进行自由的分组而不需要多次发送消息到不同的topic。</li>
<li>Segment：partition物理上由多个segment组成。</li>
<li>Offset：每个partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到partition中。partition中的每个消息都有一个连续的序列号叫做offset，用于partition唯一标识一条消息。</li>
</ul>
<p><strong>kafka特性：</strong></p>
<ul>
<li>通过O(1)的磁盘数据结构提供消息的持久化，这种结构对于即使数以TB的消息存储也能够保持长时间的稳定性能。</li>
<li>高吞吐量：即使是非常普通的硬件kafka也可以支持每秒数十万的消息。</li>
<li>支持同步和异步复制两种HA</li>
<li>Consumer客户端pull，随机读，利用sendfile系统调用，zero-copy ，批量拉数据</li>
<li>消费状态保存在客户端</li>
<li>消息存储顺序写</li>
<li>数据迁移、扩容对用户透明</li>
<li>支持Hadoop并行数据加载。</li>
<li>支持online和offline的场景。</li>
<li>持久化：通过将数据持久化到硬盘以及replication防止数据丢失。</li>
<li>scale out：无需停机即可扩展机器。</li>
<li>定期删除机制，支持设定partitions的segment file保留时间。</li>
</ul>
<h2 id="三、安装"><a href="#三、安装" class="headerlink" title="三、安装"></a>三、安装</h2><h3 id="Zookeeper安装"><a href="#Zookeeper安装" class="headerlink" title="Zookeeper安装"></a>Zookeeper安装</h3><p>ZooKeeper是一个开源的分布式框架，提供了协调分布式应用的基本服务。它向外部应用暴露一组通用服务——分布式同步（Distributed Synchronization）、命名服务（Naming Service）、集群维护（Group Maintenance）等，简化分布式应用协调及其管理的难度。</p>
<p>它是Google的Chubby一个开源的实现。它本身可以搭建成一个集群，这个zk集群用来对应用程序集群进行管理，监视应用程序集群中各个节点的状态，并根据应用程序集群中各个节点提交的反馈信息决定下一步的合理操作。</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/clip_image001.jpg" alt="ZooKeeper Service"></p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://archive.apache.org/dist/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz" target="_blank" rel="noopener">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz</a></p>
<h4 id="安装并启动"><a href="#安装并启动" class="headerlink" title="安装并启动"></a>安装并启动</h4><p><strong>1.部署3个节点的Zookeeper伪分布式集群</strong></p>
<p>在同一台服务器上，部署一个3个ZooKeeper节点组成的集群，这样的集群叫伪分布式集群，而如果集群中的3个节点分别部署在3个服务器上，那么这种集群就叫真正的分布式集群。</p>
<p>这里，记录一下搭建一个3节点的伪分布式集群的过程，真正的分布式集群的搭建过程和伪分布式的过程类似，稍有不同，真正的分布式集群和伪分布式集群不一样的地方在于配置文件。</p>
<p>1、clientport端口各个节点一样就行</p>
<p>2、server.1=127.0.0.1:8880:7770中的ip要修改成对应的server的ip，后边的两个端口号不需要不同，各个节点都一样就可以了。其他地方伪分布式和真正分布式都是一样的。</p>
<p><strong>2.解压Zookeeper安装包</strong></p>
<p>首先在要安装集群的目录中解压zk。建立一个集群安装的目录，就叫zookeeper。其次，在这个目录的下面解压三份ZooKeeper，形成3个节点，每一个目录中的ZooKeeper就代表一个节点。</p>
<p>这样就形成了如下的安装目录结构：</p>
<p>/usr/zookeeper</p>
<p>​     |—-zookeeper-1/</p>
<p>​     |—-zookeeper-2/</p>
<p>​     |—-zookeeper-3/</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf zookeeper-3.4.10.tar.gz</span><br></pre></td></tr></table></figure>

<p>之后把解压的zk复制出三份来，分别命名为zookeeper-1，zookeeper-2，zookeeper-3，这三个目录中的zk就当成是集群中的3个节点。</p>
<p><strong>3.为每个节点建立data目录、logs目录和myid文件</strong></p>
<p>在3个节点目录中分别建立data目录、logs目录和myid文件。</p>
<p>下面是zookeeper-1上的：</p>
<p>新建目录data：mkdir data</p>
<p>新建目录logs：mkdir logs</p>
<p>新建文件myid：touch data/myid</p>
<p>myid文件的内容是节点在集群中的编号，zookeeper-1节点的编号就写成1，后边的zookeeper-2的编号是2，zookeeper-3的编号就是3。</p>
<p>按照同样的方法，依次在zookeeper-2和zookeeper-3上都建立以上目录和文件。</p>
<p><strong>4.为每个节点创建配置文件</strong></p>
<p>在zookeeper-1下新增配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd conf/</span><br><span class="line">cp zoo_sample.cfg zoo.cfg</span><br></pre></td></tr></table></figure>

<p>配置文件zoo.cfg的内容如下：</p>
<ul>
<li>修改数据目录，分别是/usr/zookeeper/zookeeper-1/data，/usr/zookeeper/zookeeper-2/data，/usr/zookeeper/zookeeper-3/data</li>
<li>修改log目录，分别是/usr/zookeeper/zookeeper-1/logs，/usr/zookeeper/zookeeper-2/logs，/usr/zookeeper/zookeeper-3/logs</li>
<li>修改端口号，分别是2181，2182，2183</li>
<li>修改集群服务地址：server.1=127.0.0.1:8880:7770 server.2=127.0.0.1:8881:7771 server.3=127.0.0.1:8882:7772</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line"># zookeeper中使用的基本时间单位，毫秒值，比如可以设为1000，那么基本时间单位就是1000ms，也就是1s。</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"># The number of ticks that the initial</span><br><span class="line"># synchronization phase can take</span><br><span class="line"># zookeeper集群中的包含多台server，其中一台为leader，集群中其余的server为follower，initLimit参数配置初始化连接时，</span><br><span class="line"># follower和leader之间的最长心跳时间。如果该参数设置为5，就说明时间限制为5倍tickTime，即5*1000&#x3D;5000ms&#x3D;5s。</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"># The number of ticks that can pass between</span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line"># 该参数配置leader和follower之间发送消息，请求和应答的最大时间长度。如果该参数设置为2，说明时间限制为2倍tickTime，即2000ms。</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just</span><br><span class="line"># example sakes.</span><br><span class="line"># 数据目录. 可以是任意目录，一般是节点安装目录下data目录。</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;zookeeper&#x2F;zookeeper-1&#x2F;data</span><br><span class="line"># log目录, 同样可以是任意目录，一般是节点安装目录下的logs目录。如果没有设置该参数，将使用和dataDir相同的设置。</span><br><span class="line">dataLogDir&#x3D;&#x2F;usr&#x2F;zookeeper&#x2F;zookeeper-1&#x2F;logs</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line"># 监听client连接的端口号。</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the</span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># https:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br><span class="line"></span><br><span class="line">## Metrics Providers</span><br><span class="line">#</span><br><span class="line"># https:&#x2F;&#x2F;prometheus.io Metrics Exporter</span><br><span class="line">#metricsProvider.className&#x3D;org.apache.zookeeper.metrics.prometheus.PrometheusMetricsProvider</span><br><span class="line">#metricsProvider.httpHost&#x3D;0.0.0.0</span><br><span class="line">#metricsProvider.httpPort&#x3D;7000</span><br><span class="line">#metricsProvider.exportJvmInfo&#x3D;true</span><br><span class="line"></span><br><span class="line"># server.X&#x3D;A:B:C 其中X是一个数字, 表示这是第几号server，它的值和myid文件中的值对应。A是该server所在的IP地址。B是配置该server和集群中的leader交换消息所使用的端口。C配置选举leader时所使用的端口。由于配置的是伪集群模式，所以各个server的B, C参数必须不同，如果是真正分布式集群，那么B和C在各个节点上可以相同，因为即使相同由于节点处于不同的服务器也不会导致端口冲突。</span><br><span class="line">server.1&#x3D;127.0.0.1:8880:7770</span><br><span class="line">server.2&#x3D;127.0.0.1:8881:7771</span><br><span class="line">server.3&#x3D;127.0.0.1:8882:7772</span><br></pre></td></tr></table></figure>

<p>用同样的方法，在zookeeper-2和zookeeper-3的相应位置创建zoo.cfg，文件内容复制zookeeper-1的zoo.cfg。只不过需要改动clientport、dataDir、dataLogDir三个配置项，zookeeper-2的clientport改为2182，zookeeper-3的clientport改为2183，而dataDir和dataLogDir都修改为相应的目录，就好了。</p>
<p><strong>5.启动zk集群</strong></p>
<p>进入zookeeper集群的第一个节点zookeeper0的bin目录下，启动服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd zookeeper-1</span><br><span class="line">./bin/zkServer.sh start</span><br><span class="line">cd zookeeper-2</span><br><span class="line">./bin/zkServer.sh start</span><br><span class="line">cd zookeeper-3</span><br><span class="line">./bin/zkServer.sh start</span><br></pre></td></tr></table></figure>

<p>然后，按照同样的方法，依次启动zookeeper-1和zookeeper-2的服务。这样zookeeper集群的3个节点都启动起来了。</p>
<p><strong>解决Zookeeper出现Error: Could not find or load main class org.apache.zookeeper.server.quorum.QuorumPeerMain问题</strong></p>
<p>需要将解压的tar包重新打包一次</p>
<p>下载maven并解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://mirrors.hust.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz</span><br><span class="line">tar -zxvf apache-maven-3.6.3-bin.tar.gz</span><br></pre></td></tr></table></figure>

<p>设置maven环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export MAVEN_HOME&#x3D;&#x2F;home&#x2F;lib&#x2F;apache-maven-3.6.3</span><br><span class="line">export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$MAVEN_HOME&#x2F;bin</span><br></pre></td></tr></table></figure>

<p>启用环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source /ect/profile</span><br></pre></td></tr></table></figure>

<p>打包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/zookeeper/zookeeper-1</span><br><span class="line">mvn package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure>

<p>注意在打包的时候可能会消耗几分钟，请一定耐心等待</p>
<p>重启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/zkServer.sh restart</span><br></pre></td></tr></table></figure>

<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 启动ZK服务: ./bin/zkServer.sh start</span><br><span class="line">2. 查看ZK服务状态: ./bin/zkServer.sh status</span><br><span class="line">3. 停止ZK服务: ./bin/zkServer.sh stop</span><br><span class="line">4. 重启ZK服务: ./bin/zkServer.sh restart </span><br><span class="line">5. 连接服务器: ./zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure>

<h3 id="kafka安装"><a href="#kafka安装" class="headerlink" title="kafka安装"></a>kafka安装</h3><h4 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h4><p><a href="https://www.apache.org/dyn/closer.cgi?path=/kafka/2.1.0/kafka_2.12-2.1.0.tgz" target="_blank" rel="noopener">https://www.apache.org/dyn/closer.cgi?path=/kafka/2.1.0/kafka_2.12-2.1.0.tgz</a></p>
<h4 id="安装并启动-1"><a href="#安装并启动-1" class="headerlink" title="安装并启动"></a>安装并启动</h4><p>1、解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf kafka_2.13-3.1.0.tgz</span><br></pre></td></tr></table></figure>

<p>2、复制server.properties多份</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp server.properties server-1.properties</span><br><span class="line">cp server.properties server-2.properties</span><br><span class="line">cp server.properties server-3.properties</span><br></pre></td></tr></table></figure>

<p>3、修改配置文件：</p>
<ul>
<li>每个配置文件修改不同的broker.id，分别是broker.id=1，broker.id=2，broker.id=3</li>
<li>设置日志目录，分别是kafka-logs-1，kafka-logs-2，kafka-logs-3</li>
<li>设置服务监听地址，分别是listeners=PLAINTEXT://:9093，listeners=PLAINTEXT://:9094，listeners=PLAINTEXT://:9095</li>
<li>设置zookeeper集群连接地址，localhost:2181,localhost:2182,localhost:2183</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Licensed to the Apache Software Foundation (ASF) under one or more</span></span><br><span class="line"><span class="comment"># contributor license agreements.  See the NOTICE file distributed with</span></span><br><span class="line"><span class="comment"># this work for additional information regarding copyright ownership.</span></span><br><span class="line"><span class="comment"># The ASF licenses this file to You under the Apache License, Version 2.0</span></span><br><span class="line"><span class="comment"># (the "License"); you may not use this file except in compliance with</span></span><br><span class="line"><span class="comment"># the License.  You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an "AS IS" BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># see kafka.server.KafkaConfig for additional details and defaults</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Server Basics #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The id of the broker. This must be set to a unique integer for each broker.</span></span><br><span class="line"><span class="comment"># 配置broker ID，集群中每个节点的名称，这一名称是唯一且永久的</span></span><br><span class="line"><span class="meta">broker.id</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Socket Server Settings #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The address the socket server listens on. It will get the value returned from</span></span><br><span class="line"><span class="comment"># java.net.InetAddress.getCanonicalHostName() if not configured.</span></span><br><span class="line"><span class="comment">#   FORMAT:</span></span><br><span class="line"><span class="comment">#     listeners = listener_name://host_name:port</span></span><br><span class="line"><span class="comment">#   EXAMPLE:</span></span><br><span class="line"><span class="comment">#     listeners = PLAINTEXT://your.host.name:9092</span></span><br><span class="line"><span class="attr">listeners</span>=<span class="string">PLAINTEXT://192.168.100.201:9093</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hostname and port the broker will advertise to producers and consumers. If not set,</span></span><br><span class="line"><span class="comment"># it uses the value for "listeners" if configured.  Otherwise, it will use the value</span></span><br><span class="line"><span class="comment"># returned from java.net.InetAddress.getCanonicalHostName().</span></span><br><span class="line"><span class="comment">#advertised.listeners=PLAINTEXT://your.host.name:9092</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Maps listener names to security protocols, the default is for them to be the same. See the config documentation for more details</span></span><br><span class="line"><span class="comment">#listener.security.protocol.map=PLAINTEXT:PLAINTEXT,SSL:SSL,SASL_PLAINTEXT:SASL_PLAINTEXT,SASL_SSL:SASL_SSL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of threads that the server uses for receiving requests from the network and sending responses to the network</span></span><br><span class="line"><span class="meta">num.network.threads</span>=<span class="string">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of threads that the server uses for processing requests, which may include disk I/O</span></span><br><span class="line"><span class="meta">num.io.threads</span>=<span class="string">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The send buffer (SO_SNDBUF) used by the socket server</span></span><br><span class="line"><span class="meta">socket.send.buffer.bytes</span>=<span class="string">102400</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The receive buffer (SO_RCVBUF) used by the socket server</span></span><br><span class="line"><span class="meta">socket.receive.buffer.bytes</span>=<span class="string">102400</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The maximum size of a request that the socket server will accept (protection against OOM)</span></span><br><span class="line"><span class="meta">socket.request.max.bytes</span>=<span class="string">104857600</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Log Basics #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A comma separated list of directories under which to store log files</span></span><br><span class="line"><span class="comment"># 配置日志目录</span></span><br><span class="line"><span class="meta">log.dirs</span>=<span class="string">./../kafka-logs-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The default number of log partitions per topic. More partitions allow greater</span></span><br><span class="line"><span class="comment"># parallelism for consumption, but this will also result in more files across</span></span><br><span class="line"><span class="comment"># the brokers.</span></span><br><span class="line"><span class="meta">num.partitions</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of threads per data directory to be used for log recovery at startup and flushing at shutdown.</span></span><br><span class="line"><span class="comment"># This value is recommended to be increased for installations with data dirs located in RAID array.</span></span><br><span class="line"><span class="meta">num.recovery.threads.per.data.dir</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Internal Topic Settings  #############################</span></span><br><span class="line"><span class="comment"># The replication factor for the group metadata internal topics "__consumer_offsets" and "__transaction_state"</span></span><br><span class="line"><span class="comment"># For anything other than development testing, a value greater than 1 is recommended to ensure availability such as 3.</span></span><br><span class="line"><span class="meta">offsets.topic.replication.factor</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">transaction.state.log.replication.factor</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">transaction.state.log.min.isr</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Log Flush Policy #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Messages are immediately written to the filesystem but by default we only fsync() to sync</span></span><br><span class="line"><span class="comment"># the OS cache lazily. The following configurations control the flush of data to disk.</span></span><br><span class="line"><span class="comment"># There are a few important trade-offs here:</span></span><br><span class="line"><span class="comment">#    1. Durability: Unflushed data may be lost if you are not using replication.</span></span><br><span class="line"><span class="comment">#    2. Latency: Very large flush intervals may lead to latency spikes when the flush does occur as there will be a lot of data to flush.</span></span><br><span class="line"><span class="comment">#    3. Throughput: The flush is generally the most expensive operation, and a small flush interval may lead to excessive seeks.</span></span><br><span class="line"><span class="comment"># The settings below allow one to configure the flush policy to flush data after a period of time or</span></span><br><span class="line"><span class="comment"># every N messages (or both). This can be done globally and overridden on a per-topic basis.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The number of messages to accept before forcing a flush of data to disk</span></span><br><span class="line"><span class="comment">#log.flush.interval.messages=10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The maximum amount of time a message can sit in a log before we force a flush</span></span><br><span class="line"><span class="comment">#log.flush.interval.ms=1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Log Retention Policy #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The following configurations control the disposal of log segments. The policy can</span></span><br><span class="line"><span class="comment"># be set to delete segments after a period of time, or after a given size has accumulated.</span></span><br><span class="line"><span class="comment"># A segment will be deleted whenever *either* of these criteria are met. Deletion always happens</span></span><br><span class="line"><span class="comment"># from the end of the log.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The minimum age of a log file to be eligible for deletion due to age</span></span><br><span class="line"><span class="meta">log.retention.hours</span>=<span class="string">168</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A size-based retention policy for logs. Segments are pruned from the log unless the remaining</span></span><br><span class="line"><span class="comment"># segments drop below log.retention.bytes. Functions independently of log.retention.hours.</span></span><br><span class="line"><span class="comment">#log.retention.bytes=1073741824</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The maximum size of a log segment file. When this size is reached a new log segment will be created.</span></span><br><span class="line"><span class="meta">log.segment.bytes</span>=<span class="string">1073741824</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The interval at which log segments are checked to see if they can be deleted according</span></span><br><span class="line"><span class="comment"># to the retention policies</span></span><br><span class="line"><span class="meta">log.retention.check.interval.ms</span>=<span class="string">300000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Zookeeper #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Zookeeper connection string (see zookeeper docs for details).</span></span><br><span class="line"><span class="comment"># This is a comma separated host:port pairs, each corresponding to a zk</span></span><br><span class="line"><span class="comment"># server. e.g. "127.0.0.1:3000,127.0.0.1:3001,127.0.0.1:3002".</span></span><br><span class="line"><span class="comment"># You can also append an optional chroot string to the urls to specify the</span></span><br><span class="line"><span class="comment"># root directory for all kafka znodes.</span></span><br><span class="line"><span class="comment"># 配置zookeeper集群地址</span></span><br><span class="line"><span class="meta">zookeeper.connect</span>=<span class="string">localhost:2181,localhost:2182,localhost:2183</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Timeout in ms for connecting to zookeeper</span></span><br><span class="line"><span class="meta">zookeeper.connection.timeout.ms</span>=<span class="string">18000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Group Coordinator Settings #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The following configuration specifies the time, in milliseconds, that the GroupCoordinator will delay the initial consumer rebalance.</span></span><br><span class="line"><span class="comment"># The rebalance will be further delayed by the value of group.initial.rebalance.delay.ms as new members join the group, up to a maximum of max.poll.interval.ms.</span></span><br><span class="line"><span class="comment"># The default value for this is 3 seconds.</span></span><br><span class="line"><span class="comment"># We override this to 0 here as it makes for a better out-of-the-box experience for development and testing.</span></span><br><span class="line"><span class="comment"># However, in production environments the default value of 3 seconds is more suitable as this will help to avoid unnecessary, and potentially expensive, rebalances during application startup.</span></span><br><span class="line"><span class="meta">group.initial.rebalance.delay.ms</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure>

<p>4、启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-server-start.sh -daemon config/server-1.properties</span><br><span class="line">./bin/kafka-server-start.sh -daemon config/server-2.properties</span><br><span class="line">./bin/kafka-server-start.sh -daemon config/server-3.properties</span><br></pre></td></tr></table></figure>

<blockquote>
<p>kafk启动失败解决方案：删除配置的log目录并重新启动</p>
</blockquote>
<h4 id="创建topic"><a href="#创建topic" class="headerlink" title="创建topic"></a>创建topic</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个topic，分区数为1，副本数为1。注意，副本数不可超过集群节点数量，否则会报错</span></span><br><span class="line">./bin/kafka-topics.sh --create --topic test --bootstrap-server 192.168.100.201:9093 --partitions 1 --replication-factor 1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看创建的topic列表</span></span><br><span class="line">./bin/kafka-topics.sh --bootstrap-server 192.168.100.201:9093 --list</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看topic详细信息</span></span><br><span class="line">./bin/kafka-topics.sh --bootstrap-server 192.168.100.201:9093 --describe</span><br></pre></td></tr></table></figure>

<p>通过查看topic详细信息：</p>
<ul>
<li>leader是负责给定分区所有读写操作的节点。每个节点都是随机选择的部分分区的领导者。</li>
<li>replicas是复制分区日志的节点列表，不管这些节点是leader还是仅仅活着。</li>
<li>isr是一组“同步”replicas，是replicas列表的子集，它活着并被指到leader，即存活 的可以参与选举的节点。</li>
</ul>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220418172746373.png" alt="partitions=1,replication-factor=1"></p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220418172842985.png" alt="partitions=3,replication-factor=1"></p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220418172929723.png" alt="partitions=3,replication-factor=3"></p>
<h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><p>Kafka自带一个命令行客户端，它从文件或标准输入中获取输入，并将其作为message（消息）发送到Kafka集群。默认情况下，每行将作为单独的message发送。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启一个命令行客户端，输入消息并发送</span></span><br><span class="line">./bin/kafka-console-producer.sh --bootstrap-server 192.168.100.201:9093 --topic test</span><br></pre></td></tr></table></figure>

<h4 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启一个命令行客户端，接收消息并转换为标准输出，其中--from-beginning表示从头读取历史消息</span></span><br><span class="line">./bin/kafka-console-producer.sh --bootstrap-server 192.168.100.201:9093 --topic test --from-beginning</span><br></pre></td></tr></table></figure>

<h2 id="四、Kafka文件存储机制"><a href="#四、Kafka文件存储机制" class="headerlink" title="四、Kafka文件存储机制"></a>四、Kafka文件存储机制</h2><h3 id="1、topic中partition存储分布"><a href="#1、topic中partition存储分布" class="headerlink" title="1、topic中partition存储分布"></a>1、topic中partition存储分布</h3><p>假设实验环境中Kafka集群只有一个broker，kafka/kafka-logs为数据文件存储根目录，在Kafka broker中server.properties文件配置(参数log.dirs=kafka/kafka-logs)，例如创建2个topic名称分别为report_push、launch_info，partitions数量都为partitions=4 存储路径和目录规则为： kafka/kafka-logs</p>
<p>|–report_push-0<br>|–report_push-1<br>|–report_push-2<br>|–report_push-3<br>|–launch_info-0<br>|–launch_info-1<br>|–launch_info-2<br>|–launch_info-3</p>
<p>在Kafka文件存储中，同一个topic下有多个不同partition，每个partition为一个目录，partiton命名规则为topic名称+有序序号，第一个partiton序号从0开始，序号最大值为partitions数量减1。 如果是多broker分布情况会分散到不同的broker上，具体的分配规则和分配算法请看下面示例。</p>
<p>Kafka集群partition replication默认自动分配，以一个Kafka集群中4个Broker举例，创建1个topic包含4个Partition，2 Replication；数据Producer流动如图所示：</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220418225156907.png" alt="kafka集群partitions分配-1"></p>
<p>当集群中新增2节点，Partition增加到6个时分布情况如下：</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220418225256302.png" alt="kafka集群partitions分配-2"></p>
<p><strong>副本分配逻辑规则：</strong></p>
<ul>
<li>在Kafka集群中，每个Broker都有均等分配Partition的Leader机会。</li>
<li>上述图Broker Partition中，箭头指向为副本，以Partition-0为例:broker1中parition-0为Leader，Broker2中Partition-0为副本。</li>
<li>上述图中每个Broker(按照BrokerId有序)依次分配主Partition，下一个Broker为副本，如此循环迭代分配，多副本都遵循此规则。</li>
</ul>
<p><strong>副本分配算法：</strong></p>
<ul>
<li>将所有N Broker和待分配的i个Partition排序.</li>
<li>将第i个Partition分配到第(i mod n)个Broker上.</li>
<li>将第i个Partition的第j个副本分配到第((i + j) mod n)个Broker上.</li>
</ul>
<h3 id="2、partiton中文件存储方式"><a href="#2、partiton中文件存储方式" class="headerlink" title="2、partiton中文件存储方式"></a>2、partiton中文件存储方式</h3><p>下面示意图形象说明了partition中文件存储方式：</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220418225746332.png" alt="partition文件存储方式"></p>
<ul>
<li>每个partion(目录)相当于一个巨型文件被平均分配到多个大小相等segment(段)数据文件中。但每个段segment file消息数量不一定相等，这种特性方便old segment file快速被删除。</li>
<li>每个partiton只需要支持顺序读写就行了，segment文件生命周期由服务端配置参数决定。</li>
</ul>
<p>这样做的好处就是能快速删除无用文件，有效提高磁盘利用率。</p>
<h3 id="3、partiton中segment文件存储结构"><a href="#3、partiton中segment文件存储结构" class="headerlink" title="3、partiton中segment文件存储结构"></a>3、partiton中segment文件存储结构</h3><p>上面我们了解到Kafka文件系统partition存储方式，接下来深入分析partion中segment file组成和物理结构。</p>
<ul>
<li>segment file组成：由2大部分组成，分别为index file和data file，此2个文件一一对应，成对出现，后缀”.index”和“.log”分别表示为segment索引文件、数据文件.</li>
<li>segment文件命名规则：partion全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值。数值最大为64位long大小，19位数字字符长度，没有数字用0填充。</li>
</ul>
<p>下面文件列表是在Kafka broker上做的一个实验，创建一个topic包含1 partition，设置每个segment大小为500MB，并启动producer向Kafka broker写入大量数据，如图所示segment文件列表形象说明了上述2个规则：</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220418234049129.png" alt="segment文件列表"></p>
<p>以上述图中一对segment file文件为例，说明segment中index&lt;—-&gt;data file对应关系物理结构如下：</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220418234221467.png" alt="index与data关系"></p>
<p>上图中索引文件存储大量元数据，数据文件存储大量消息，索引文件中元数据指向对应数据文件中message的物理偏移地址。 其中以索引文件中元数据3,497为例，依次在数据文件中表示第3个message(在全局partiton表示第368772个message)、以及该消息的物理偏移地址为497。从上述图了解到segment data file由许多message组成，下面详细说明message物理结构如下：</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220418234403717.png" alt="message物理结构"></p>
<p>参数说明：</p>
<table>
<thead>
<tr>
<th align="left">关键字</th>
<th align="left">解释说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">8 byte offset</td>
<td align="left">在parition(分区)内的每条消息都有一个有序的id号，这个id号被称为偏移(offset)，它可以唯一确定每条消息在parition(分区)内的位置。即offset表示partiion的第多少message</td>
</tr>
<tr>
<td align="left">4 byte messagesize</td>
<td align="left">message大小</td>
</tr>
<tr>
<td align="left">4 byte CRC32</td>
<td align="left">用crc32校验message</td>
</tr>
<tr>
<td align="left">1 byte “magic”</td>
<td align="left">表示本次发布Kafka服务程序协议版本号</td>
</tr>
<tr>
<td align="left">1 byte “attributes”</td>
<td align="left">表示为独立版本、或标识压缩类型、或编码类型。</td>
</tr>
<tr>
<td align="left">4 byte key length</td>
<td align="left">表示key的长度，当key为-1时，K byte key字段不填</td>
</tr>
<tr>
<td align="left">K byte key</td>
<td align="left">可选</td>
</tr>
<tr>
<td align="left">value bytes payload</td>
<td align="left">表示实际消息数据。</td>
</tr>
</tbody></table>
<p><strong>查看segment 内容：</strong></p>
<p>kafka附带了一个叫DumpLogSegment的工具，可以用它查看片段的内容。它可以显示每个消息的偏移量、校验和、魔术数字节、消息大小和压缩算法。运行该工具的方式如下</p>
<p>/kafka-run-class.sh kafka.tools.DumpLogSegments</p>
<p>如果使用–deep-iteration参数，可以显示被压缩到包装消息里的消息。</p>
<p>–files参数，用于指定想查看的分区片段</p>
<p>–print-data-log参数，指定打印详细内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-run-class.sh kafka.tools.DumpLogSegments --files /kafka/kafka-logs/test-0/00000000000000000000.log  --print-data-log</span><br></pre></td></tr></table></figure>

<h3 id="4、在partition中如何通过offset查找message"><a href="#4、在partition中如何通过offset查找message" class="headerlink" title="4、在partition中如何通过offset查找message"></a>4、在partition中如何通过offset查找message</h3><p>例如读取offset=368776的message，需要通过下面2个步骤查找。</p>
<ul>
<li>第一步查找segment file 上述图2为例，其中00000000000000000000.index表示最开始的文件，起始偏移量(offset)为0.第二个文件00000000000000368769.index的消息量起始偏移量为368770= 368769 + 1。同样，第三个文件00000000000000737337.index的起始偏移量为737338=737337 + 1，其他后续文件依次类推，以起始偏移量命名并排序这些文件，只要根据offset 二分查找文件列表，就可以快速定位到具体文件。 当offset=368776时定位到00000000000000368769.index|log</li>
<li>第二步通过segment file查找message 通过第一步定位到segment file，当offset=368776时，依次定位到00000000000000368769.index的元数据物理位置和00000000000000368769.log的物理偏移地址，然后再通过00000000000000368769.log顺序查找直到offset=368776为止。</li>
</ul>
<p>从上述图3可知这样做的优点，segment index file采取稀疏索引存储方式，它减少索引文件大小，通过mmap可以直接内存操作，稀疏索引为数据文件的每个对应message设置一个元数据指针，它比稠密索引节省了更多的存储空间，但查找起来需要消耗更多的时间。</p>
<h2 id="五、Kafka运维手册"><a href="#五、Kafka运维手册" class="headerlink" title="五、Kafka运维手册"></a>五、Kafka运维手册</h2><h3 id="1、如何在Kafka上创建一个Topic"><a href="#1、如何在Kafka上创建一个Topic" class="headerlink" title="1、如何在Kafka上创建一个Topic"></a>1、如何在Kafka上创建一个Topic</h3><p><strong>脚本手工创建</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --create --topic test --bootstrap-server 192.168.100.201:9092 --partitions 1 --replication-factor 1</span><br></pre></td></tr></table></figure>

<p>–topic指定topic name</p>
<p>–partitions指定分区数，这个参数需要根据broker数和数据量决定，正常情况下，每个broker上两个partition最好；</p>
<p>–replication-factor指定partition的replicas数，建议设置为2；</p>
<p><strong>程序自动创建</strong></p>
<p>开启自动创建配置： auto.create.topics.enable=true</p>
<p>使用程序直接往kafka中相应的topic发送数据，如果topic不存在就会按默认配置进行创建。</p>
<p><strong>查看topic信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --describe --topic test --bootstrap-server 192.168.100.201:9092</span><br></pre></td></tr></table></figure>

<p><strong>发送消息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-console-producer.sh --bootstrap-server 192.168.100.201:9092 --topic test</span><br></pre></td></tr></table></figure>

<p><strong>消费消息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-console-consumer.sh --bootstrap-server 192.168.100.201:9092 --topic test --from-beginning</span><br></pre></td></tr></table></figure>

<h3 id="2、如何在Kafka上对一个Topic增加partition"><a href="#2、如何在Kafka上对一个Topic增加partition" class="headerlink" title="2、如何在Kafka上对一个Topic增加partition"></a>2、如何在Kafka上对一个Topic增加partition</h3><p>通过kafka-topics.sh工具的alter命令，将topic_test的partitions从1增加到2；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --bootstrap-server 192.168.10.201:9092 --alter --partitions 2 --topic test</span><br></pre></td></tr></table></figure>

<h3 id="3、如何在Kafka上对一个Topic增加replicas"><a href="#3、如何在Kafka上对一个Topic增加replicas" class="headerlink" title="3、如何在Kafka上对一个Topic增加replicas"></a>3、如何在Kafka上对一个Topic增加replicas</h3><p>操作步骤如下：<br>操作，是指手动写扩充replicas的配置文件，然后使用工具进行操作<br><strong>1.查看topic的详细信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --bootstrap-server 192.168.100.201:9092 --describe --topic test</span><br></pre></td></tr></table></figure>

<p>Topic: test TopicId: -h4ScOOXT6WvzasqGLJadQ PartitionCount: 2 ReplicationFactor: 1 Configs:<br>segment.bytes=1073741824<br>Topic: test Partition: 0  Leader: 1 Replicas: 1 Isr: 1<br>Topic: test Partition: 1  Leader: 2 Replicas: 2 Isr: 2</p>
<p>说明：<br>partiton： partion id，partition id 从 0 开始计数<br>leader：当前负责读写的 lead broker id<br>relicas：当前partition的所有 replication broker list<br>isr：relicas的子集，只包含处于活动状态的 broker</p>
<p><strong>2.修改配置文件</strong></p>
<p>将原有replicas为[0]扩充为[0,1], [1]扩充为[1,2]</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; partitions-to-move.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">"partitions": [&#123;</span><br><span class="line">"topic": "test",</span><br><span class="line">"partition": 0,</span><br><span class="line">"replicas": [0, 1]</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">"topic": "test",</span><br><span class="line">"partition": 1,</span><br><span class="line">"replicas": [1, 2]</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">"version": 1</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<p><strong>3.执行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-reassign-partitions.sh --bootstrap-server 192.168.100.201:9092 --reassignment-json-file partitions-to-move.json --execute</span><br></pre></td></tr></table></figure>

<p><strong>4.检查修改情况</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --bootstrap-server 192.168.100.201:9092 --describe --topic test</span><br></pre></td></tr></table></figure>

<p>Topic: test TopicId: -h4ScOOXT6WvzasqGLJadQ PartitionCount: 2 ReplicationFactor: 2 Configs:<br>segment.bytes=1073741824<br>Topic: test Partition: 0  Leader: 1 Replicas: 0,1 Isr: 1,0<br>Topic: test Partition: 1  Leader: 2 Replicas: 1,2 Isr: 2,1</p>
<h3 id="4、如何在Kafka中修改Topic的preferred-replica"><a href="#4、如何在Kafka中修改Topic的preferred-replica" class="headerlink" title="4、如何在Kafka中修改Topic的preferred replica"></a>4、如何在Kafka中修改Topic的preferred replica</h3><p><strong>操作背景</strong></p>
<p>假如topic test中partition 0的replicas为[0,1]，则0为preferred replica，应该成为leader。这时我们期望1为preferred replica，并变成leader。</p>
<p>执行步骤如下：</p>
<p><strong>1.查看当前的topic详细信息</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --bootstrap-server 192.168.100.201:9092 --describe --topic test</span><br></pre></td></tr></table></figure>

<p>Topic: test TopicId: -h4ScOOXT6WvzasqGLJadQ PartitionCount: 2 ReplicationFactor: 2 Configs:<br>segment.bytes=1073741824<br>Topic: test Partition: 0  Leader: 1 Replicas: 0,1 Isr: 1,0<br>Topic: test Partition: 1  Leader: 2 Replicas: 1,2 Isr: 2,1</p>
<p><strong>2.修改replicas的顺序</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; partitions-to-move-2.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">"partitions": [</span><br><span class="line">&#123;</span><br><span class="line">"topic": "test",</span><br><span class="line">"partition": 0,</span><br><span class="line">"replicas": [</span><br><span class="line">1,</span><br><span class="line">0</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">"version": 1</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-reassign-partitions.sh --bootstrap-server 192.168.100.201:9092 --reassignment-json-file partitions-to-move-2.json --execute</span><br></pre></td></tr></table></figure>

<p><strong>3.更改leader</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; topicPartitionList.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">"partitions":</span><br><span class="line">[</span><br><span class="line">&#123;"topic": "test", "partition": 0&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-leader-election.sh --bootstrap-server 192.168.100.201:9092 --path-to-json-file topicPartitionList.json --election-type PREFERRED</span><br></pre></td></tr></table></figure>

<p><strong>4.检查replicas leader切换情况</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --bootstrap-server 192.168.100.201:9092 --describe --topic test</span><br></pre></td></tr></table></figure>

<p>Topic: test TopicId: -h4ScOOXT6WvzasqGLJadQ PartitionCount: 2 ReplicationFactor: 2 Configs:<br>segment.bytes=1073741824<br>Topic: test Partition: 0  Leader: 0 Replicas: 0,1 Isr: 1,0<br>Topic: test Partition: 1  Leader: 2 Replicas: 1,2 Isr: 2,1</p>
<h3 id="5、如何在Kafka中对Topic的leader进行均衡"><a href="#5、如何在Kafka中对Topic的leader进行均衡" class="headerlink" title="5、如何在Kafka中对Topic的leader进行均衡"></a>5、如何在Kafka中对Topic的leader进行均衡</h3><p><strong>操作背景</strong></p>
<p>在创建一个topic时，kafka尽量将partition均分在所有的brokers上，并且将replicas也均分在不同的broker上。</p>
<p>每个partition的所有replicas叫做”assigned replicas”，”assigned replicas”中的第一个replicas叫”preferred replica”，刚创建的topic一般”preferred replica”是leader。leader replica负责所有的读写。</p>
<p>但随着时间推移，broker可能会停机，会导致leader迁移，导致机群的负载不均衡。我们期望对topic的leader进行重新负载均衡，让partition选择”preferred replica”做为leader。</p>
<p><strong>1.对所有Topics进行操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-leader-election.sh --bootstrap-server 192.168.100.201:9092 --election-type PREFERRED --all-topic-partitions</span><br></pre></td></tr></table></figure>

<p><strong>2.对某个Topic进行操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &gt; topicPartitionList.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">"partitions":</span><br><span class="line">[</span><br><span class="line">&#123;"topic":"test","partition": "0"&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-leader-election.sh --bootstrap-server 192.168.100.201:9092 --path-to-json-file topicPartitionList.json --election-type PREFERRED</span><br></pre></td></tr></table></figure>

<h3 id="6、apache-kafka中topic级别配置"><a href="#6、apache-kafka中topic级别配置" class="headerlink" title="6、apache kafka中topic级别配置"></a>6、apache kafka中topic级别配置</h3><p><strong>1.topic级别配置用法</strong></p>
<p>配置topic级别参数时，相同(参数)属性topic级别会覆盖全局的，否则默认为全局配置属性值。</p>
<p>创建topic参数可以设置一个或多个–config “Property(属性)”,下面是创建一个topic名称为”my-topic”例子，它设置了2个参数max message size 和 flush rate:</p>
<ul>
<li>创建topic时配置参数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --create --topic my-topic --bootstrap-server 192.168.100.201:9092 --partitions 1 --replication-factor 1 --config max.message.bytes=64000 --config flush.messages=1</span><br></pre></td></tr></table></figure>

<ul>
<li>修改topic时配置参数</li>
</ul>
<p>覆盖已经有topic参数，下面例子修改”my-topic”的max message属性</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --alter --topic my-topic --bootstrap-server 192.168.100.201:9092 --config max.message.bytes=128000</span><br></pre></td></tr></table></figure>

<ul>
<li>删除topic级别配置参数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-topics.sh --alter --topic my-topic --bootstrap-server 192.168.100.201:9092 --delete-config max.message.bytes</span><br></pre></td></tr></table></figure>

<ul>
<li>topic级别在zookeeper存储结构</li>
</ul>
<p>“my-topic”在zookeeper上路径为/config/topics/my-topic,存储内容如下：</p>
<p>{<br>    “version”: 1,<br>    “config”: {<br>        “max.message.bytes”: “12800000”,<br>        “flush.messages”: “1000”<br>    }<br>}</p>
<p><strong>2.topic级别配置属性表</strong></p>
<p>以下是topic级别配置， kafak server中默认配置为下表“Server Default Property”列，当需要设置topic级别配置时，属性设置为“Property(属性)”列</p>
<table>
<thead>
<tr>
<th>Property(属性)</th>
<th>Default(默认值)</th>
<th>Server Default Property(server.properties)</th>
<th>说明(解释)</th>
</tr>
</thead>
<tbody><tr>
<td>cleanup.policy</td>
<td>delete</td>
<td>log.cleanup.policy</td>
<td>日志清理策略选择有：delete和compact主要针对过期数据的处理，或是日志文件达到限制的额度，会被topic创建时的指定参数覆盖</td>
</tr>
<tr>
<td>delete.retention.ms</td>
<td>86400000(24 hours)</td>
<td>log.cleaner.delete.retention.ms</td>
<td>对于压缩的日志保留的最长时间，也是客户端消费消息的最长时间，同log.retention.minutes的区别在于一个控制未压缩数据，一个控制压缩后的数据。会被topic创建时的指定参数覆盖</td>
</tr>
<tr>
<td>flush.messages</td>
<td>None</td>
<td>log.flush.interval.messages</td>
<td>log文件”sync”到磁盘之前累积的消息条数,因为磁盘IO操作是一个慢操作,但又是一个”数据可靠性”的必要手段,所以此参数的设置,需要在”数据可靠性”与”性能”之间做必要的权衡.如果此值过大,将会导致每次”fsync”的时间较长(IO阻塞),如果此值过小,将会导致”fsync”的次数较多,这也意味着整体的client请求有一定的延迟.物理server故障,将会导致没有fsync的消息丢失.</td>
</tr>
<tr>
<td>flush.ms</td>
<td>None</td>
<td>log.flush.interval.ms</td>
<td>仅仅通过interval来控制消息的磁盘写入时机,是不足的.此参数用于控制”fsync”的时间间隔,如果消息量始终没有达到阀值,但是离上一次磁盘同步的时间间隔达到阀值,也将触发.</td>
</tr>
<tr>
<td>index.interval.bytes</td>
<td>4096</td>
<td>log.index.interval.bytes</td>
<td>当执行一个fetch操作后，需要一定的空间来扫描最近的offset大小，设置越大，代表扫描速度越快，但是也更耗内存，一般情况下不需要搭理这个参数</td>
</tr>
<tr>
<td>message.max.bytes</td>
<td>1,000,000</td>
<td>message.max.bytes</td>
<td>表示消息的最大大小，单位是字节</td>
</tr>
<tr>
<td>min.cleanable.dirty.ratio</td>
<td>0.5</td>
<td>log.cleaner.min.cleanable.ratio</td>
<td>日志清理的频率控制，越大意味着更高效的清理，同时会存在一些空间上的浪费，会被topic创建时的指定参数覆盖</td>
</tr>
<tr>
<td>retention.bytes</td>
<td>None</td>
<td>log.retention.bytes</td>
<td>topic每个分区的最大文件大小，一个topic的大小限制 = 分区数*log.retention.bytes。-1没有大小限log.retention.bytes和log.retention.minutes任意一个达到要求，都会执行删除，会被topic创建时的指定参数覆盖</td>
</tr>
<tr>
<td>retention.ms</td>
<td>None</td>
<td>log.retention.minutes</td>
<td>数据存储的最大时间超过这个时间会根据log.cleanup.policy设置的策略处理数据，也就是消费端能够多久去消费数据log.retention.bytes和log.retention.minutes达到要求，都会执行删除，会被topic创建时的指定参数覆盖</td>
</tr>
<tr>
<td>segment.bytes</td>
<td>1 GB</td>
<td>log.segment.bytes</td>
<td>topic的分区是以一堆segment文件存储的，这个控制每个segment的大小，会被topic创建时的指定参数覆盖</td>
</tr>
<tr>
<td>segment.index.bytes</td>
<td>10 MB</td>
<td>log.index.size.max.bytes</td>
<td>对于segment日志的索引文件大小限制，会被topic创建时的指定参数覆盖</td>
</tr>
<tr>
<td>log.roll.hours</td>
<td>7 days</td>
<td>log.roll.hours</td>
<td>这个参数会在日志segment没有达到log.segment.bytes设置的大小，也会强制新建一个segment会被 topic创建时的指定参数覆盖</td>
</tr>
</tbody></table>
<h3 id="7、apache-Kafka下线broker的操作"><a href="#7、apache-Kafka下线broker的操作" class="headerlink" title="7、apache Kafka下线broker的操作"></a>7、apache Kafka下线broker的操作</h3><p><strong>操作背景</strong></p>
<p>主动下线是指broker运行正常，因为机器需要运维（升级操作系统，添加磁盘等）而主动停止broker，分两种情况处理：</p>
<ul>
<li>所有的topic的replica &gt;= 2</li>
</ul>
<p>此时，直接停止一个broker，会自动触发leader election操作，不过目前leader election是逐个partition进行，等待所有partition完成leader election耗时较长，这样不可服务的时间就比较长。为了缩短不可服务时间窗口，可以主动触发停止broker操作，这样可以逐个partition转移，直到所有partition完成转移，再停止broker。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-run-class.sh kafka.admin.ShutdownBroker --bootstrap-server 192.168.100.201:9092 --broker #brokerId# --num.retries 3 --retry.interval.ms 60</span><br></pre></td></tr></table></figure>

<p>然后shutdown broker。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./bin/kafka-server-stop.sh</span><br></pre></td></tr></table></figure>

<ul>
<li>存在topic的replica=1</li>
</ul>
<p>当存在topic的副本数小于2，只能手工把当前broker上这些topic对应的partition转移到其他broker上。当此broker上剩余的topic的replica &gt; 2时，参照上面的处理方法继续处理。</p>
<h2 id="六、Kafka中Follower如何与Leader同步数据"><a href="#六、Kafka中Follower如何与Leader同步数据" class="headerlink" title="六、Kafka中Follower如何与Leader同步数据"></a>六、Kafka中Follower如何与Leader同步数据</h2><h3 id="1、重要名词解释："><a href="#1、重要名词解释：" class="headerlink" title="1、重要名词解释："></a>1、重要名词解释：</h3><p>log end offset (logEndOffset)，表示log中最后的message的offst位置。</p>
<p>high watermark (HW)，表示Partition各个replicas数据间同步且一致的offset位置，即表示allreplicas已经commit位置，每个Broker缓存中维护此信息,并不断更新。</p>
<h3 id="2、Kafka中replication复制数据"><a href="#2、Kafka中replication复制数据" class="headerlink" title="2、Kafka中replication复制数据"></a>2、Kafka中replication复制数据</h3><p>Kafka的复制机制既不是完全的同步复制，也不是单纯的异步复制。完全同步复制要求All Alive Follower都复制完，这条消息才会被认为commit，这种复制方式极大的影响了吞吐率。而异步复制方式下，Follower异步的从Leader复制数据，数据只要被Leader写入log就被认为已经commit，这种情况下如果Follower都复制完都落后于Leader，而如果Leader突然宕机，则会丢失数据。而Kafka的这种使用ISR的方式则很好的均衡了确保数据不丢失以及吞吐率。Follower可以批量的从Leader复制数据，而且Leader充分利用磁盘顺序读以及send file(zero copy)机制，这样极大的提高复制性能，内部批量写磁盘，大幅减少了Follower与Leader的消息量差。</p>
<p><strong>优点</strong></p>
<ul>
<li>性能高，吞吐量大。</li>
<li>降低了系统和磁盘开销，Leader充分利用磁盘顺序读以及send file(zero copy)机制。</li>
<li>降低Leader与Follower之间网络开销和交互次数。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>有可能会占用大量网络带宽(例如本来集群很大而且数据量很多，后来新增Broker节点需要迁移数据)，甚至堵塞网络，需要有流控机制，否则会影响线上服务。</li>
<li>因为Follower是批量拉取Leader消息，如果设置为保证所有replicas commit，才返回Ack给生产者会存在抖动现象，Follow拉取Leader修改HW，当HW与当次生产者请求logEndOffset的offst一致时，客户端等待时间会拉长。</li>
</ul>
<h3 id="3、kafka集群副本分布原理分析"><a href="#3、kafka集群副本分布原理分析" class="headerlink" title="3、kafka集群副本分布原理分析"></a>3、kafka集群副本分布原理分析</h3><p>Kafka中partition replication之间同步数据，从partition的leader复制数据到follower只需要一个线程(ReplicaFetcherThread)，实际上复制是follower(一个follower相当于consumer)主动从leader批量拉取消息的，这极大提高了吞吐量，从中可以看出无处不显示Kafka高吞吐量设计思想。</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220419104738306.png" alt></p>
<p>这是一个异步复制过程，follow从leader批量拉取消息进行同步数据</p>
<p><strong>Kafka中partition replica复制机制：</strong></p>
<p>Kafka中每个Broker启动时都会创建一个副本管理服务(ReplicaManager)，该服务负责维护ReplicaFetcherThread与其他Broker链路连接关系，该Broker中存在多少Follower的partitions对应leader partitions分布在不同的Broker上，有多少Broker就会创建相同数量的ReplicaFetcherThread线程同步对应partition数据，Kafka中partition间复制数据是由follower(扮演consumer角色)主动向leader获取消息，follower每次读取消息都会更新HW状态。每当Follower的partitions发生变更影响leader所在Broker变化时，ReplicaManager就会新建或销毁相应的ReplicaFetcherThread。</p>
<p>Kafka Broker中follower partition与ReplicaFetcherThread对应关系</p>
<p>partition三副本情况：</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220419104936169.png" alt></p>
<p>partition两副本情况：</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220419104953319.png" alt></p>
<p><strong>Kafka中partitions数据一致性：</strong></p>
<p>Kafka中Producer发送消息到Broker，Broker有三种返回方式，分别为noack、leader commit成功就ack、leader和follower同时commit成功才返回ack。第三种方式是数据强一致性。</p>
<p><strong>如何保证数据强一致性？</strong></p>
<p>当Producer发送消息到leader partition所在Broker时，首先保证leader commit消息成功，然后创建一个“生产者延迟请求任务”，并判断当前partiton的HW是否大于等于logEndOffset，如果满足条件即表示本次Producer请求partition replicas之间数据已经一致，立即向Producer返回Ack。否则待Follower批量拉取Leader的partition消息时，同时更新Leader ISR中HW，然后检查是否满足上述条件，如果满足向Producer返回Ack。</p>
<h2 id="七、Kafka-Broker-HA机制"><a href="#七、Kafka-Broker-HA机制" class="headerlink" title="七、Kafka Broker HA机制"></a>七、Kafka Broker HA机制</h2><p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220420154417487.png" alt="HA机制"></p>
<p>从图中我们可以看出HA的缓存分为生产缓存事件池和拉取缓存事件池两块结构相同的缓存区，分别缓存生产和拉取请求。2个缓存事件池的作用：</p>
<ul>
<li>生产缓存事件池：当生产者设置了等待从partition的同步选项(requiredAcks为-1，即等待所有ISR接收到消息后确认ACK)时才会启动生产缓存。因为每一批生产的消息，需要等待所有的处于同步状态的从partition（in-sync）同步成功，在所有follow partition上报自己的水位线追上leader partition之前，生产请求会一直保留在生产缓存中，等待直到超时。</li>
<li>拉取缓存事件池：拉取请求为什么也需要缓存？因为kafka在消费消息时有一个默认选项，一次拉取最低消费1条消息。那么，如果消费者拉取的时候没有任何新消息生产，则拉取请求会保留到拉取缓存中，等待直到超时。这一定程度上避免了反复拉取一批空消息占用带宽资源的问题，不过也把Kafka的ha缓存架构的复杂度提升了一个等级。</li>
</ul>
<h2 id="八、Kafka副本同步机制理解"><a href="#八、Kafka副本同步机制理解" class="headerlink" title="八、Kafka副本同步机制理解"></a>八、Kafka副本同步机制理解</h2><p>Apache Kafka的流行归功于它设计和操作简单、存储系统高效、充分利用磁盘顺序读写等特性、非常适合在线日志收集等高吞吐场景。</p>
<p>Apache Kafka特性之一是它的复制协议。对于单个集群中每个Broker不同工作负载情况下，如何自动调优Kafka副本的工作方式是比较有挑战的。它的挑战之一是要知道如何避免follower进入和退出同步副本列表(即ISR)。从用户的角度来看，如果生产者发送一大批海量消息，可能会引起Kafka Broker很多警告。这些警报表明一些topics处于“under replicated”状态，这些副本处于同步失败或失效状态，更意味着数据没有被复制到足够数量Broker从而增加数据丢失的概率。因此Kafka集群中处于“underreplicated”中Partition数要密切监控。这个警告应该来自于Broker失效，减慢或暂停等状态而不是生产者写不同大小消息引起的。在这篇文章中，我将讨论这种问题的根源以及我们如何修复它。</p>
<h3 id="Kafka副本"><a href="#Kafka副本" class="headerlink" title="Kafka副本"></a>Kafka副本</h3><p>Kafka中主题的每个Partition有一个预写式日志文件，每个Partition都由一系列有序的、不可变的消息组成，这些消息被连续的追加到Partition中，Partition中的每个消息都有一个连续的序列号叫做offset，确定它在分区日志中唯一的位置。</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220420154639297.png" alt></p>
<p>Kafka每个topic的partition有N个副本，其中N是topic的复制因子。Kafka通过多副本机制实现故障自动转移，当Kafka集群中一个Broker失效情况下仍然保证服务可用。在Kafka中发生复制时确保partition的预写式日志有序地写到其他节点上。N个replicas中。其中一个replica为leader，其他都为follower，leader处理partition的所有读写请求，与此同时，follower会被动定期地去复制leader上的数据。</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220420154715977.png" alt></p>
<p>Kafka必须提供数据复制算法保证，如果leader发生故障或挂掉，一个新leader被选举并接收客户端的消息成功写入。Kafka确保从同步副本列表中选举一个副本为leader，或者换句话说，follower追赶leader数据。leader负责维护和跟踪ISR中所有follower滞后状态。当生产者发送一条消息到Broker，leader写入消息并复制到所有follower。消息提交之后才被成功复制到所有的同步副本。消息复制延迟受最慢的follower限制，重要的是快速检测慢副本，如果follower”落后”太多或者失效，leader将会把它从replicas从ISR移除。</p>
<h3 id="partition的follower追上leader含义"><a href="#partition的follower追上leader含义" class="headerlink" title="partition的follower追上leader含义"></a>partition的follower追上leader含义</h3><p>Kafka中每个partition的follower没有“赶上”leader的日志可能会从同步副本列表中移除。下面用一个例子解释一下“追赶”到底是什么意思。</p>
<p>请看一个例子：主题名称为foo 1 partition 3 replicas。假如partition的replication分布在Brokers 1、2和3上，并且Broker 3消息已经成功提交。同步副本列表中1为leader、2和3为follower。假设replica.lag.max.messages设置为4，表明只要follower落后leader不超过3，就不会从同步副本列表中移除。replica.lag.time.max设置为500 ms，表明只要follower向leader发送请求时间间隔不超过500ms，就不会被标记为死亡，也不会从同步副本列中移除。</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220420155358841.png" alt></p>
<p>下面看看，生产者发送下一条消息写入leader，与此同时follower Broker 3 GC暂停，如下图所示:</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220420155425552.png" alt></p>
<p>直到follower Broker 3从同步副本列表中移除或追赶上leader log end offset，最新的消息才会认为提交。注意，因为follower Broker 3小于replica.lag.max.messages= 4落后于leader Broker 1，Kafka不会从同步副本列表中移除。在这种情况下，这意味着follower Broker 3需要迎头追赶上直到offset = 6，如果是，那么它完全“赶上” leader Broker 1 log end offset。让我们假设代理3出来的GC暂停在100 ms和追赶上领袖的日志结束偏移量。在这种状态下，下面partition日志会看起来像这样</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220420155537150.png" alt></p>
<h3 id="是什么原因导致分区的副本与leader不同步"><a href="#是什么原因导致分区的副本与leader不同步" class="headerlink" title="是什么原因导致分区的副本与leader不同步"></a>是什么原因导致分区的副本与leader不同步</h3><p><strong>一个副本可以不同步Leader有如下几个原因</strong></p>
<ul>
<li>慢副本：在一定周期时间内follower不能追赶上leader。最常见的原因之一是I / O瓶颈导致follower追加复制消息速度慢于从leader拉取速度。</li>
<li>卡住副本：在一定周期时间内follower停止从leader拉取请求。follower replica卡住了是由于GC暂停或follower失效或死亡。</li>
<li>新启动副本：当用户给主题增加副本因子时，新的follower不在同步副本列表中，直到他们完全赶上了leader日志。</li>
</ul>
<p>一个partition的follower落后于leader足够多时，被认为不在同步副本列表或处于滞后状态。在Kafka-0.8.2.x中，副本滞后判断依据是副本落后于leader最大消息数量(replica.lag.max.messages)或replicas响应partition leader的最长等待时间(replica.lag.time.max.ms)。前者是用来检测缓慢的副本，而后者是用来检测失效或死亡的副本</p>
<p><strong>如何确定副本是滞后的</strong></p>
<p>这个模型检测不同步卡住副本列表工作下所有情况都适用。它追踪follower replica时间内没有向leader发送拉取请求，表明它已经死了。另一方面，如果均匀流量模式情况下，为一个主题或多个主题设置这些参数检测模型不同步慢副本列表消息的数量会工作很好，但我们发现生产环境中它不扩展到所有主题各种工作负载。</p>
<p>接着上面的例子，如果主题foo获取数据速率2 msg/sec，leader单次批量接收一般不会超过3条消息，然后你知道主题参数replica.lag.max.messages设置为4。为什么?因为follower replica从leader复制消息前，已经有大批量消息写leader，follower replica落后于leader不超过3条消息 。另一方面，如果主题foo的follower replica初始落后于leader持续超过3消息，leader会从同步副本列表中移除慢副本，避免消息写延迟增加。</p>
<p>这本质上是replica.lag.max.messages的目标。能够检测follower与leader不一致且从同步副本列表移除。然而，主题在流量高峰期发送了一批消息(4条消息)，等于replica.lag.max.messages = 4配置值。在那一瞬间，2个follower replica将被认为是”out-of-sync”并且leader会从同步副本列表中移除。</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220420155745344.png" alt></p>
<p>2个follower replica都是活着，下次拉取请求他们会赶上leader log end offset并重新加入同步副本列表。重复相同的过程，如果生产者继续发送相对一批较大消息到leader。这种情况演示了当followerreplica频繁在从同步副本列表移除和重新加入同步副本列表之间来回切换时，不必要触发虚假警报。</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220420155811743.png" alt></p>
<p>参数replica.lag.max.messages指向核心问题。它的配置值根据队列流量大小和集群一般负载情况做出判断并设置一个合适值!</p>
<p><strong>副本配置规则</strong></p>
<p>真正重要的事情是检测卡或慢副本，这段时间follower replica是“out-of-sync”落后于leader。在服务端现在只有一个参数需要配置replica.lag.time.max.ms。这个参数解释replicas响应partitionleader的最长等待时间。检测卡住或失败副本的探测——如果一个replica失败导致发送拉取请求时间间隔超过replica.lag.time.max.ms。Kafka会认为此replica已经死亡会从同步副本列表从移除。检测慢副本机制发生了变化——如果一个replica开始落后leader超过replica.lag.time.max.ms。Kafka会认为太缓慢并且会从同步副本列表中移除。除非replica请求leader时间间隔大于replica.lag.time.max.ms，因此即使leader使流量激增和大批量写消息。Kafka也不会从同步副本列表从移除该副本。</p>
<h2 id="九、Kafka数据可靠性与一致性解析"><a href="#九、Kafka数据可靠性与一致性解析" class="headerlink" title="九、Kafka数据可靠性与一致性解析"></a>九、Kafka数据可靠性与一致性解析</h2><h3 id="1-Partition-Recovery机制"><a href="#1-Partition-Recovery机制" class="headerlink" title="1.Partition Recovery机制"></a>1.Partition Recovery机制</h3><p>每个Partition会在磁盘记录一个RecoveryPoint， 记录已经flush到磁盘的最大offset。当broker fail 重启时，会进行loadLogs。 首先会读取该Partition的RecoveryPoint，找到包含RecoveryPoint的segment及以后的segment， 这些segment就是可能没有完全flush到磁盘segments。然后调用segment的recover，重新读取各个segment的msg，并重建索引。</p>
<p><strong>优点：</strong></p>
<ul>
<li>以segment为单位管理Partition数据，方便数据生命周期的管理，删除过期数据简单</li>
<li>在程序崩溃重启时，加快recovery速度，只需恢复未完全flush到磁盘的segment</li>
<li>通过index中offset与物理偏移映射，用二分查找能快速定位msg，并且通过分多个Segment，每个index文件很小，查找速度更快。</li>
</ul>
<h3 id="2-Partition-Replica同步机制"><a href="#2-Partition-Replica同步机制" class="headerlink" title="2.Partition Replica同步机制"></a>2.Partition Replica同步机制</h3><ul>
<li>Partition的多个replica中一个为Leader，其余为follower</li>
<li>Producer只与Leader交互，把数据写入到Leader中</li>
<li>Followers从Leader中拉取数据进行数据同步</li>
<li>Consumer只从Leader拉取数据</li>
</ul>
<p>ISR：所有不落后的replica集合， 不落后有两层含义：距离上次FetchRequest的时间不大于某一个值或落后的消息数不大于某一个值， Leader失败后会从ISR中选取一个Follower做Leader</p>
<h3 id="3-数据可靠性保证"><a href="#3-数据可靠性保证" class="headerlink" title="3.数据可靠性保证"></a>3.数据可靠性保证</h3><p>当Producer向Leader发送数据时，可以通过acks参数设置数据可靠性的级别</p>
<ul>
<li>0：不论写入是否成功，server不需要给Producer发送Response，如果发生异常，server会终止连接，触发Producer更新meta数据；</li>
<li>1：Leader写入成功后即发送Response，此种情况如果Leader fail，会丢失数据</li>
<li>-1：等待所有ISR接收到消息后再给Producer发送Response，这是最强保证仅设置acks=-1也不能保证数据不丢失，当Isr列表中只有Leader时，同样有可能造成数据丢失。</li>
</ul>
<p>要保证数据不丢除了设置acks=-1， 还要保 证ISR的大小大于等于2，具体参数设置：</p>
<ol>
<li>request.required.acks：设置为-1 等待所有ISR列表中的Replica接收到消息后采算写成功；</li>
<li>min.insync.replicas：设置为大于等于2，保证ISR中至少有两个Replica Producer要在吞吐率和数据可靠性之间做一个权衡</li>
</ol>
<h3 id="4-数据一致性保证"><a href="#4-数据一致性保证" class="headerlink" title="4.数据一致性保证"></a>4.数据一致性保证</h3><p>一致性定义：若某条消息对Consumer可见，那么即使Leader宕机了，在新Leader上数据依然可以被读到</p>
<ul>
<li>HighWaterMark简称HW： Partition的高水位，取一个partition对应的ISR中最小的LEO作为HW，消费者最多只能消费到HW所在的位置，另外每个replica都有highWatermark，leader和follower各自负责更新自己的highWatermark状态，highWatermark &lt;= leader. LogEndOffset</li>
<li>对于Leader新写入的msg，Consumer不能立刻消费，Leader会等待该消息被所有ISR中的replica同步后，更新HW，此时该消息才能被Consumer消费，即Consumer最多只能消费到HW位置</li>
</ul>
<p>这样就保证了如果Leader Broker失效，该消息仍然可以从新选举的Leader中获取。对于来自内部Broker的读取请求，没有HW的限制。同时，Follower也会维护一份自己的HW，Folloer.HW =min(Leader.HW， Follower.offset)</p>
<h2 id="十、Kafka性能为什么这么快？"><a href="#十、Kafka性能为什么这么快？" class="headerlink" title="十、Kafka性能为什么这么快？"></a>十、Kafka性能为什么这么快？</h2><h3 id="1-顺序读写"><a href="#1-顺序读写" class="headerlink" title="1. 顺序读写"></a>1. 顺序读写</h3><p>随机I/O和顺序I/O的。什么叫随机I/O</p>
<p>磁盘寻址的过程，磁盘的盘片不停的旋转，磁头会在磁盘表面画出一个圆形轨迹，这个就叫<strong>磁道</strong>。从内到外半径不同有很多磁道。然后又有半径线，把磁道分割成了<strong>扇区</strong>（两根射线之内的扇区组成扇面）。如果要读写数据，必须找到数据对应的扇区，这个过程就叫寻址。</p>
<p><img src="/2022/04/12/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6-2-kafka/image-20220523235233229.png" alt="磁盘构造"></p>
<p>随机I/O：读写的多条数据在磁盘上是分散的，寻址会很耗时。</p>
<p>顺序I/O：读写的数据在磁盘上是集中的，不需要重复寻址的过程。</p>
<p>Kafka的message是不断追加到本地磁盘文件末尾的，而不是随机的写入，这是的Kafka写入吞吐量得到了显著提升。</p>
<h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2.索引"></a>2.索引</h3><p>Kafka中设计了两种索引：偏移量索引和时间戳索引。</p>
<p>偏移量索引文件记录的是offset和消息物理地址（在log文件中的位置）的映射关系。时间戳索引文件记录的是时间戳和offset的关系。<strong>注意：Kafka的索引并不是每一条消息都会建立索引，而是一种稀疏索引（sparse index）。</strong></p>
<h3 id="3-批量读写和文件压缩"><a href="#3-批量读写和文件压缩" class="headerlink" title="3.批量读写和文件压缩"></a>3.批量读写和文件压缩</h3><p>它把所有的消息都变成一个批量的文件，并且进行合理的批量压缩，减少网络I/O损耗。</p>
<h3 id="4-零拷贝"><a href="#4-零拷贝" class="headerlink" title="4.零拷贝"></a>4.零拷贝</h3><h2 id="面试题："><a href="#面试题：" class="headerlink" title="面试题："></a>面试题：</h2><p><strong>1、kafka如何做到高吞吐低延迟</strong></p>
<p>总结起来，主要是四点：磁盘顺序I/O、索引机制、批量操作和压紧、零拷贝。</p>
<p><strong>2、如何保证kafka消息不丢失</strong></p>
<ol>
<li>producer端使用producer.send(msg, callback)带有回调的send方法，而不是producer.send(msg)方法。根据回调，一旦出现消息提交失败的情况，就可以有针对性的进行处理。</li>
<li>设置acks = all。acks是Producer的一个参数，代表“已提交”消息的定义。如果设置成all，则表明所有Broker都要接收到消息，该消息才算是“已提交”。</li>
<li>设置retries为一个较大的值。同样是Producer的参数。当出现网络抖动时，消息发送可能会失败，此时配置了retries的Producer能够自动重试发送消息，尽量避免消息丢失。</li>
<li>设置unclean.leader.election.enable = false。即如果分区leader发生故障时，不允许ISR之外的副本参与选举，因为ISR之外的副本并未完全同步leader的消息，会造成数据丢失。</li>
<li>设置replication.factor &gt;= 3。即需要三个以上的副本。</li>
<li>设置min.insync.replicas &gt; 1。Broker端参数，控制消息至少要被写入到多少个副本才算是“已提交”。设置成大于1可以提升消息持久性。在生产库安静中不要使用默认值1.确保replication.factor &gt; min.insync.replicas。如果两者相等，那么只要有一个副本离线，整个分区就无法正常工作了。推荐设置成replication.factor = min.insync.replicas + 1。</li>
<li>确保消息消费完成再提交。Consumer端有个参数enable.auto.commit，最好设置成false，并自己来处理offset的提交更新。</li>
</ol>
]]></content>
      <categories>
        <category>消息中间件</category>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
</search>
